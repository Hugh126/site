{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"source/images/Autowired1.png","path":"images/Autowired1.png","modified":0,"renderable":0},{"_id":"source/images/6f68e8517ae6e68ac63f4a34b8d14ca5.png","path":"images/6f68e8517ae6e68ac63f4a34b8d14ca5.png","modified":0,"renderable":0},{"_id":"source/images/Autowired10.png","path":"images/Autowired10.png","modified":0,"renderable":0},{"_id":"source/images/Autowired2.png","path":"images/Autowired2.png","modified":0,"renderable":0},{"_id":"source/images/Autowired4.png","path":"images/Autowired4.png","modified":0,"renderable":0},{"_id":"source/images/Autowired3.png","path":"images/Autowired3.png","modified":0,"renderable":0},{"_id":"source/images/Autowired5.png","path":"images/Autowired5.png","modified":0,"renderable":0},{"_id":"source/images/Autowired6.png","path":"images/Autowired6.png","modified":0,"renderable":0},{"_id":"source/images/Autowired7.png","path":"images/Autowired7.png","modified":0,"renderable":0},{"_id":"source/images/Autowired8.png","path":"images/Autowired8.png","modified":0,"renderable":0},{"_id":"source/images/Autowired9.png","path":"images/Autowired9.png","modified":0,"renderable":0},{"_id":"source/images/DDD四层模型.jpg","path":"images/DDD四层模型.jpg","modified":0,"renderable":0},{"_id":"source/images/SSE浏览器请求.png","path":"images/SSE浏览器请求.png","modified":0,"renderable":0},{"_id":"source/images/ScheduledAnnotationBeanPostProcessor-scope_prototype无法注入定时任务.png","path":"images/ScheduledAnnotationBeanPostProcessor-scope_prototype无法注入定时任务.png","modified":0,"renderable":0},{"_id":"source/images/ScheduledAnnotationBeanPostProcessor-单例bean可以注入.png","path":"images/ScheduledAnnotationBeanPostProcessor-单例bean可以注入.png","modified":0,"renderable":0},{"_id":"source/images/Scheduled定时任务注册.png","path":"images/Scheduled定时任务注册.png","modified":0,"renderable":0},{"_id":"source/images/TiDB-01.png","path":"images/TiDB-01.png","modified":0,"renderable":0},{"_id":"source/images/arthas1.png","path":"images/arthas1.png","modified":0,"renderable":0},{"_id":"source/images/arthas2.png","path":"images/arthas2.png","modified":0,"renderable":0},{"_id":"source/images/beanFactory加载不到Scheduled的BeanPostProcessor.png","path":"images/beanFactory加载不到Scheduled的BeanPostProcessor.png","modified":0,"renderable":0},{"_id":"source/images/datax1.png","path":"images/datax1.png","modified":0,"renderable":0},{"_id":"source/images/gradle-command.png","path":"images/gradle-command.png","modified":0,"renderable":0},{"_id":"source/images/gradle-idea-config.png","path":"images/gradle-idea-config.png","modified":0,"renderable":0},{"_id":"source/images/scheduled_5_1.png","path":"images/scheduled_5_1.png","modified":0,"renderable":0},{"_id":"source/images/scheduled_5_3.png","path":"images/scheduled_5_3.png","modified":0,"renderable":0},{"_id":"source/images/scheduled_5_4.png","path":"images/scheduled_5_4.png","modified":0,"renderable":0},{"_id":"source/images/scheduled_5_2.png","path":"images/scheduled_5_2.png","modified":0,"renderable":0},{"_id":"source/images/scheduled_5_5.png","path":"images/scheduled_5_5.png","modified":0,"renderable":0},{"_id":"source/images/schedule执行.png","path":"images/schedule执行.png","modified":0,"renderable":0},{"_id":"source/images/skywalking1.png","path":"images/skywalking1.png","modified":0,"renderable":0},{"_id":"source/images/skywalking3.png","path":"images/skywalking3.png","modified":0,"renderable":0},{"_id":"source/images/skywalking2.png","path":"images/skywalking2.png","modified":0,"renderable":0},{"_id":"source/images/spring5-scheduled注册.png","path":"images/spring5-scheduled注册.png","modified":0,"renderable":0},{"_id":"source/images/spring5-scheduled注册0.png","path":"images/spring5-scheduled注册0.png","modified":0,"renderable":0},{"_id":"source/images/GC/copy.png","path":"images/GC/copy.png","modified":0,"renderable":0},{"_id":"source/images/GC/mark-clean.png","path":"images/GC/mark-clean.png","modified":0,"renderable":0},{"_id":"source/images/GC/mark-compress.png","path":"images/GC/mark-compress.png","modified":0,"renderable":0},{"_id":"source/images/coder/Metrics1.png","path":"images/coder/Metrics1.png","modified":0,"renderable":0},{"_id":"source/images/coder/Metrics2.png","path":"images/coder/Metrics2.png","modified":0,"renderable":0},{"_id":"source/images/coder/Metrics3.png","path":"images/coder/Metrics3.png","modified":0,"renderable":0},{"_id":"source/images/k8s/1部署演化.png","path":"images/k8s/1部署演化.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130153853-ui2udcs.png","path":"images/assets/image-20231130153853-ui2udcs.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130161537-k6jp4kq.png","path":"images/assets/image-20231130161537-k6jp4kq.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130160711-ora87uk.png","path":"images/assets/image-20231130160711-ora87uk.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130154646-n3tfgm6.png","path":"images/assets/image-20231130154646-n3tfgm6.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130161950-nthyx0q.png","path":"images/assets/image-20231130161950-nthyx0q.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130162207-amricr9.png","path":"images/assets/image-20231130162207-amricr9.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130162334-wq8knl7.png","path":"images/assets/image-20231130162334-wq8knl7.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130163419-dlucov7.png","path":"images/assets/image-20231130163419-dlucov7.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130163626-b3ijn8u.png","path":"images/assets/image-20231130163626-b3ijn8u.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130165000-f9u4xav.png","path":"images/assets/image-20231130165000-f9u4xav.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130165557-5lors2o.png","path":"images/assets/image-20231130165557-5lors2o.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231130170131-pfyz6vu.png","path":"images/assets/image-20231130170131-pfyz6vu.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231204111109-ayhkc67.png","path":"images/assets/image-20231204111109-ayhkc67.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231204162214-4g1bw2e.png","path":"images/assets/image-20231204162214-4g1bw2e.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240104152220-2izpt7h.png","path":"images/assets/image-20240104152220-2izpt7h.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20231204174826-1q081wx.png","path":"images/assets/image-20231204174826-1q081wx.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240104154329-g9hnw90.png","path":"images/assets/image-20240104154329-g9hnw90.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240104155246-fieh1f7.png","path":"images/assets/image-20240104155246-fieh1f7.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240104155916-dw9zsud.png","path":"images/assets/image-20240104155916-dw9zsud.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240104155650-95jxrin.png","path":"images/assets/image-20240104155650-95jxrin.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240104160141-n1db8go.png","path":"images/assets/image-20240104160141-n1db8go.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240104160611-xmslynf.png","path":"images/assets/image-20240104160611-xmslynf.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240116140626-xdrpftt.png","path":"images/assets/image-20240116140626-xdrpftt.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240116165959-vy9w5gu.png","path":"images/assets/image-20240116165959-vy9w5gu.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240116170020-sq3x22z.png","path":"images/assets/image-20240116170020-sq3x22z.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240116170034-fs3xv9q.png","path":"images/assets/image-20240116170034-fs3xv9q.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240116170050-p7vvxyi.png","path":"images/assets/image-20240116170050-p7vvxyi.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240116183723-ievwwyy.png","path":"images/assets/image-20240116183723-ievwwyy.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240116183756-jtgrcuo.png","path":"images/assets/image-20240116183756-jtgrcuo.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240117120120-oyzznx1.png","path":"images/assets/image-20240117120120-oyzznx1.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240123142211-7frka5a.png","path":"images/assets/image-20240123142211-7frka5a.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240226173616-kau7kcb.png","path":"images/assets/image-20240226173616-kau7kcb.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240226173645-8641hbr.png","path":"images/assets/image-20240226173645-8641hbr.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240425162917-mdlq5qj.png","path":"images/assets/image-20240425162917-mdlq5qj.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240430164433-bng4qnr.png","path":"images/assets/image-20240430164433-bng4qnr.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240511180118-9ol9gj4.png","path":"images/assets/image-20240511180118-9ol9gj4.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240513172430-zijsvdp.png","path":"images/assets/image-20240513172430-zijsvdp.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240508174543-ue2vter.png","path":"images/assets/image-20240508174543-ue2vter.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240509100554-j5ulk0q.png","path":"images/assets/image-20240509100554-j5ulk0q.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240514143508-npmef32.png","path":"images/assets/image-20240514143508-npmef32.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240514145801-mfzjlbf.png","path":"images/assets/image-20240514145801-mfzjlbf.png","modified":0,"renderable":0},{"_id":"source/images/assets/image-20240514152040-m7ea0hd.png","path":"images/assets/image-20240514152040-m7ea0hd.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404/index.md","hash":"9c04e9185a1c38b5c1d049969cd7718de8cba950","modified":1679548661415},{"_id":"source/about/index.md","hash":"635ec2329cc49e5afc2c244a78efdcc4eef69e41","modified":1694596988755},{"_id":"source/_posts/CompletableFuture.md","hash":"b72027f2f6428c691c24f825273145824d061a3e","modified":1714303578167},{"_id":"source/_posts/Flink.md","hash":"a4b4e12b34d64301fcd932af1ca0b7e593b507ec","modified":1708244431206},{"_id":"source/_posts/DDD领域驱动设计.md","hash":"fe82f3a9f61486f9467dc71ac7582e359384be4b","modified":1715677617764},{"_id":"source/_posts/Gradle入门.md","hash":"fa10de52d049215ccfced403d0017efdfcddc136","modified":1708244625777},{"_id":"source/_posts/Hexo-Guide.md","hash":"a3128d54ca9e58073ef2eec052f18a295b3f3323","modified":1712806750637},{"_id":"source/_posts/G1收集器.md","hash":"ccd9c0d6088bc8e1e6745b0fdf003155ec156ef5","modified":1712806740883},{"_id":"source/_posts/Mybatis源码.md","hash":"5658bf84f3a73a03064f49506091f1466776a1b9","modified":1708246625518},{"_id":"source/_posts/Nacos源码.md","hash":"acb619100d69d49ea01b2b456880195a065a36a8","modified":1714358148880},{"_id":"source/_posts/OLAP浅入.md","hash":"989c200c4e32d20e3a4fc1bce76716336f193e61","modified":1708244742157},{"_id":"source/_posts/Redis高级功能.md","hash":"477ef6a6b49d9a608ab7f72b3f3698342d48854e","modified":1708244939412},{"_id":"source/_posts/RedLock.md","hash":"70d73f235e522ab8ee3c8aa363d29df3bbcfe96c","modified":1708244957419},{"_id":"source/_posts/Raft算法解析.md","hash":"2b87a52b479e37a545187bd36d9a5cdcd2ae6088","modified":1714377793427},{"_id":"source/_posts/RBAC权限模型.md","hash":"cf2fe099da23163873fae5ae532ad626e3018011","modified":1712806756793},{"_id":"source/_posts/Spring-AspectJ织入.md","hash":"032bcb4558eac4851da58428a078dea23003a0bf","modified":1708245047444},{"_id":"source/_posts/Spark.md","hash":"35f922518f88b1c2d0b5affa197e0f7617bd46e1","modified":1708244994459},{"_id":"source/_posts/Spring-Cache.md","hash":"92f36bb7ad3027c45241535d006df1085693b270","modified":1708245067929},{"_id":"source/_posts/Sping-Cache源码.md","hash":"9d6b53decb78cefb70cd23a30e8e40a09ba2b8f8","modified":1708245013360},{"_id":"source/_posts/SpringEvent应用.md","hash":"fb7b278b3ef480f8c778f4a0b8dd1db7f0e22912","modified":1715065440763},{"_id":"source/_posts/Spring源码-Autowired注解.md","hash":"6c50ad3ebd6ce08f15b93bae43435dbd14c74cc1","modified":1708245092806},{"_id":"source/_posts/TiDB解决事务冲突.md","hash":"d7651a8a74499bcc6ad5b003af9f5169e36f18bc","modified":1708245141422},{"_id":"source/_posts/Spring源码-Scheduled注解.md","hash":"41b486decaeab2496320ff752659d7f28d2cb3fb","modified":1708245111565},{"_id":"source/_posts/arthas简述.md","hash":"38fba4ece27e2c27ebe598f0153b84b63ffae7ec","modified":1712806687021},{"_id":"source/_posts/Tidb执行计划.md","hash":"d890d2ba7af02bbff624dad87490934b02367874","modified":1715652434145},{"_id":"source/_posts/dataX-异构数据离线同步.md","hash":"7e746f65c2ec9d0f4c09a697a8e3b4125707e875","modified":1712806722725},{"_id":"source/_posts/gprc.md","hash":"4b192161164e129ae62612ca147005c1147ba516","modified":1708244519760},{"_id":"source/_posts/jdbc处理大数据时的坑.md","hash":"f779fec54f015148ff6ca9231b5c6aeb2531409f","modified":1713945912316},{"_id":"source/_posts/kubernetes-2-相关概念.md","hash":"bb39359ec3afb074184bbbc998f958e18caa54bc","modified":1708244835608},{"_id":"source/_posts/kafka入门.md","hash":"695f6d24c4673eea31de9dd78751cc30b0aa79f4","modified":1708244717737},{"_id":"source/_posts/kubernetes-1-基本架构.md","hash":"86f5f458387ee2734346c9caf7fc9b375fe8e5ba","modified":1708244814435},{"_id":"source/_posts/protobuf.md","hash":"f502df680fc13254bf9ceede07e2ce28221e71a1","modified":1708244758788},{"_id":"source/_posts/redis集群-cluster.md","hash":"3de8727a28924f586b317aebe522e2e88f940450","modified":1708244862042},{"_id":"source/_posts/kubernetes-3-安装与使用.md","hash":"3fca2931b8815b9c46dbbf04cf1e0f8834ff2299","modified":1708244847264},{"_id":"source/_posts/redis集群-sentinel.md","hash":"cde03cd449d8cfeeb801193ae2bc13d15d10e699","modified":1708244891312},{"_id":"source/_posts/skywalking与分布式链路追踪.md","hash":"4597cd8ca7c40201f0ec17399522eb9e196718cc","modified":1708244971937},{"_id":"source/_posts/一次OOM分析.md","hash":"e93cd33f8d0219ba1a8e0af6759ef0c03f3314ee","modified":1712806690310},{"_id":"source/_posts/从Docker到Kubernetes.md","hash":"930de7aadf51da00835ddedf0da8b23571ffd199","modified":1708241670830},{"_id":"source/_posts/压力测试.md","hash":"dd0fa4a9f8a437e3c8715cf3fa019f489c70105f","modified":1712806677898},{"_id":"source/_posts/分布式限流sentinel.md","hash":"2e151cef7934c77cb5d4ed1889304a174ff0e8f9","modified":1714035083401},{"_id":"source/_posts/理解服务端推送与实践.md","hash":"547283c4238811bdc1f22fa1a86c305a72a93e2a","modified":1708242662848},{"_id":"source/_posts/跨域问题总结.md","hash":"7eba54e19ad561e7d29d7320edc18136ab0225c6","modified":1712806683549},{"_id":"source/_posts/程序员练级攻略.md","hash":"38989d0b98a0c41317a9ff18cd7442df05e0f530","modified":1712806669611},{"_id":"source/categories/index.md","hash":"da6cc9bb17f418f62eef14d134fad77ea657162a","modified":1708242598310},{"_id":"source/images/Autowired3.png","hash":"bc8e4f4e5e1bfc429f97642d28584ac1d2c4baab","modified":1697003141386},{"_id":"source/images/SSE浏览器请求.png","hash":"f341ff238137b9932312a8a2a68b905607ea1d67","modified":1689047320721},{"_id":"source/images/arthas1.png","hash":"832502dbf49ccbfce533db0a496e0894bc324549","modified":1688722391802},{"_id":"source/images/arthas2.png","hash":"832502dbf49ccbfce533db0a496e0894bc324549","modified":1688722405301},{"_id":"source/images/datax1.png","hash":"d7bdfb6ca3587296b18f85e5d960026a18f534ee","modified":1702974836171},{"_id":"source/images/gradle-command.png","hash":"e74d9451a306107c8420b47cbd9ecb35be8980af","modified":1681206595373},{"_id":"source/tags/index.md","hash":"4e610fa17126eed4596935f34e6f2c85e796efb1","modified":1708241355637},{"_id":"source/images/GC/copy.png","hash":"fa9634fc19f68640345e227c9ca65fb820ef7062","modified":1690443259553},{"_id":"source/images/GC/mark-clean.png","hash":"8565a336f71878e57ec1240691128a18a018a9e8","modified":1690443237977},{"_id":"source/images/GC/mark-compress.png","hash":"7c4db03de1fd236e413887e7cc07521b7ee241bc","modified":1690443357754},{"_id":"source/images/coder/Metrics3.png","hash":"8837e6cbcc149d0d11962c32a550831e944abfe5","modified":1705064203577},{"_id":"source/images/coder/Metrics2.png","hash":"087d4889914c4e0f636819f41a76cac62f69a6c6","modified":1705064189487},{"_id":"source/images/coder/Metrics1.png","hash":"702691d040550ebb17d38daa00ecd7a672ba6edf","modified":1705064171830},{"_id":"source/images/k8s/1部署演化.png","hash":"993780da4c110e984619011e3d82f42bee5ce8b3","modified":1705371103391},{"_id":"source/images/assets/image-20240104154329-g9hnw90.png","hash":"5dbc959ba1595000dd7d7f5830fc01e03de95031","modified":1704354209000},{"_id":"source/images/assets/image-20240104152220-2izpt7h.png","hash":"40b7b0f250ac1204a945d4ca87137fa0f2e0e46c","modified":1704352941000},{"_id":"source/images/assets/image-20240116165959-vy9w5gu.png","hash":"5e6448dec2205f2751731565b26c8725fcacff6f","modified":1705395599000},{"_id":"source/images/assets/image-20240104155246-fieh1f7.png","hash":"11b9fc3483afe6012c4320f5d264d83d0f78d637","modified":1704354766000},{"_id":"source/images/assets/image-20240226173616-kau7kcb.png","hash":"0f3db801b6d754530dcbbfbd55d9c121029be802","modified":1708940176000},{"_id":"source/images/assets/image-20240430164433-bng4qnr.png","hash":"3f5f3ee744408518dd8d1b9d8d98b1a478c13029","modified":1714466673000},{"_id":"source/images/Autowired1.png","hash":"a1eaff2075ec87f13ae271c61719b9c875e936e4","modified":1697003115591},{"_id":"source/images/6f68e8517ae6e68ac63f4a34b8d14ca5.png","hash":"09641cc351098a3b5901a35acc75b70baebcea85","modified":1705311545725},{"_id":"source/images/DDD四层模型.jpg","hash":"7a019c1d1094d81621148967b23c36b09c693f0d","modified":1686722456870},{"_id":"source/images/Autowired6.png","hash":"350d0866b23ccc66e77b826ae531783daf3298e9","modified":1697003516222},{"_id":"source/images/Autowired9.png","hash":"fe07ac70d680f2b019bb446966a0563acae65fa4","modified":1697003555872},{"_id":"source/images/TiDB-01.png","hash":"4fd0efde7a714dda290b314ae40af425f4863d8a","modified":1697615380983},{"_id":"source/images/gradle-idea-config.png","hash":"02f03a0358a6f383426496938f27a92722c54fc9","modified":1681205323386},{"_id":"source/images/assets/image-20240104160611-xmslynf.png","hash":"4365ec3236cd05a11c76d3d702d639567083c96c","modified":1704355571000},{"_id":"source/images/assets/image-20240116170020-sq3x22z.png","hash":"8726bea1e5e4d2021c48a2c677e66932dd16e607","modified":1705395620000},{"_id":"source/images/assets/image-20240116170034-fs3xv9q.png","hash":"3f7319194b22bc1c94a82be2ebe191c1bc15fda7","modified":1705395634000},{"_id":"source/images/assets/image-20240116183723-ievwwyy.png","hash":"8e43eb7fe08beb3115420e802c0665486cda076b","modified":1705401443617},{"_id":"source/images/Autowired4.png","hash":"215a18d06fe59a6505b6da6d1ae3d7d138772025","modified":1697003160210},{"_id":"source/images/Autowired5.png","hash":"399684775432b92afe0ba0b97594f3deba26266c","modified":1697003487319},{"_id":"source/images/Autowired10.png","hash":"e203493e3595f0a1011662ad76f77cb7ecd2995d","modified":1697003566740},{"_id":"source/images/Autowired8.png","hash":"0b3afc2724f37ef671a2e23b305d9f23cc9f649f","modified":1697003545996},{"_id":"source/images/assets/image-20240226173645-8641hbr.png","hash":"737a273f4b6cbd62b449388e517d817b7e4fb709","modified":1708940205000},{"_id":"source/images/assets/image-20231130161537-k6jp4kq.png","hash":"12a16b1a764bfa079ea6e07155f611c0dcf11821","modified":1701332137000},{"_id":"source/images/assets/image-20240104155650-95jxrin.png","hash":"c6cbc314a5ffb169270a3a8e8d1b2684b4d6b3c4","modified":1704355010000},{"_id":"source/images/assets/image-20240104155916-dw9zsud.png","hash":"3e3a09d2508303bae10139491a376fc9af4b0c54","modified":1704355156000},{"_id":"source/images/assets/image-20240116170050-p7vvxyi.png","hash":"7f0ee1acd5e63f69ae1fd5d2ca4690e286d83605","modified":1705395650000},{"_id":"source/images/assets/image-20240513172430-zijsvdp.png","hash":"1a3abfc21e36ba37916098897dc1b36bd31d0128","modified":1715592270000},{"_id":"source/images/Autowired7.png","hash":"1a588863d8f822e7cc64646bd10aeeb7bf026f3f","modified":1697003529437},{"_id":"source/images/spring5-scheduled注册0.png","hash":"ab6068458933827a7f57ba0bf952973c5a45ea98","modified":1696762942529},{"_id":"source/images/scheduled_5_3.png","hash":"7a68d710568f484a8f6f035a0f25e31951dd6fa3","modified":1696923977534},{"_id":"source/images/skywalking2.png","hash":"c41fa09e352abf92cb426596c3d8d9d01493cb96","modified":1695895528185},{"_id":"source/images/assets/image-20231130160711-ora87uk.png","hash":"77fd269719428e501212c0fbd07d3572adf20452","modified":1701331631000},{"_id":"source/images/assets/image-20240104160141-n1db8go.png","hash":"28f8d52f49e1d04667105a67e31222c4f3e06ce9","modified":1704355301000},{"_id":"source/images/assets/image-20240116140626-xdrpftt.png","hash":"0156884845119fa948a566544e291d48ff20b763","modified":1705385186000},{"_id":"source/images/assets/image-20240511180118-9ol9gj4.png","hash":"6e87117a9ccbc1c6aa685cc3caa57df3103fc489","modified":1715421678000},{"_id":"source/images/skywalking3.png","hash":"00a2f20bba8c3fea6687d4b8298ddaade856f878","modified":1695897907483},{"_id":"source/images/assets/image-20231130153853-ui2udcs.png","hash":"4fe03f668a0ff149064258053cf3b0609f340ff1","modified":1701329933000},{"_id":"source/images/assets/image-20231130161950-nthyx0q.png","hash":"d25927b8e4f4603a7393318710e862edad65c099","modified":1701332390000},{"_id":"source/images/assets/image-20240425162917-mdlq5qj.png","hash":"4bc714eea2d17fa26509e0cbd5c38ad3a8ba376d","modified":1714033757066},{"_id":"source/images/assets/image-20231130154646-n3tfgm6.png","hash":"c16aa3b799f7ef88c01ca7251c9fe0557016d00b","modified":1701330406000},{"_id":"source/images/assets/image-20231204111109-ayhkc67.png","hash":"a0f9a3ab829362430d2aec39a86eaf844c9040d7","modified":1701659469000},{"_id":"source/images/assets/image-20231130163626-b3ijn8u.png","hash":"b35ff3718de10f81cae9a75310075ca9650d88ca","modified":1701333386000},{"_id":"source/images/assets/image-20240123142211-7frka5a.png","hash":"636781a33a6ad3bc1b833a117b1828fb6f86ecf8","modified":1705990931000},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1679395990601},{"_id":"themes/next/.gitattributes","hash":"aeeca2f1e987d83232d7870d1435a4e3ed66b648","modified":1679395990602},{"_id":"themes/next/.eslintrc.json","hash":"611e15c3fcb41dc68fa8532ee595a1262a1b5a8a","modified":1679395990601},{"_id":"themes/next/.gitignore","hash":"087b7677078303acb2acb47432165950e4d29b43","modified":1679395990610},{"_id":"themes/next/_vendors.yml","hash":"9f0128c829bff4e9935d5993cd3bde96cc7bef0e","modified":1679395990612},{"_id":"themes/next/.stylelintrc","hash":"c6b473cc7337d35b278cd9d85855c60ee2fead3e","modified":1679395990610},{"_id":"themes/next/_config.yml","hash":"c011e000b3fbe16a4a996f3b267c9255a8dd9119","modified":1708247191261},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1679395990612},{"_id":"themes/next/LICENSE.md","hash":"8cfb03967dd4cbaf3b825271ffce0039aa3fc22a","modified":1679395990610},{"_id":"themes/next/package.json","hash":"848d840614069063b40698b88a0ce1e711187e8a","modified":1679395990651},{"_id":"themes/next/README.md","hash":"fe1761cb3eab07a1742296c5976c30f2346073b7","modified":1679395990611},{"_id":"themes/next/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1679395990651},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"593ae64e72d43c020a697eac65b1f9c3483ff097","modified":1679395990603},{"_id":"themes/next/.githooks/install.js","hash":"72757c6827909a5f2c217ddbbdf6034ca6fab74a","modified":1679395990602},{"_id":"themes/next/.githooks/pre-commit","hash":"b69b9d0b51e27d5d4c87c3242f5067c2cda26e44","modified":1679395990603},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"2fdca1040427cabfe27cae6754ec5e027ec7092e","modified":1679395990604},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"009b397b686bba7b63885da59d904144ff59b24e","modified":1679395990606},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1679395990606},{"_id":"themes/next/.github/release.yml","hash":"83b4dae3f8d76619e208d2110a247b3ccadd64d8","modified":1679395990607},{"_id":"themes/next/.github/config.yml","hash":"0956bf71b6f36632b63b14d26580458041a5abd2","modified":1679395990606},{"_id":"themes/next/.github/labeler.yml","hash":"ff76a903609932a867082b8ccced906e9910533a","modified":1679395990607},{"_id":"themes/next/docs/AUTHORS.md","hash":"579014d47f45b27fd1618b9709f0efe9585c7449","modified":1679395990613},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1679395990613},{"_id":"themes/next/languages/README.md","hash":"b1c96465b3bc139bf5ba6200974b66581d8ff85a","modified":1679395990616},{"_id":"themes/next/languages/ar.yml","hash":"a18fecc404177bd8f76bab82826f5931ec557069","modified":1679395990616},{"_id":"themes/next/languages/bn.yml","hash":"785c43cf417879240515435da64b98660f3deaaf","modified":1679395990617},{"_id":"themes/next/languages/de.yml","hash":"0607d8973e74824321564714f92c8a6afcbbc6d5","modified":1679395990617},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1679395990618},{"_id":"themes/next/languages/fa.yml","hash":"9e7b49b9017a3ffa62949f31c7ea3eecb8e547f5","modified":1679395990619},{"_id":"themes/next/languages/en.yml","hash":"03041988456463c08aae64415d4b3b7ec32c92d1","modified":1679395990618},{"_id":"themes/next/languages/id.yml","hash":"5da84365f133d8afda5288554aa82c8d8ea1a9fd","modified":1679395990619},{"_id":"themes/next/languages/it.yml","hash":"56d4fe22fd7a30954e62b003ff95d5949765fbfb","modified":1679395990620},{"_id":"themes/next/languages/es.yml","hash":"c52a4747f2d112f217a2d2cc9217d62aa62ff24f","modified":1679395990618},{"_id":"themes/next/languages/fr.yml","hash":"66443aef072a9e20cb053c8fee339377827c96f9","modified":1679395990619},{"_id":"themes/next/languages/ja.yml","hash":"4944ad1e226f2a4f965fe409989b7506f9264e76","modified":1679395990620},{"_id":"themes/next/languages/ko.yml","hash":"05a78a32e4e7dd5903153231ba0d10dd73823ab9","modified":1679395990620},{"_id":"themes/next/languages/pt-BR.yml","hash":"6ff0fac38e3cfb2d79f64645d90a7e7f2f2764d3","modified":1679395990621},{"_id":"themes/next/languages/nl.yml","hash":"a27feeb08d8e6dc1439dd258b2ef6e65cfe4ca17","modified":1679395990621},{"_id":"themes/next/languages/pt.yml","hash":"46b82ce46d3a09391a068dfa519b7a6baf04a775","modified":1679395990621},{"_id":"themes/next/languages/ru.yml","hash":"ee381a6c2c8bd85580b03ab52cf5cb95dca4899b","modified":1679395990622},{"_id":"themes/next/languages/si.yml","hash":"c608d89d85061a488eca222b99e5062f2fc6b681","modified":1679395990622},{"_id":"themes/next/languages/uk.yml","hash":"a3d58cf753057963e08a355528dd7ce68b57c9b5","modified":1679395990623},{"_id":"themes/next/languages/th.yml","hash":"14845e9fbd235c0ff70522992e6be97f0ef1a523","modified":1679395990622},{"_id":"themes/next/languages/tk.yml","hash":"567e1bf608d94e212c7fff2eda1d1dbe6f5d5a58","modified":1679395990622},{"_id":"themes/next/languages/tr.yml","hash":"7625b7948a6bfc3ff8ae8d4d0470cdbae5e347be","modified":1679395990623},{"_id":"themes/next/languages/zh-CN.yml","hash":"c7d18a00387f21f5e54329b72d68e3c95dbc3c5f","modified":1708245913181},{"_id":"themes/next/languages/vi.yml","hash":"73f7e23b1869b3a00da106635711679e6743f1ec","modified":1679395990623},{"_id":"themes/next/languages/zh-TW.yml","hash":"4945d947d007987b6462fdb7b1a7fa996a58491d","modified":1679395990624},{"_id":"themes/next/layout/_layout.njk","hash":"0f2760cd7550ca30ffcc28e2dbd7f031a237b5a7","modified":1679395990625},{"_id":"themes/next/layout/archive.njk","hash":"aa491dba8f746e626c273a920effedf7d0b32170","modified":1679395990649},{"_id":"themes/next/layout/category.njk","hash":"82f541452cae76a94ee15cb8d8a888f44260a0fd","modified":1679395990650},{"_id":"themes/next/layout/index.njk","hash":"fa52c3049871e879980cb6abccdea3792ca4ce70","modified":1679395990650},{"_id":"themes/next/languages/zh-HK.yml","hash":"ff7fe965128f01d2c00bf68aef7a9fcfbf3a1174","modified":1679395990624},{"_id":"themes/next/layout/page.njk","hash":"6d2f7e7cd9fe868e96765b82d17df49081379e27","modified":1679395990650},{"_id":"themes/next/layout/tag.njk","hash":"b6c017d30d08ddd30d66e9c6f3a71aa65d214eac","modified":1679395990651},{"_id":"themes/next/layout/post.njk","hash":"6767de9702a07a2a4e16a8a6bc9c5919536c1e3f","modified":1679395990651},{"_id":"themes/next/docs/LICENSE.txt","hash":"d1cd5a8e83d3bbdb50f902d2b487813da95ddfd3","modified":1679395990614},{"_id":"themes/next/test/index.js","hash":"983a505399796b9d9e174ba46d89abbdde38f8ee","modified":1679395990717},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"daeedc5da2ee74ac31cf71846b766ca6499e9fc6","modified":1679395990605},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.yml","hash":"10eca518b91a19984f6a5a912d41222042f61d63","modified":1679395990605},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"a1aa85a2fc66ff0c52c65bd97b0fa282e297a73f","modified":1679395990607},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"b87ffaf40820461159c891d0d41c87e00e312ff3","modified":1679395990608},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"bfea9b04e3ea7da31a2095277c4c23ae6bd14baa","modified":1679395990608},{"_id":"themes/next/.github/workflows/codeql.yml","hash":"1e4e4a7ea522b76d6fc5947ddd07260f9fecbcf4","modified":1679395990608},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.yml","hash":"3f19cbf0c2b2fee6bf3788870b842c9ccc1425ca","modified":1679395990604},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.yml","hash":"fbc3062cd4591c8329fab9db72803746f0d11920","modified":1679395990605},{"_id":"themes/next/.github/workflows/lock.yml","hash":"ea346568ab811fea4dacc69081af2d6177b5aafb","modified":1679395990609},{"_id":"themes/next/scripts/events/index.js","hash":"8ae618d4436dab49928c2bebc0837e5310dbe7de","modified":1679395990652},{"_id":"themes/next/.github/workflows/linter.yml","hash":"74ecdd99cc20a8f5103579210353de33536aa45c","modified":1679395990608},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7befb4325b107dd668d9eae3d7e86a34910ce3f2","modified":1679395990615},{"_id":"themes/next/docs/ru/README.md","hash":"caf25da442d08b3d0a4e4503c6f4d6b68b1ac2f2","modified":1679395990614},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a09ceb82b45dd8b7da76c227f3d0bb7eebe7d5d1","modified":1679395990615},{"_id":"themes/next/docs/zh-CN/README.md","hash":"5500b0c6db58bf2e93e8ace98ae8da65de7e8318","modified":1679395990616},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"0c9a1fe9906672724dbf274154a37bac1915ca2c","modified":1679395990658},{"_id":"themes/next/scripts/helpers/engine.js","hash":"43568a872a93259fc1c497724a53914474ef83ae","modified":1679395990660},{"_id":"themes/next/scripts/filters/minify.js","hash":"997fc7153a7055bdf278e93d16a17c2d0bd62b8f","modified":1679395990659},{"_id":"themes/next/scripts/filters/locals.js","hash":"87f3bff03fa9fd96cf0787a6442464a7ff57f76b","modified":1679395990659},{"_id":"themes/next/scripts/filters/post.js","hash":"e6cf4c94fc2291215a3345134ddbbc74d5091b00","modified":1679395990659},{"_id":"themes/next/scripts/helpers/font.js","hash":"0a6fa582a0890ecaf5f03f758a730936e48aeca1","modified":1679395990660},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"ad764d48715c5da87d33f048ad5f1ae8b4e2eb52","modified":1679395990661},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"82f6e81bacf23d10cac71b09cff8708e47891ef3","modified":1679395990660},{"_id":"themes/next/scripts/tags/button.js","hash":"86c71c73a63744efbbbb367612871fede0d69529","modified":1679395990662},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"483d75522e76c7e67c7e0dfd5cac8ab04784a04c","modified":1679395990661},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"2e8dcc12a52517bb4e00ea611720bcd298624112","modified":1679395990661},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"b4d12e6fe29089be0f43bafc9eea736602cd16bf","modified":1679395990663},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"8e912c715702addaf0cefe63e580e45b97ae8c3f","modified":1679395990663},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1c609312a71d47f838226346aad5c2e1c35f15dd","modified":1679395990663},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"52acbc74c1ead8a77cd3bbcba4e033053683f7d0","modified":1679395990662},{"_id":"themes/next/scripts/tags/index.js","hash":"255dd1090e8319b557eeca43571f0e4f8aab013b","modified":1679395990664},{"_id":"themes/next/scripts/tags/label.js","hash":"c18b0e619a779ed40be7f014db92af18f45fbd5c","modified":1679395990664},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"3f358bb78c5c6fdf45de287f3ead553e3a6a93c2","modified":1679395990665},{"_id":"themes/next/scripts/tags/note.js","hash":"a12fd53e421400836a3722ae69130969558d6ac0","modified":1679395990665},{"_id":"themes/next/scripts/tags/pdf.js","hash":"317ba4611020cc840854386dde098dbbe452777e","modified":1679395990666},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e0ed5fe1bc9d2957952a1aacdf3252d6ef3f9743","modified":1679395990666},{"_id":"themes/next/scripts/tags/video.js","hash":"f6ad3f52779f0636251238d3cbdc5b6f91cc5aba","modified":1679395990666},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"d9d8e6d7a6a8c80009dd5334cc17fd3e4977a008","modified":1679395990625},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"b9fc0a6b02f0380de939d1ea2a7c7d2e6be9f462","modified":1679395990626},{"_id":"themes/next/layout/_macro/post.njk","hash":"fefa9d5f56607dbcbfd9b8d57b3f32c07167d847","modified":1679395990626},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"b3844e168b51a99d495ca05562ffac47677f5728","modified":1679395990665},{"_id":"themes/next/layout/_partials/comments.njk","hash":"60f4620dd479da6d86d1d493440e9e2a28b6e132","modified":1679395990627},{"_id":"themes/next/layout/_partials/footer.njk","hash":"3c99c51cc6cfc74f1bdef8c953aa81d8a9ab48ac","modified":1679395990627},{"_id":"themes/next/layout/_partials/languages.njk","hash":"537026fc120adeef9148c98ebf074207e3810538","modified":1679395990630},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"c55167bc0dbe7e104d4f4d782e98fcabc7e07a35","modified":1679395990632},{"_id":"themes/next/layout/_scripts/index.njk","hash":"4eb65641b47ea9b23ed2ddfd69b18f21d7d8f214","modified":1679395990636},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"9471c4f3aeee101b9b9a8c2aae7d21ec7277574e","modified":1679395990636},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"0a1470440f11362df2b1cd6b6228e273d9f999d6","modified":1679395990637},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"53ad3c31762b74e5d29787b37d5e494cc4fded9b","modified":1679395990643},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"13b2a77b4858a127f458ea092b6f713b052befac","modified":1679395990645},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"73bc15a9c3c5c239ab90efa19a1e721f41f3cb93","modified":1679395990646},{"_id":"themes/next/layout/_third-party/index.njk","hash":"489d0cd36c75555fafa9551cf58ff35cb75a91f4","modified":1679395990644},{"_id":"themes/next/test/helpers/index.js","hash":"2fb58dca3df2fe53116ee2b1232fa26ebe7b2ce5","modified":1679395990716},{"_id":"themes/next/.github/workflows/tester.yml","hash":"dda18899fe62652c633f60c300a93df18f58862f","modified":1679395990610},{"_id":"themes/next/source/css/_colors.styl","hash":"a88430865c99f47ce1d8240f8895819b8b7b0c06","modified":1679395990667},{"_id":"themes/next/.github/workflows/pr-reminder.yml","hash":"7d9f270dda6b28688b68118d9001ceaa4991d965","modified":1679395990609},{"_id":"themes/next/source/css/main.styl","hash":"c326550ce8b4deaa9b647bcfe3cdc04c100644e6","modified":1679395990700},{"_id":"themes/next/source/css/_mixins.styl","hash":"eacfdd1795ccc0138e194fbf9381d3a64b5ba130","modified":1679395990691},{"_id":"themes/next/test/helpers/font.js","hash":"6f5076bd3f2724e47b46ca69028393a9b6275cd1","modified":1679395990716},{"_id":"themes/next/test/helpers/next-url.js","hash":"08e84781f1cd54e5634b86877ad9cefae4a78e95","modified":1679395990717},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1679395990701},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1679395990700},{"_id":"themes/next/source/css/noscript.styl","hash":"64b378a4d2f0b36bf666fba13b57c59da3a8ac83","modified":1679395990700},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1679395990702},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1679395990701},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1679395990701},{"_id":"themes/next/test/tags/button.js","hash":"a50ca44eaec3d91c2958e3157d624cd3e68828c7","modified":1679395990717},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1679395990702},{"_id":"themes/next/test/tags/index.js","hash":"5cad001936a694bf32d59751cc2b68a66199f976","modified":1679395990719},{"_id":"themes/next/test/tags/label.js","hash":"6cad7d84c42511459a89cda3971e8ea5cdee0125","modified":1679395990719},{"_id":"themes/next/test/tags/caniuse.js","hash":"2852be850d9103c25114253a45e6c62e32517de4","modified":1679395990718},{"_id":"themes/next/test/tags/group-pictures.js","hash":"8f66d3c6f03fb11d85aa2ab05c9b3c9aa2b4e994","modified":1679395990718},{"_id":"themes/next/test/tags/center-quote.js","hash":"2ac4b5a358681691a17e736de06fce0b640a7023","modified":1679395990718},{"_id":"themes/next/test/validate/index.js","hash":"560862194991c5963da5a411629d8e6c71d20ee2","modified":1679395990721},{"_id":"themes/next/test/tags/mermaid.js","hash":"f718a3d0e303d842e2ca5a3b162539a49e45a520","modified":1679395990720},{"_id":"themes/next/test/tags/video.js","hash":"88db9a3a26cd35525c43c0339fcd1c5965ec9518","modified":1679395990721},{"_id":"themes/next/source/js/config.js","hash":"211a9ab35205ccfa6b7c74394bade84da0d00af7","modified":1679395990703},{"_id":"themes/next/test/tags/link-grid.js","hash":"41730266306c02362258384cd73659223928361f","modified":1679395990720},{"_id":"themes/next/test/tags/pdf.js","hash":"2d114596a8a180b2f3cd2a9c6528a328961f12d4","modified":1679395990720},{"_id":"themes/next/test/tags/note.js","hash":"161a81ce749e239d2403681372d48ecc1b51d7b9","modified":1679395990720},{"_id":"themes/next/source/js/comments.js","hash":"0b4daf0ce610760bd52e95d423f61f3e1c72442a","modified":1679395990703},{"_id":"themes/next/source/js/next-boot.js","hash":"da11083557070d947da48d29d2d60988c8d628e9","modified":1679395990704},{"_id":"themes/next/test/tags/tabs.js","hash":"b19d2592347eae5d6a7a97ca7e8cec03e8f25b51","modified":1679395990721},{"_id":"themes/next/source/js/motion.js","hash":"d4c01d5317d45444e91a52236b751c9e9ab1bc16","modified":1679395990704},{"_id":"themes/next/source/js/pjax.js","hash":"c999bfc7cad747e3da0fe3d75c31dd933bf63016","modified":1679395990705},{"_id":"themes/next/source/js/bookmark.js","hash":"1457291a7244b7786ec35b949d97183e4fbd181d","modified":1679395990702},{"_id":"themes/next/scripts/events/lib/config.js","hash":"7c29184a37222d6499c5220264fda6942afc03a9","modified":1679395990653},{"_id":"themes/next/source/js/utils.js","hash":"6b8152558a7c3b1ab6649cf3dfa897c7ada97138","modified":1679395990715},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"00cec6980cafd417def885f496371856cd524a25","modified":1679395990653},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"1f1ea7b579a49f17574c31d78d663c54896133eb","modified":1679395990653},{"_id":"themes/next/source/js/schedule.js","hash":"4858233224756e3cadfabd8135f7c4b1e3673b44","modified":1679395990705},{"_id":"themes/next/source/js/comments-buttons.js","hash":"81ea6cbcdf0357094753d7523919c1eafa38e79f","modified":1679395990703},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"0a2df7d40d64c61ce7e730bb8269b848b03526d1","modified":1679395990653},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"761760031e49edb77277bd4a8582774959240d6b","modified":1679395990655},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"1cb58aa6b88f7461c3c3f9605273686adcc30979","modified":1679395990656},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"a96050b0a9bcb49f1f6897660efc77991024790a","modified":1679395990654},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3283bdd6e5ac7d10376df8ddd5faaec5dc1bd667","modified":1679395990656},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"550cc7f57bc3ab3d093e34741e7860222851d4d4","modified":1679395990655},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"65825c37e473c942095df05183424003d7263df5","modified":1679395990654},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"4dbe9652ae53a181c86eb7e9005a5255f0540055","modified":1679395990657},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"bb8ebb541c40362c0cbbd8e83d3b777302bb6c40","modified":1679395990658},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"96e58efba0dc76af409cc7d2db225f0fe4526ea8","modified":1679395990657},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"7bf2b6ab499775355bbf8f3ae597ff7bc00e89e4","modified":1679395990628},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"c22cbccd7d514947e084eeac6a3af1aa41ec857a","modified":1679395990657},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"a50718c081685fd35ff8ea9ca13682c284399ed8","modified":1679395990658},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"fd75652957c1c3668874fdfd16f4f56027be0d8b","modified":1679395990627},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"e016c3f80db433f17781caf26e44f2089a71550a","modified":1679395990628},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"1b2ae17f3c394ce310fe2d9ed5f4d07d8cc74ae7","modified":1679395990628},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"62513f08e9e7f4abeaeedca91fd0af0861a2540f","modified":1679395990629},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"20cb9c39bcdcfa3f710df7bc5838d6e62d4dd674","modified":1679395990629},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"828700af2a2f273d3e3e0554ffc60706d889d539","modified":1679395990629},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"1fe44a1e156cd30e3e9fd8313e1011ad30970f83","modified":1679395990630},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"92553feb26f30f7fc9147bc4ef122908a9da06be","modified":1679395990631},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"0ebc0142abebbeef4278e32abb543c7d7fa75d88","modified":1679395990632},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"ebe45ab38ace03ea74eed3f676ec1cb5805a3c8a","modified":1679395990633},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"b352346dd2cb42f7eeaec5e39d9a2a353b029775","modified":1679395990630},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"93fbb449fbd599cb4315d7eb0daeb239811b233f","modified":1679395990634},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9a9c4fb7e7c4fe4b7d474bdfdb4ed2b0a5423df2","modified":1679395990633},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"752df7d12360a077c51a25609916a3ecc1763bb3","modified":1679395990632},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"6ec9c97e91c793cc2eb5ac0f7c3c36fdaaf637d1","modified":1679395990631},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"fd6fde597ea2fb7b80cffd0a3553c8e73acb8ab2","modified":1679395990634},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"f73d25a8ccfdd5d4ca2953dc434ff8ce36034c57","modified":1679395990635},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"d251532b76d4b44e84732f78e774b18e2415d7d9","modified":1679395990634},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"9a7eda45ad0753d5f624c51a56e00277ba97c93d","modified":1679395990633},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"9766852e72c1809d8c1eea71ac6116b4cc0886d2","modified":1679395990635},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"3e80332f88b101141be69f2a07f54ed8c053eabb","modified":1679395990637},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"3de5c9676aaf6a2f7d837db275c56d15f9b74fb8","modified":1679395990635},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"43238bc1bc2e88d707f8097814ef3ff830cbe641","modified":1679395990639},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"9ff9ec05c2037beea229a6bb698f9e3546973220","modified":1679395990638},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"52ad137450f7b3d6a330e16b3ed1c6174290f0eb","modified":1679395990638},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"17173c45f0b740669ef45aaae1fe96eeb0a0ff52","modified":1679395990638},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"64ed6fecae79f9f9c61e956d2bd077792473e069","modified":1679395990640},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"24719266662fcff63e88a21ee9b5b284abb8b37c","modified":1679395990639},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"81abcf790cf97395cde9e3cd6d5d1aa5656bd134","modified":1679395990639},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"724a58f5296ab4a12910c81f2e619e607b2b21a6","modified":1679395990640},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"375a86f0b19e130cfa7707007e3a53d9ae7c9b64","modified":1679395990641},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"3fbc72427c1211e5dcfd269af1a74852a7ba5c1a","modified":1679395990641},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5f7967bd946060f4102263a552ddfbae9975e7ea","modified":1679395990641},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"09d2c9487d75894d45a823e3237ae9f90fd6ee01","modified":1679395990640},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"6fd4df5c21cfe530dbb0c012bc0b202f2c362b9c","modified":1679395990642},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"c5086b4c35f730f82c99c4a8317f2f153ebde869","modified":1679395990642},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"b8e0d5de584cece5e05b03db5b86145aa1e422b4","modified":1679395990643},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"b0828dd1b1fd66ecd612d9e886a08e7579e9a4f7","modified":1679395990642},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"38badcc7624a13961381c2465478056b9602aee5","modified":1679395990642},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"a7921be7328e1509d33b435175f5333a9aada66f","modified":1679395990643},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"67f67a77f27103177b9940446f43610229536d82","modified":1679395990646},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"d97790e4b442a1e3ded7d7b4f84b8ee6cdb6e8ea","modified":1679395990647},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"1856c4b035c5b8e64300a11af0461b519dfc4cf4","modified":1679395990644},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"a62aa1ed4e35b8d0451d83f341bf0a97538bc9a4","modified":1679395990645},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1df65b1390add93b86ae3f9423d96a130b0ece04","modified":1679395990645},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"210c32b654adae3d8076c4417d370b42af258cea","modified":1679395990646},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"866ffa15a3250678eb8a90aa6f609fa965db90fd","modified":1679395990648},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"af5336e8bbdc4638435971da115bb7443d374ade","modified":1679395990647},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"8703d1855bb8d251c9b7c2940b7e3be525e53000","modified":1679395990648},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"dd8f963acd5a3685be46fd5319c06df0308d99b2","modified":1679395990649},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5092cacdfbc482996d0bee9fdf2c37d8d3ae863c","modified":1679395990698},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"0386c708975cc5faea4f782611c5d2c6b8ac2850","modified":1679395990649},{"_id":"themes/next/source/css/_variables/base.styl","hash":"c8b101c76b179877a22256922a56d30d0926bc51","modified":1679395990699},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ebee77b2307bf4b260afb06c060171ef42b7141","modified":1679395990712},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"7782dfae7a0f8cd61b936fa8ac980440a7bbd3bb","modified":1679395990680},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"d3a8f6e71c86926d0c2a247a31d7446d829736d5","modified":1679395990699},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"8a847a7bbdbc0086dd1de12b82107a854b43f5e5","modified":1679395990711},{"_id":"themes/next/source/js/schemes/muse.js","hash":"aa84bdd853a9b0646ad9157e26df949ba0ec57c3","modified":1679395990705},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"2db4462e9cb87b8aef3f50f850fed407de16da3e","modified":1679395990680},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"49c3063b46d65796003a822deed971abee41675e","modified":1679395990668},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"f3defd56be33dba4866a695396d96c767ce63182","modified":1679395990674},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"969c3797d4315a2873aa143d0674d251fa0c5703","modified":1679395990668},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"1239f1b432a6932b2bb9ebcfbaabf724b8f4e59a","modified":1679395990684},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"f768ecb2fe3e9384777c1c115cd7409e9155edd7","modified":1679395990684},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1679395990686},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"cf8446f4378dcab27b55ede1635c608ae6b8a5c8","modified":1679395990685},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1679395990686},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"fd4a2d2303f107a021837aa6e3d977c2f9d14c42","modified":1679395990687},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"5b0197e061f57e00875be3636ba372a67693abe0","modified":1679395990713},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b9388016f8d9274703e77e306a1feaad1b7b9d6c","modified":1679395990687},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"77d9c468897283223cdc922eb7e146ca7a83420c","modified":1679395990699},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"aa34abe71ad476922a0371bcac82cd8e5b45d383","modified":1679395990690},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"c4537fa2de33d98baff2c87a73801770414e0b69","modified":1679395990698},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e728caca94567b4d4215402d01e449e23969e7e1","modified":1679395990691},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"6630a642ad2311ec09466c962963c006c4df4c38","modified":1679395990695},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5c3dd08c520a16ee49f85fa12b4935e725ef261","modified":1679395990697},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"7905f428b46d100ac5928875cb1e2b99fa86fc0b","modified":1679395990697},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"8ece7c8d3f95b7db3588465faff66adeff4d406e","modified":1679395990694},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1d29eca70fa686d895f8e98a283e4a159e40905a","modified":1679395990696},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8edf8fc4bc4a3913822fa4f8cf5abf3bcf011f56","modified":1679395990694},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e06e0fd44e39838ce22ac7829a2421f8c9e1b12d","modified":1679395990696},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"ec5d4e8ffe74722a092a69ace2f8dec7776466a8","modified":1679395990694},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"06835446a1c7353f434a9527889a53d6be69766c","modified":1679395990695},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1679395990695},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"507179f9d5648089e3b4da0e17cca74acc20e38a","modified":1679395990696},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1679395990695},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"a28f0858a0f4c3aac5496c693893696d5ac12372","modified":1679395990692},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"82311a531e26ca5a6ad17cf14959da75d4ac6106","modified":1679395990693},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"2db5ada757f7ffb9a36b06400cf30d80ec039b6e","modified":1679395990692},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"68f8d30071516913a7a958e01d010e8a93f7aa24","modified":1679395990693},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"89bf3f6b82cb0fafbbd483431df8f450857c5a0b","modified":1679395990693},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f9579a02599de063ccff336177ba964a2931a6e9","modified":1679395990706},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"f755e8537ccbbb0bd84c26923f320d4e206e7428","modified":1679395990707},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"f24604710002234f18a7b5cfe9ccdf3ed6e725a8","modified":1679395990707},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"14b024c920a8b359777d79dd8e1a849387f8f3ad","modified":1679395990708},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"77c231bcd64f1c09bd9989909e9fee703b65f47f","modified":1679395990708},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"d77d4934d959e7125128754b568f1d041c3fbfff","modified":1679395990706},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"72e0766752b78a723fb30e92d533a8b353104e2d","modified":1679395990708},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"b4cb06fdf531292e2361398a98d75a4ca2b8473a","modified":1679395990709},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"b9b9fd2f0e098a123b34a4932da912a9485ffe6c","modified":1679395990710},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"07e0038b221b9a4fd8ccac75093de3dee1f8315e","modified":1679395990709},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"68892d74ef5fc308c6e7e6b4f190826d79f3055d","modified":1679395990710},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"ec44d7f1c8b51b0aa3cccba099a78f3575ac828c","modified":1679395990711},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"5673d28509a8e837a512da490a88b7bf5162fc49","modified":1679395990709},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"1e8509356fb027d948d118ab220d9631f4d482fa","modified":1679395990710},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"e927000b375e79e2d173bdc6b8b45e67364fad4a","modified":1679395990713},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"e6361ed3d5fa959e11e90f7dab8fdaff398b4425","modified":1679395990713},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"d93556184b2c0aa1dbc4a6fb892d2f77b80d7d9f","modified":1679395990712},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"5c63ec71458b4fe0cd98fd4a04e11c3746764f11","modified":1679395990712},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"e109c2d6828f527f0289d5fa3bb02fce63ee6d93","modified":1679395990715},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"39066b4e2e914d85736c9c33fa51f21a3f86c0e4","modified":1679395990677},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"c8648c8ea3105556be0068d9fb2735261d0d94bc","modified":1679395990678},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"05af22f3edc2383a3d97ec4c05e9ac43b014bead","modified":1679395990678},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"038625515ba4760e4dda6792549bddc0db5a3d20","modified":1679395990678},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"06d551ef6e26d426bb3ffb4638714488c7cbce66","modified":1679395990679},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"dce8ea62d7d7b08a0444fbb2f617be30bfcfc152","modified":1679395990679},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"d9bc2b520636b9df7f946295cd430593df4118ff","modified":1679395990679},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"bdfef8d2363bc199dfbcc23ee833edca27cc9fcf","modified":1679395990681},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b3689beb90cda64cafecaf6b25981fe8a9525992","modified":1679395990681},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2c2bfbc34b6f19d262ae7c041474985e12f4f4ad","modified":1679395990682},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"63d8f5f169c2b1c969928fc79244c5fe89ee484e","modified":1679395990682},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"f8a97aad14e0b16b555ee0048da5402f818f9693","modified":1679395990682},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"d8a028f532d562e6a86bb3b9c7b992e4b6dbbb51","modified":1679395990682},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"8f82d5141a18f6319e0609a3f6e4fcca6d442203","modified":1679395990683},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"cbc6b0938a2e60f35a5df32210904fb16e4938da","modified":1679395990683},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2de038def2cb91da143b14696366c14a66e0e569","modified":1679395990684},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fde10ce94e9ae21a03b60d41d532835b54abdcb1","modified":1679395990668},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"509bad7d1d6b5c6f24a3f205b2ed7b65a2326dd4","modified":1679395990683},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"80595d274f593b321c0b644a06f3165fe07b16f5","modified":1679395990669},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"091b8c763e43447d087c122a86538f290f83136a","modified":1679395990670},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"aa04527f76de7646573ea327d4f6145200d6070d","modified":1679395990671},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1679395990669},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"56d719bcdcba3d725141c55bbd4b168f3942f912","modified":1679395990670},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"268e0a4cf638b9ce4db07268031ab34c5f31ac65","modified":1679395990671},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"eebe3013a9a976011570dce2d04dfeae4c31d790","modified":1679395990671},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"7245d8364092c2d184e658e801ba94815a2a1f81","modified":1679395990672},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"c34936a17c3d8af6c0988ac6746d7509dc0b50eb","modified":1679395990673},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"4790d37a40b80f7278ec55274f017dad21791038","modified":1679395990672},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"4d29b6ae7ed3dc44b10df851a4128b6441efa8be","modified":1679395990673},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"69dff7cf231d01f85671758455726dd666664a73","modified":1679395990673},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"777efaacbabb623f1d77fac5dd784401f8dea4cd","modified":1679395990673},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"65dde3ba925ac19b0bfcb7fa70cf4157bec02576","modified":1679395990674},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"a2ffaa06c963514a79fda52665e707af6e8e2f5e","modified":1679395990675},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"406c03be3cf8a8411227bc1fecf942ca368f7e2a","modified":1679395990675},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"7b36f776c41fbb744572c5de2c8d49b35656ec21","modified":1679395990675},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"08d609b0534b9a5151cab7e6d54c0dec6a8dad8c","modified":1679395990676},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"1e5776ad4c5c8bcf7596ac74dcabc30704b3f5a0","modified":1679395990676},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"49c26184580fde8a732899a4de5aae8662e289b8","modified":1679395990676},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"d28856f365a9373c4ae6fe1e5673d63df2dfd65f","modified":1679395990677},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"ce12b5007c9aa997738641c06a1c081c357e27bd","modified":1679395990714},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"e9fffe2a14751e86aed5e84a5e96514413eac2dc","modified":1679395990715},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"a3ea8e3d2347f417ec163d191c9d7c1e9d606c1e","modified":1679395990686},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"7db3233f0b33870943ce1547326a67f9e628b411","modified":1679395990714},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"6b3680e0dbea8e14c1cec24ef63b7fae5e37f7ef","modified":1679395990688},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"8d9218980e185210ce034e9769ab639b9630fd88","modified":1679395990688},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"e22fde6f1657d311d46f64d868c4491d535c8caa","modified":1679395990688},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"531daf2612c6217950677a2d03924459ce57c291","modified":1679395990689},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7075dd32dd70da1e161e4bd14b46f1e8be62fa3c","modified":1679395990689},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"c7754dc6c866928b538f0863a05b96ec44b5e986","modified":1679395990689},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"77122986509a6b4968bae2729417b7016137534c","modified":1679395990690},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"3324e9d09faf3903bc9815358bda4000bbb691fa","modified":1679395990690},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f71b2022094c5bc8c74b4ed049639f7262e0b182","modified":1679395990690},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"047bf8176ea24e277b1a4f6e6ad599033f1d1a44","modified":1679395990685},{"_id":"source/images/assets/image-20231130162207-amricr9.png","hash":"a629b5496d2e675e06d80bf1fd830d2bf9865217","modified":1701332527000},{"_id":"source/images/assets/image-20231130163419-dlucov7.png","hash":"6791c9a47e7b0ddbe4409a661e04b0bb70db8cc7","modified":1701333259000},{"_id":"source/images/assets/image-20231130162334-wq8knl7.png","hash":"8a512c45e991c70d3fc00a9e64230b457cc4e870","modified":1701332614000},{"_id":"source/images/scheduled_5_5.png","hash":"3b54d741b658072ca1d1206ef1e608ebd956c844","modified":1696929342779},{"_id":"source/images/assets/image-20231130165000-f9u4xav.png","hash":"827a7929d7bf9a448c49165b6005afb4b7044ebc","modified":1701334200000},{"_id":"source/images/assets/image-20231204174826-1q081wx.png","hash":"66b86ab7703d3cfe8784068ad262c24b0bd322ac","modified":1701683306000},{"_id":"source/images/Scheduled定时任务注册.png","hash":"223a40a078ccd84c5554ae61429baa56ddb169e7","modified":1696745778390},{"_id":"source/images/ScheduledAnnotationBeanPostProcessor-单例bean可以注入.png","hash":"4e25b4942c43f4872a1682413270e3c33339717b","modified":1696745188882},{"_id":"source/images/skywalking1.png","hash":"5bbb5ea7b6b0037ce28ea6c33c820d8d75957205","modified":1695895446625},{"_id":"source/images/assets/image-20231130165557-5lors2o.png","hash":"6a32a7d743e16df488bd259143438446703c40f6","modified":1701334557000},{"_id":"source/images/ScheduledAnnotationBeanPostProcessor-scope_prototype无法注入定时任务.png","hash":"7e2a18f934aa904b5b8867b1aada1b9bc6acc8ef","modified":1696744456001},{"_id":"source/images/assets/image-20240116183756-jtgrcuo.png","hash":"a6167964f3db9ab5ad8eceaabf4de890873cc8a9","modified":1705401476696},{"_id":"source/images/scheduled_5_2.png","hash":"a07787cc0f71bb77bccf75e27ba2080cf153a371","modified":1696920738362},{"_id":"source/images/schedule执行.png","hash":"e3c6cbd1db60287a64f2c0daad927c4c2aad2b64","modified":1696751115942},{"_id":"source/images/assets/image-20231130170131-pfyz6vu.png","hash":"746d6a7ba7354c09314ff8ea8575a318f4985105","modified":1701334891000},{"_id":"source/images/spring5-scheduled注册.png","hash":"21e3324c8edcf613535d45a2b4a54b74dbe2beba","modified":1696762549195},{"_id":"source/images/beanFactory加载不到Scheduled的BeanPostProcessor.png","hash":"63223a51e9e6dda181b739e88ed7a8567d076ce5","modified":1696915372190},{"_id":"source/images/assets/image-20231204162214-4g1bw2e.png","hash":"489555403bffe92641144f7d7d6835e85b44039c","modified":1701678134000},{"_id":"source/images/Autowired2.png","hash":"6c8c0f2cd80d00dd120108046ea5f63778b03497","modified":1697003128681},{"_id":"source/images/scheduled_5_1.png","hash":"f2108fed52556d767ec9727136c0b414181958b2","modified":1696915597722},{"_id":"source/images/scheduled_5_4.png","hash":"8cc53f0d399512b93dc60165a356e73f5b6327c9","modified":1696924090590},{"_id":"source/images/assets/image-20240117120120-oyzznx1.png","hash":"903df33f7195762e33ed4136011e3771b97a0d91","modified":1705464080000},{"_id":"public/404/index.html","hash":"f25706912406ff53ec9f38b37c587ec7cb750719","modified":1715681216516},{"_id":"public/tags/index.html","hash":"e5b9bed0da64a30ae8c7c17cb7c4c9335a185f9c","modified":1715681216516},{"_id":"public/2024/04/29/Raft算法解析/index.html","hash":"45859be4bfd71d2c273fdcd9702cf2de477f2a2f","modified":1715652471547},{"_id":"public/categories/index.html","hash":"f77bfc5c088eef31deea3099d07e2ceb17f14fc0","modified":1715681216516},{"_id":"public/2024/04/29/Nacos源码/index.html","hash":"a9cdbf03764fba2f7170115ec060eb0878d2911c","modified":1715681216516},{"_id":"public/2023/12/26/Spark/index.html","hash":"5155f9a27622541d4ffe0a40a42fa6c6170ed323","modified":1715681216516},{"_id":"public/2023/12/26/Flink/index.html","hash":"4a12e0fe6e5c5b6034d8eb4540a592b50f4b1686","modified":1715681216516},{"_id":"public/2023/05/06/OLAP浅入/index.html","hash":"644d0e8571ceb4caa4c00790487cfb906c1d40f6","modified":1715681216516},{"_id":"public/about/index.html","hash":"62bee56a1934b12d882deef8cd635b8d41f53e9d","modified":1715681216516},{"_id":"public/2024/04/29/SpringEvent应用/index.html","hash":"c4c251b9c4edadcfe9cdb2b382204c31652a105a","modified":1715681216516},{"_id":"public/2024/04/28/CompletableFuture/index.html","hash":"f95fa35b372fd1406f5f171fcec4bc817b33ff10","modified":1715681216516},{"_id":"public/2024/04/24/分布式限流sentinel/index.html","hash":"ac32fb9f8b6fb831c9b78e23355b52031a2de187","modified":1715681216516},{"_id":"public/2024/02/18/Mybatis源码/index.html","hash":"e1cb509e9ad7490622f53b2ad4e6023826e91a6f","modified":1715681216516},{"_id":"public/2024/01/30/kubernetes-3-安装与使用/index.html","hash":"fff3b8bbf4bd702cc4ee090a0b7816823418311a","modified":1715681216516},{"_id":"public/2024/01/30/kubernetes-2-相关概念/index.html","hash":"f15bfbbda419b77aaf96a8dd3c2ecd9a09ded5ee","modified":1715681216516},{"_id":"public/2024/01/24/redis集群-cluster/index.html","hash":"d851db130a8aaf01def511dfb4bb5a578a3e2f4f","modified":1715681216516},{"_id":"public/2024/01/19/redis集群-sentinel/index.html","hash":"2b7dc540b5c1bcbb857f90d64a582180f1f10afd","modified":1715681216516},{"_id":"public/2024/01/16/RBAC权限模型/index.html","hash":"9b302ac16a7e0c8645037a5036eee1efaeb6ac71","modified":1715681216516},{"_id":"public/2024/01/12/程序员练级攻略/index.html","hash":"8514ec82ca15699f250cbc6f37a0af222a950b1b","modified":1715681216516},{"_id":"public/2024/01/04/一次OOM分析/index.html","hash":"5a141dd86c7dc2229ae04ce0d26beb4ac4d0f7f4","modified":1715681216516},{"_id":"public/2024/01/03/kubernetes-1-基本架构/index.html","hash":"35bfd4d15345f00d417c355df230e2ce89920087","modified":1715681216516},{"_id":"public/2023/12/26/Redis高级功能/index.html","hash":"ca28ccdf42d80cc31ad2fbb937aaec54d67e4379","modified":1715681216516},{"_id":"public/2023/12/20/jdbc处理大数据时的坑/index.html","hash":"5fdee166baeb169f23057cccd88716356df424b1","modified":1715681216516},{"_id":"public/2023/12/19/dataX-异构数据离线同步/index.html","hash":"be49814e1c7c8bb9f557ad23bd3c1c3eb182fab7","modified":1715681216516},{"_id":"public/2023/10/18/TiDB解决事务冲突/index.html","hash":"fd8ccc9c8696f17ab1938896f19766ef6342dfd0","modified":1715681216516},{"_id":"public/2023/10/11/Spring源码-Autowired注解/index.html","hash":"b9be533c98805724154e7cd1090d6ddb5251516b","modified":1715681216516},{"_id":"public/2023/10/08/Spring源码-Scheduled注解/index.html","hash":"4eb161d48cc3041e50dba8c7a3878a2c12ef3298","modified":1715681216516},{"_id":"public/2023/09/26/从Docker到Kubernetes/index.html","hash":"accd72ffbaad6138f1dadcfdca043563abbc2cb0","modified":1715681216516},{"_id":"public/2023/09/26/skywalking与分布式链路追踪/index.html","hash":"f3df6f74f5febb6efa0477e7ad61f5438b940178","modified":1715681216516},{"_id":"public/2023/09/14/kafka入门/index.html","hash":"56eb7025d9d3c370f647e842e9ba72dac0829a2f","modified":1715681216516},{"_id":"public/2023/09/13/Tidb执行计划/index.html","hash":"73f53b922500834d86c7b6f32dee5ae893d6f66d","modified":1715681216516},{"_id":"public/2023/08/01/RedLock/index.html","hash":"6d6bcf459c978e318d898646b19636dd8efbb99f","modified":1715681216516},{"_id":"public/2023/07/17/跨域问题总结/index.html","hash":"0f119699007ce628d30ea5dde503403a44c3fb9a","modified":1715681216516},{"_id":"public/2023/07/10/理解服务端推送与实践/index.html","hash":"cec5343ce47ece3d55fd382c9fcbfe860969da81","modified":1715681216516},{"_id":"public/2023/07/07/arthas简述/index.html","hash":"ec9a6a9ae41afbbfb64f376f6ac8469292e9a10b","modified":1715681216516},{"_id":"public/2023/06/29/压力测试/index.html","hash":"a33e2641ee38a7647c7b6b123181ab2fae3e8615","modified":1715681216516},{"_id":"public/2023/06/13/DDD领域驱动设计/index.html","hash":"d65fa2d0f26b1bfe09a9e0b77df1dd04592b0b63","modified":1715681216516},{"_id":"public/2023/05/23/G1收集器/index.html","hash":"52fbe11151aeff6d99b693268db05ae27ee90f91","modified":1715681216516},{"_id":"public/2023/04/11/Gradle入门/index.html","hash":"d90b114325d8a703b664c1a1137f7018d3f05357","modified":1715681216516},{"_id":"public/archives/index.html","hash":"31b11c8102c58ef215bc4fbdbd646b816a674912","modified":1715681216516},{"_id":"public/archives/page/2/index.html","hash":"6c350dc90fb2f598ec61ef494493fc6049f00489","modified":1715681216516},{"_id":"public/archives/page/3/index.html","hash":"42fee0f418ec1f8d382a493647393a4f80a0539f","modified":1715681216516},{"_id":"public/archives/page/4/index.html","hash":"909f66237d70d8cc2460a65f55be3c02fb9a72da","modified":1715681216516},{"_id":"public/archives/2023/index.html","hash":"e9a175f9424192c7736274ac5872c0b9a7ebe5ac","modified":1715681216516},{"_id":"public/archives/page/5/index.html","hash":"2d5e04a4fa15a292539850a217d4fbb5f08b6c2f","modified":1715681216516},{"_id":"public/archives/2023/page/2/index.html","hash":"d3e63d99f79c30a9e6ad617afd74f3376630ca30","modified":1715681216516},{"_id":"public/archives/2023/page/3/index.html","hash":"6053a475c66f2ddc482bdd21efc73b5366a6c634","modified":1715681216516},{"_id":"public/archives/2023/03/index.html","hash":"2fbfbc8dd2696f57f967acd3a6da8560d8de02ba","modified":1715681216516},{"_id":"public/archives/2023/04/index.html","hash":"084c1a8591951a3632f325c7be46c5e2ce0015ee","modified":1715681216516},{"_id":"public/archives/2023/05/index.html","hash":"80cb2b892e12b2969d3ede92e5ce209077969e21","modified":1715681216516},{"_id":"public/archives/2023/06/index.html","hash":"5ce8da052fed594880692715608924e3b40f79fc","modified":1715681216516},{"_id":"public/archives/2023/07/index.html","hash":"e10db6e83bbedd83d915bab8098da0a8bd3438ca","modified":1715681216516},{"_id":"public/archives/2023/08/index.html","hash":"1fbe44eee4a3284a5a51663b894c690ed59e9e20","modified":1715681216516},{"_id":"public/archives/2023/09/index.html","hash":"e14bb6bdd5b2961f42b64a343f810549f643d376","modified":1715681216516},{"_id":"public/archives/2023/10/index.html","hash":"e4f29cfa1d4699fb2b2932f34f0952951585ca8c","modified":1715681216516},{"_id":"public/archives/2023/12/index.html","hash":"a0a4228b650cf73387c5774511b826c051ae9298","modified":1715681216516},{"_id":"public/archives/2024/index.html","hash":"a6928c0432f3898a00a11e3192a3fd9bce958aa9","modified":1715681216516},{"_id":"public/archives/2024/page/2/index.html","hash":"98cef4113d5769ac3b5d2a345e303b0a7bf3e415","modified":1715681216516},{"_id":"public/archives/2024/01/index.html","hash":"315d4868fc7000ef1a7b85e13c5a7f6e8215bd08","modified":1715681216516},{"_id":"public/archives/2024/02/index.html","hash":"f6cf07ca8589c38d1993bafe7623e72e3ddbb015","modified":1715681216516},{"_id":"public/archives/2024/04/index.html","hash":"f418340f3cc74bb2eb7d9129b60ccbb01d8e970b","modified":1715681216516},{"_id":"public/categories/其他/index.html","hash":"ffcaaf8014ee75945cbdc34a8ab4bddac2c964d6","modified":1715681216516},{"_id":"public/categories/大数据/index.html","hash":"286661ce1b3be223163b3eb4bfd38759521dfa5a","modified":1715681216516},{"_id":"public/categories/Spring/index.html","hash":"b0cd4a176e811ee4dadda8229a35295de3e0cc32","modified":1715681216516},{"_id":"public/categories/Spring/page/2/index.html","hash":"5260f94b38cff2020daea96be2f61495c8d67dcd","modified":1715681216516},{"_id":"public/categories/中间件/index.html","hash":"82c1beb8205a2f9a39cb1ced5f0810e875218ea1","modified":1715681216516},{"_id":"public/categories/数据库/index.html","hash":"65f815334640ab3d9dd77bea8b50e7016ca9ffc6","modified":1715681216516},{"_id":"public/categories/troubleshooting/index.html","hash":"e805501a7ac730d7686554028309eed934c94dbf","modified":1715681216516},{"_id":"public/categories/云原生/index.html","hash":"ed73c1a9d0ff172b64aebe2c71e2fe93e3cf528c","modified":1715681216516},{"_id":"public/page/5/index.html","hash":"6bf9649c046963a9b9a7c4c65b103fcf9f6d188d","modified":1715681216516},{"_id":"public/tags/DDD/index.html","hash":"c6dd2e84f78dc8c2be765dc701c7430134a87434","modified":1715681216516},{"_id":"public/tags/Flink/index.html","hash":"8ee9a7bb497863c81de8849326d5b6f1e4d913b7","modified":1715681216516},{"_id":"public/tags/大数据/index.html","hash":"94876b56edab63c9d11b34174d7c8f91b98dafe3","modified":1715681216516},{"_id":"public/tags/java/index.html","hash":"04b6726c8838eedd24b36c525d1cd4650ce7ef83","modified":1715681216516},{"_id":"public/tags/JVM/index.html","hash":"cbef50f651d2e13894984311363f7d5114add1f8","modified":1715681216516},{"_id":"public/tags/垃圾回收/index.html","hash":"457935aabc49c8bd4d78d72ca9cf65e2126a2820","modified":1715681216516},{"_id":"public/tags/gradle/index.html","hash":"95aa1825c19711e81906b40fb30afbfd9bf3412c","modified":1715681216516},{"_id":"public/tags/hexo/index.html","hash":"1c16cbc72b796926e2af0936c630fa7b44d6eefd","modified":1715681216516},{"_id":"public/tags/blog/index.html","hash":"49590409c5fdcfb20bffcc008057240e4cb7720b","modified":1715681216516},{"_id":"public/tags/mybatis/index.html","hash":"abdac6c7849d5d974fc23af378bd2bacc6e8f356","modified":1715681216516},{"_id":"public/tags/OLAP/index.html","hash":"c288271ff93ade4480905d3609c1e4858bb50e08","modified":1715681216516},{"_id":"public/tags/clickhouse/index.html","hash":"61c768fd2c39a238b40b6ffb4d02c9c278487d32","modified":1715681216516},{"_id":"public/tags/RBAC/index.html","hash":"6cf4807acc534e13d56a6e19b1f1be13c5e25f22","modified":1715681216516},{"_id":"public/tags/redis/index.html","hash":"6572d4134a10f75ae1f62028c0a16c8fe30ab493","modified":1715681216516},{"_id":"public/tags/Redis/index.html","hash":"90fa31c9534e721026c51fea2c84165c7c5ce149","modified":1715681216516},{"_id":"public/tags/Spark/index.html","hash":"a00b8274b3b495d0f8383548a653c05153dd1f62","modified":1715681216516},{"_id":"public/tags/spring-cache/index.html","hash":"75cd4c4f3b1ca23956877aaba62805e0b8d1a9c3","modified":1715681216516},{"_id":"public/tags/spring增强/index.html","hash":"823cf917cbf32f2c160effc248513d6896172be2","modified":1715681216516},{"_id":"public/tags/Spring源码/index.html","hash":"7e75eaf807818674963083b939603a9c1c8ebfbe","modified":1715681216516},{"_id":"public/tags/Tidb/index.html","hash":"3b0dcf4c29b4f8cd5dbfaf0af704c3cca5cf9d60","modified":1715681216516},{"_id":"public/tags/spring-aop/index.html","hash":"8b061d524b976983fa756df0caad5a0e1e18151c","modified":1715681216516},{"_id":"public/tags/AspectJ/index.html","hash":"bf894222e38dd2e4f0c560f0e96d8e7878005e86","modified":1715681216516},{"_id":"public/tags/arthas/index.html","hash":"f5537b2d3a62befd77d3c6e9c3f97a7c11a55b83","modified":1715681216516},{"_id":"public/tags/spring-event/index.html","hash":"c9d40e877a27516f47d8e62df7a588b247831f6c","modified":1715681216516},{"_id":"public/tags/dataX/index.html","hash":"34f415b64afcc26602dee554283be59d3ae41b75","modified":1715681216516},{"_id":"public/tags/grpc/index.html","hash":"3354bc7483845ea4609da5ae300d6158a68b062d","modified":1715681216516},{"_id":"public/tags/jdbc/index.html","hash":"e4576a39c51fb7ead462435794e385f7896045af","modified":1715681216516},{"_id":"public/tags/数据库/index.html","hash":"49cb4ec29e1c82588cdb85696b6f2a5cdf3139cf","modified":1715681216516},{"_id":"public/tags/kafka/index.html","hash":"e6b4556a25e94ef0a6026f94c4b0b6176df62a97","modified":1715681216516},{"_id":"public/tags/kubernetes/index.html","hash":"ee1ae9d5db4b7f1c64352bc957a6ca02422029c6","modified":1715681216516},{"_id":"public/tags/protobuf/index.html","hash":"32c0e9eb5e075b8edfce9f7f377ea8d2194c6678","modified":1715681216516},{"_id":"public/tags/skywalking/index.html","hash":"d342d51a4f91e825ee253f54b76734616d99c45a","modified":1715681216516},{"_id":"public/tags/OOM/index.html","hash":"b2d80de55e8f32d07ca6a11ae7863153ddcaab4b","modified":1715681216516},{"_id":"public/tags/k8s/index.html","hash":"61f02970ad21f0389d9e56a461222652a7e0149e","modified":1715681216516},{"_id":"public/tags/限流/index.html","hash":"6c5fe8d67dfe13bcca844363698787c93a66d3dd","modified":1715681216516},{"_id":"public/tags/压力测试/index.html","hash":"ffc8f702c400650efb57974ac63bc1f54356f279","modified":1715681216516},{"_id":"public/tags/sentinel/index.html","hash":"e23df5a2ea065e49811995449f4a11f0f2228f18","modified":1715681216516},{"_id":"public/tags/SSE/index.html","hash":"3b3d992e01dc3213761e74436fe3840d62935e91","modified":1715681216516},{"_id":"public/tags/websocket/index.html","hash":"f0d0082d877a1dcbfa35dca252b00eb3fa96dec5","modified":1715681216516},{"_id":"public/tags/comet/index.html","hash":"651543e239c1a1211eed65b7f868f4642026e161","modified":1715681216516},{"_id":"public/tags/跨域/index.html","hash":"a01a389304db211095ca983b7982550b553fc143","modified":1715681216516},{"_id":"public/2023/04/06/Spring-AspectJ织入/index.html","hash":"31d6c8a30479974eb91ea5046b7ccdeed5d63668","modified":1715681216516},{"_id":"public/2023/03/31/Spring-Cache/index.html","hash":"1d6f96bf2061c5d4373a155b4e35f88aeee9342f","modified":1715681216516},{"_id":"public/2023/04/04/Sping-Cache源码/index.html","hash":"e6da401e6db5a5f35a233930ed3026b853051c15","modified":1715681216516},{"_id":"public/2023/03/23/Hexo-Guide/index.html","hash":"b5b8bd79e498f07f8a7a8048ba9383b9a9a55053","modified":1715681216516},{"_id":"public/2023/03/19/protobuf/index.html","hash":"98ab67bc273078b95441aed5c6f300f12958fdef","modified":1715681216516},{"_id":"public/2023/03/19/gprc/index.html","hash":"2696c59904f5c762a0611b48ee85192e20684dcc","modified":1715681216516},{"_id":"public/index.html","hash":"053ec86e8eb35007e7721f7f9aea1e56e8f51efb","modified":1715681216516},{"_id":"public/page/2/index.html","hash":"c1a497d81afb646850b697ca0d9f562356a1d681","modified":1715681216516},{"_id":"public/page/4/index.html","hash":"3046f5758e0fab51bce4c3594dee650d12b630a3","modified":1715681216516},{"_id":"public/page/3/index.html","hash":"c56c02b693e24ce472127d6ff4eaae3ce61d2e89","modified":1715681216516},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1715652471547},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1715652471547},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1715652471547},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1715652471547},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1715652471547},{"_id":"public/images/Autowired3.png","hash":"bc8e4f4e5e1bfc429f97642d28584ac1d2c4baab","modified":1715652471547},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1715652471547},{"_id":"public/images/SSE浏览器请求.png","hash":"f341ff238137b9932312a8a2a68b905607ea1d67","modified":1715652471547},{"_id":"public/images/arthas1.png","hash":"832502dbf49ccbfce533db0a496e0894bc324549","modified":1715652471547},{"_id":"public/images/arthas2.png","hash":"832502dbf49ccbfce533db0a496e0894bc324549","modified":1715652471547},{"_id":"public/images/datax1.png","hash":"d7bdfb6ca3587296b18f85e5d960026a18f534ee","modified":1715652471547},{"_id":"public/images/gradle-command.png","hash":"e74d9451a306107c8420b47cbd9ecb35be8980af","modified":1715652471547},{"_id":"public/images/coder/Metrics1.png","hash":"702691d040550ebb17d38daa00ecd7a672ba6edf","modified":1715652471547},{"_id":"public/images/GC/copy.png","hash":"fa9634fc19f68640345e227c9ca65fb820ef7062","modified":1715652471547},{"_id":"public/images/GC/mark-clean.png","hash":"8565a336f71878e57ec1240691128a18a018a9e8","modified":1715652471547},{"_id":"public/images/GC/mark-compress.png","hash":"7c4db03de1fd236e413887e7cc07521b7ee241bc","modified":1715652471547},{"_id":"public/images/coder/Metrics2.png","hash":"087d4889914c4e0f636819f41a76cac62f69a6c6","modified":1715652471547},{"_id":"public/images/coder/Metrics3.png","hash":"8837e6cbcc149d0d11962c32a550831e944abfe5","modified":1715652471547},{"_id":"public/images/k8s/1部署演化.png","hash":"993780da4c110e984619011e3d82f42bee5ce8b3","modified":1715652471547},{"_id":"public/images/assets/image-20240104152220-2izpt7h.png","hash":"40b7b0f250ac1204a945d4ca87137fa0f2e0e46c","modified":1715652471547},{"_id":"public/images/assets/image-20240104154329-g9hnw90.png","hash":"5dbc959ba1595000dd7d7f5830fc01e03de95031","modified":1715652471547},{"_id":"public/images/assets/image-20240104155246-fieh1f7.png","hash":"11b9fc3483afe6012c4320f5d264d83d0f78d637","modified":1715652471547},{"_id":"public/images/assets/image-20240116165959-vy9w5gu.png","hash":"5e6448dec2205f2751731565b26c8725fcacff6f","modified":1715652471547},{"_id":"public/images/assets/image-20240226173616-kau7kcb.png","hash":"0f3db801b6d754530dcbbfbd55d9c121029be802","modified":1715652471547},{"_id":"public/images/assets/image-20240226173645-8641hbr.png","hash":"737a273f4b6cbd62b449388e517d817b7e4fb709","modified":1715652471547},{"_id":"public/images/assets/image-20240430164433-bng4qnr.png","hash":"3f5f3ee744408518dd8d1b9d8d98b1a478c13029","modified":1715652471547},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1715652471547},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1715652471547},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1715652471547},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1715652471547},{"_id":"public/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1715652471547},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1715652471547},{"_id":"public/js/pjax.js","hash":"b03ba78c6916ad2f390d55bc1bc18fafb64b0ebf","modified":1715652471547},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1715652471547},{"_id":"public/js/schemes/muse.js","hash":"ba7ba2c129d1f240c6a22cec3e53f3f22af64b6b","modified":1715652471547},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1715652471547},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1715652471547},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1715652471547},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1715652471547},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1715652471547},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1715652471547},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1715652471547},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1715652471547},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1715652471547},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1715652471547},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1715652471547},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1715652471547},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1715652471547},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1715652471547},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1715652471547},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1715652471547},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1715652471547},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1715652471547},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1715652471547},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1715652471547},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1715652471547},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1715652471547},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1715652471547},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1715652471547},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1715652471547},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1715652471547},{"_id":"public/css/main.css","hash":"ae9885789639678e3e162499bf5b3e7ffa70c9ea","modified":1715652471547},{"_id":"public/js/utils.js","hash":"5e1cf39de050964e97fb3ba0825aeec7f4bc36dd","modified":1715652471547},{"_id":"public/images/Autowired1.png","hash":"a1eaff2075ec87f13ae271c61719b9c875e936e4","modified":1715652471547},{"_id":"public/images/6f68e8517ae6e68ac63f4a34b8d14ca5.png","hash":"09641cc351098a3b5901a35acc75b70baebcea85","modified":1715652471547},{"_id":"public/images/Autowired6.png","hash":"350d0866b23ccc66e77b826ae531783daf3298e9","modified":1715652471547},{"_id":"public/images/DDD四层模型.jpg","hash":"7a019c1d1094d81621148967b23c36b09c693f0d","modified":1715652471547},{"_id":"public/images/Autowired9.png","hash":"fe07ac70d680f2b019bb446966a0563acae65fa4","modified":1715652471547},{"_id":"public/images/TiDB-01.png","hash":"4fd0efde7a714dda290b314ae40af425f4863d8a","modified":1715652471547},{"_id":"public/images/gradle-idea-config.png","hash":"02f03a0358a6f383426496938f27a92722c54fc9","modified":1715652471547},{"_id":"public/images/assets/image-20240104160611-xmslynf.png","hash":"4365ec3236cd05a11c76d3d702d639567083c96c","modified":1715652471547},{"_id":"public/images/assets/image-20240116170020-sq3x22z.png","hash":"8726bea1e5e4d2021c48a2c677e66932dd16e607","modified":1715652471547},{"_id":"public/images/assets/image-20240116170034-fs3xv9q.png","hash":"3f7319194b22bc1c94a82be2ebe191c1bc15fda7","modified":1715652471547},{"_id":"public/images/assets/image-20240116183723-ievwwyy.png","hash":"8e43eb7fe08beb3115420e802c0665486cda076b","modified":1715652471547},{"_id":"public/images/assets/image-20240425162917-mdlq5qj.png","hash":"4bc714eea2d17fa26509e0cbd5c38ad3a8ba376d","modified":1715652471547},{"_id":"public/images/Autowired10.png","hash":"e203493e3595f0a1011662ad76f77cb7ecd2995d","modified":1715652471547},{"_id":"public/images/Autowired4.png","hash":"215a18d06fe59a6505b6da6d1ae3d7d138772025","modified":1715652471547},{"_id":"public/images/Autowired5.png","hash":"399684775432b92afe0ba0b97594f3deba26266c","modified":1715652471547},{"_id":"public/images/Autowired8.png","hash":"0b3afc2724f37ef671a2e23b305d9f23cc9f649f","modified":1715652471547},{"_id":"public/images/assets/image-20231130161537-k6jp4kq.png","hash":"12a16b1a764bfa079ea6e07155f611c0dcf11821","modified":1715652471547},{"_id":"public/images/assets/image-20240104155650-95jxrin.png","hash":"c6cbc314a5ffb169270a3a8e8d1b2684b4d6b3c4","modified":1715652471547},{"_id":"public/images/assets/image-20240104155916-dw9zsud.png","hash":"3e3a09d2508303bae10139491a376fc9af4b0c54","modified":1715652471547},{"_id":"public/images/assets/image-20240116170050-p7vvxyi.png","hash":"7f0ee1acd5e63f69ae1fd5d2ca4690e286d83605","modified":1715652471547},{"_id":"public/images/assets/image-20240513172430-zijsvdp.png","hash":"1a3abfc21e36ba37916098897dc1b36bd31d0128","modified":1715652471547},{"_id":"public/images/Autowired7.png","hash":"1a588863d8f822e7cc64646bd10aeeb7bf026f3f","modified":1715652471547},{"_id":"public/images/scheduled_5_3.png","hash":"7a68d710568f484a8f6f035a0f25e31951dd6fa3","modified":1715652471547},{"_id":"public/images/skywalking2.png","hash":"c41fa09e352abf92cb426596c3d8d9d01493cb96","modified":1715652471547},{"_id":"public/images/spring5-scheduled注册0.png","hash":"ab6068458933827a7f57ba0bf952973c5a45ea98","modified":1715652471547},{"_id":"public/images/assets/image-20231130160711-ora87uk.png","hash":"77fd269719428e501212c0fbd07d3572adf20452","modified":1715652471547},{"_id":"public/images/assets/image-20240104160141-n1db8go.png","hash":"28f8d52f49e1d04667105a67e31222c4f3e06ce9","modified":1715652471547},{"_id":"public/images/assets/image-20240116140626-xdrpftt.png","hash":"0156884845119fa948a566544e291d48ff20b763","modified":1715652471547},{"_id":"public/images/assets/image-20240511180118-9ol9gj4.png","hash":"6e87117a9ccbc1c6aa685cc3caa57df3103fc489","modified":1715652471547},{"_id":"public/images/skywalking3.png","hash":"00a2f20bba8c3fea6687d4b8298ddaade856f878","modified":1715652471547},{"_id":"public/images/assets/image-20231130153853-ui2udcs.png","hash":"4fe03f668a0ff149064258053cf3b0609f340ff1","modified":1715652471547},{"_id":"public/images/assets/image-20231130154646-n3tfgm6.png","hash":"c16aa3b799f7ef88c01ca7251c9fe0557016d00b","modified":1715652471547},{"_id":"public/images/assets/image-20231130161950-nthyx0q.png","hash":"d25927b8e4f4603a7393318710e862edad65c099","modified":1715652471547},{"_id":"public/images/assets/image-20231204111109-ayhkc67.png","hash":"a0f9a3ab829362430d2aec39a86eaf844c9040d7","modified":1715652471547},{"_id":"public/images/assets/image-20231130163626-b3ijn8u.png","hash":"b35ff3718de10f81cae9a75310075ca9650d88ca","modified":1715652471547},{"_id":"public/images/assets/image-20240116183756-jtgrcuo.png","hash":"a6167964f3db9ab5ad8eceaabf4de890873cc8a9","modified":1715652471547},{"_id":"public/images/assets/image-20240123142211-7frka5a.png","hash":"636781a33a6ad3bc1b833a117b1828fb6f86ecf8","modified":1715652471547},{"_id":"public/images/assets/image-20231130162207-amricr9.png","hash":"a629b5496d2e675e06d80bf1fd830d2bf9865217","modified":1715652471547},{"_id":"public/images/assets/image-20231130163419-dlucov7.png","hash":"6791c9a47e7b0ddbe4409a661e04b0bb70db8cc7","modified":1715652471547},{"_id":"public/images/assets/image-20231130162334-wq8knl7.png","hash":"8a512c45e991c70d3fc00a9e64230b457cc4e870","modified":1715652471547},{"_id":"public/images/ScheduledAnnotationBeanPostProcessor-scope_prototype无法注入定时任务.png","hash":"7e2a18f934aa904b5b8867b1aada1b9bc6acc8ef","modified":1715652471547},{"_id":"public/images/scheduled_5_5.png","hash":"3b54d741b658072ca1d1206ef1e608ebd956c844","modified":1715652471547},{"_id":"public/images/assets/image-20231130165000-f9u4xav.png","hash":"827a7929d7bf9a448c49165b6005afb4b7044ebc","modified":1715652471547},{"_id":"public/images/assets/image-20231204174826-1q081wx.png","hash":"66b86ab7703d3cfe8784068ad262c24b0bd322ac","modified":1715652471547},{"_id":"public/images/Scheduled定时任务注册.png","hash":"223a40a078ccd84c5554ae61429baa56ddb169e7","modified":1715652471547},{"_id":"public/images/ScheduledAnnotationBeanPostProcessor-单例bean可以注入.png","hash":"4e25b4942c43f4872a1682413270e3c33339717b","modified":1715652471547},{"_id":"public/images/skywalking1.png","hash":"5bbb5ea7b6b0037ce28ea6c33c820d8d75957205","modified":1715652471547},{"_id":"public/images/assets/image-20231130165557-5lors2o.png","hash":"6a32a7d743e16df488bd259143438446703c40f6","modified":1715652471547},{"_id":"public/images/assets/image-20231130170131-pfyz6vu.png","hash":"746d6a7ba7354c09314ff8ea8575a318f4985105","modified":1715652471547},{"_id":"public/images/scheduled_5_2.png","hash":"a07787cc0f71bb77bccf75e27ba2080cf153a371","modified":1715652471547},{"_id":"public/images/schedule执行.png","hash":"e3c6cbd1db60287a64f2c0daad927c4c2aad2b64","modified":1715652471547},{"_id":"public/images/beanFactory加载不到Scheduled的BeanPostProcessor.png","hash":"63223a51e9e6dda181b739e88ed7a8567d076ce5","modified":1715652471547},{"_id":"public/images/spring5-scheduled注册.png","hash":"21e3324c8edcf613535d45a2b4a54b74dbe2beba","modified":1715652471547},{"_id":"public/images/assets/image-20231204162214-4g1bw2e.png","hash":"489555403bffe92641144f7d7d6835e85b44039c","modified":1715652471547},{"_id":"public/images/Autowired2.png","hash":"6c8c0f2cd80d00dd120108046ea5f63778b03497","modified":1715652471547},{"_id":"public/images/scheduled_5_1.png","hash":"f2108fed52556d767ec9727136c0b414181958b2","modified":1715652471547},{"_id":"public/images/scheduled_5_4.png","hash":"8cc53f0d399512b93dc60165a356e73f5b6327c9","modified":1715652471547},{"_id":"public/images/assets/image-20240117120120-oyzznx1.png","hash":"903df33f7195762e33ed4136011e3771b97a0d91","modified":1715652471547},{"_id":"source/_posts/理解Raft简述.md","hash":"3565bb21b1dd0aba1046bcee91a5cef3b44fceb6","modified":1715681206786},{"_id":"source/images/assets/image-20240514143508-npmef32.png","hash":"c2980761ee7e7a66214e875c514ccb99f34fb602","modified":1715668508000},{"_id":"source/images/assets/image-20240508174543-ue2vter.png","hash":"b68b380c920981e2a1e2160292b60612aecb2ab7","modified":1715161543000},{"_id":"source/images/assets/image-20240509100554-j5ulk0q.png","hash":"e83f2b44a9547f65bf579f3601b866a4e2db9196","modified":1715220354000},{"_id":"source/images/assets/image-20240514152040-m7ea0hd.png","hash":"d65524bea0f3ca0ce4c7c7adfa7e9e2ded2c4cab","modified":1715671240000},{"_id":"source/images/assets/image-20240514145801-mfzjlbf.png","hash":"5d13e751e6d5eb62b809168331678be7657de10c","modified":1715669881000},{"_id":"public/tags/Raft/index.html","hash":"e6ec9e0e6fc0a73bcf0bcf96d8173e0980ebf8aa","modified":1715681216516},{"_id":"public/2024/04/29/理解Raft简述/index.html","hash":"3dafa0db54c268c0ea873b063cd8fb578a1640fa","modified":1715681216516},{"_id":"public/images/assets/image-20240508174543-ue2vter.png","hash":"b68b380c920981e2a1e2160292b60612aecb2ab7","modified":1715681216516},{"_id":"public/images/assets/image-20240509100554-j5ulk0q.png","hash":"e83f2b44a9547f65bf579f3601b866a4e2db9196","modified":1715681216516},{"_id":"public/images/assets/image-20240514143508-npmef32.png","hash":"c2980761ee7e7a66214e875c514ccb99f34fb602","modified":1715681216516},{"_id":"public/images/assets/image-20240514152040-m7ea0hd.png","hash":"d65524bea0f3ca0ce4c7c7adfa7e9e2ded2c4cab","modified":1715681216516},{"_id":"public/images/assets/image-20240514145801-mfzjlbf.png","hash":"5d13e751e6d5eb62b809168331678be7657de10c","modified":1715681216516}],"Category":[{"name":"其他","_id":"clw5r6oyl0004qwvd4348a0h2"},{"name":"大数据","_id":"clw5r6oyp000bqwvddzitdfy1"},{"name":"Spring+","_id":"clw5r6oyq000hqwvdcmkr257k"},{"name":"中间件","_id":"clw5r6oyy0016qwvdbss7gig8"},{"name":"数据库","_id":"clw5r6oz1001nqwvd8svuaifr"},{"name":"troubleshooting","_id":"clw5r6oz3001uqwvdbha0gfqf"},{"name":"云原生","_id":"clw5r6oz7002eqwvddeythy3f"}],"Data":[],"Page":[{"title":"404","date":"2023-03-23T05:17:18.000Z","comments":0,"_content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2023-03-23 13:17:18\ncomments: false\n---\n<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"Back to home\">\n</script>","updated":"2023-03-23T05:17:41.415Z","path":"404/index.html","layout":"page","_id":"clw5r6oyf0000qwvdhxpsh8sr","content":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"Back to home\">\n</script>","site":{"data":{}},"excerpt":"","more":"<script src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"Back to home\">\n</script>"},{"title":"关于自己","date":"2023-03-22T03:22:22.000Z","_content":"\n# 个人信息\n**洪宗敏**  意向: 效能研发\n<table>\n    <tr>\n        <td>34岁</td> \n        <td>男</td> \n        <td>武汉</td> \n   </tr>\n    <tr>  \n  \t\t <td>15527282430</td> \n         <td colspan=\"2\">283341330@qq.com</td> \n    </tr>\n</table>\n\n\n\n# 自我评价\n- 有9年的web开发经验、4年运维经验，熟悉阿里云诸多产品\n- 能运用python/shell等脚本语言，有H5/微信小程序/移动端项目经验\n- 熟悉Spring源码，熟练掌握Java/Spring/Mybatis/Hibernate/MySQL/Redis\n- 熟悉Springboot, 熟练运用Nacos/Kafka/SpringCache/grpc等组件\n- 理解JVM，有参数调优和线上故障定位经验\n- 熟悉MySQL/PostgreSQL/TIDB等多种数据库，熟悉SQL调优\n> [个人博客 https://hugh126.github.io](https://hugh126.github.io)\n\n# 工作经历\n### 1. 海伦司科技有限责任公司 2018.11~现在  \n\n1. 为了让研发便于稳定发版但又不接触生产服务器。从0到1研发公司自动化运维平台：  \n主要集成发版、补丁、监控、SQL审批执行等功能\n2. 公司没有运维，积累大量一线问题解决及运维经验\n3. 有实际的公众号开发、小程序开发、IOSApp开发、智能IOT设备接入等项目经验  \n> 总结: 近5年时间，帮助团队从3人扩展到30人，承担运维开发多重职责，优化系统效率保障线上稳定\n\n### 2. 软通动力技术服务有限公司 2016.05~2018.09\n1. 协同华为武汉SDN团队，完成沙箱项目开发及展示\n2. 扩展团队从2人到9人，承接独立项目；熟悉了微服务开发的流程，积累大量CI/CD以及LLT经验\n\n### 3. 广州世纪龙信息网络有限责任公司(中国电信)  2014.7~2016.04\n使用python处理分段日志，完成流量监控分析平台开发与维护；其中熟悉了Linux与日志处理\n\n\n# 项目经验\n### 1. Ayplot自动运维平台\n运维平台是参考开源项目Walle的思想，借助开源平台jeecgboot实现自己的企业运维平台。\n- 技术栈：\nAnt-design-vue + Vue2 + SpringBoot2 + MybatisPlus3 + Redis+ Druid+ Mysql\n- 个人贡献：\n0. 集成环境管理、服务器管理、项目管理和部署回滚功能\n1. 支持mvn和ant打包成war或jar的打包方式\n2. 支持了前后置任务服务切量上下线，通过自定义shell关联前端更新部署\n3. 为方便审批发布，支持钉钉移动端审批\n4. 支持各服务自定义各自启动JVM参数\n5. 集成SQL的审批操作:发布前对比测试与正式数据库结构并同步,以及临时开发申请执行的SQL\n\n### 2. 企业ERP\n企业ERP是海伦司的基础服务配置平台，包含了人事、运营、采购、营销、财务几大模块。  \n- 技术栈：    \nJSP+ EasyUI + Jeecg(SpringMVC) + Hibernate+ Redis/Hazelcast + Druid+ Tidb\n- 个人贡献：  \n1. JVM参数调优，通过arthas解决线上OOM或CPU占用过高等问题\n2. 优化审批流：事务不完整问题；数据库记录与钉钉通知不一致问题；使用策略模式解决分支问题；封装Guava的MapDiff优化审批数据对比\n3. 优化quartz定时任务：使用Reids的发布订阅完成集群任务变更；自定义group控制是否执行；通过Listener记录任务执行详情\n4. 使用SSE优化批量同步金蝶过程中的信息反馈\n5. 优化慢SQL\n\n### 3. 华为开发者社区SDN-WAN沙箱项目开发\n为开发者社区演示SDK控制器操作物理网络设备,最终播放远端高清视频流。\n- 技术栈：\nStructs2+JSP+VLC\n- 个人贡献：\n1. 完成复杂JSON的encode/decode，兼容不同版本\n2. HttpUrlConnection解决http数据分包传输\n\n### 4. NCE-Super控制器\n基于华为ServiceStage的微服务开发。总共近80个微服务，每个微服务中集成启动以及SQL变更脚本，通过封装Jekins功能实现CICD。\n- 个人贡献：\n1. 大量CodeReview及代码质量修复，大量单元测试(LLT)\n2. ForkJoinTask优化任务执行速度\n\n# 教育经历\n|学校|专业|期间|\n|---|---|---|\n|中国地质大学(武汉)|计算机技术|2012-2014|\n|湖北师范大学|信息与计算科学|2007-2011|\n\n","source":"about/index.md","raw":"---\ntitle: 关于自己\ndate: 2023-03-22 11:22:22\n---\n\n# 个人信息\n**洪宗敏**  意向: 效能研发\n<table>\n    <tr>\n        <td>34岁</td> \n        <td>男</td> \n        <td>武汉</td> \n   </tr>\n    <tr>  \n  \t\t <td>15527282430</td> \n         <td colspan=\"2\">283341330@qq.com</td> \n    </tr>\n</table>\n\n\n\n# 自我评价\n- 有9年的web开发经验、4年运维经验，熟悉阿里云诸多产品\n- 能运用python/shell等脚本语言，有H5/微信小程序/移动端项目经验\n- 熟悉Spring源码，熟练掌握Java/Spring/Mybatis/Hibernate/MySQL/Redis\n- 熟悉Springboot, 熟练运用Nacos/Kafka/SpringCache/grpc等组件\n- 理解JVM，有参数调优和线上故障定位经验\n- 熟悉MySQL/PostgreSQL/TIDB等多种数据库，熟悉SQL调优\n> [个人博客 https://hugh126.github.io](https://hugh126.github.io)\n\n# 工作经历\n### 1. 海伦司科技有限责任公司 2018.11~现在  \n\n1. 为了让研发便于稳定发版但又不接触生产服务器。从0到1研发公司自动化运维平台：  \n主要集成发版、补丁、监控、SQL审批执行等功能\n2. 公司没有运维，积累大量一线问题解决及运维经验\n3. 有实际的公众号开发、小程序开发、IOSApp开发、智能IOT设备接入等项目经验  \n> 总结: 近5年时间，帮助团队从3人扩展到30人，承担运维开发多重职责，优化系统效率保障线上稳定\n\n### 2. 软通动力技术服务有限公司 2016.05~2018.09\n1. 协同华为武汉SDN团队，完成沙箱项目开发及展示\n2. 扩展团队从2人到9人，承接独立项目；熟悉了微服务开发的流程，积累大量CI/CD以及LLT经验\n\n### 3. 广州世纪龙信息网络有限责任公司(中国电信)  2014.7~2016.04\n使用python处理分段日志，完成流量监控分析平台开发与维护；其中熟悉了Linux与日志处理\n\n\n# 项目经验\n### 1. Ayplot自动运维平台\n运维平台是参考开源项目Walle的思想，借助开源平台jeecgboot实现自己的企业运维平台。\n- 技术栈：\nAnt-design-vue + Vue2 + SpringBoot2 + MybatisPlus3 + Redis+ Druid+ Mysql\n- 个人贡献：\n0. 集成环境管理、服务器管理、项目管理和部署回滚功能\n1. 支持mvn和ant打包成war或jar的打包方式\n2. 支持了前后置任务服务切量上下线，通过自定义shell关联前端更新部署\n3. 为方便审批发布，支持钉钉移动端审批\n4. 支持各服务自定义各自启动JVM参数\n5. 集成SQL的审批操作:发布前对比测试与正式数据库结构并同步,以及临时开发申请执行的SQL\n\n### 2. 企业ERP\n企业ERP是海伦司的基础服务配置平台，包含了人事、运营、采购、营销、财务几大模块。  \n- 技术栈：    \nJSP+ EasyUI + Jeecg(SpringMVC) + Hibernate+ Redis/Hazelcast + Druid+ Tidb\n- 个人贡献：  \n1. JVM参数调优，通过arthas解决线上OOM或CPU占用过高等问题\n2. 优化审批流：事务不完整问题；数据库记录与钉钉通知不一致问题；使用策略模式解决分支问题；封装Guava的MapDiff优化审批数据对比\n3. 优化quartz定时任务：使用Reids的发布订阅完成集群任务变更；自定义group控制是否执行；通过Listener记录任务执行详情\n4. 使用SSE优化批量同步金蝶过程中的信息反馈\n5. 优化慢SQL\n\n### 3. 华为开发者社区SDN-WAN沙箱项目开发\n为开发者社区演示SDK控制器操作物理网络设备,最终播放远端高清视频流。\n- 技术栈：\nStructs2+JSP+VLC\n- 个人贡献：\n1. 完成复杂JSON的encode/decode，兼容不同版本\n2. HttpUrlConnection解决http数据分包传输\n\n### 4. NCE-Super控制器\n基于华为ServiceStage的微服务开发。总共近80个微服务，每个微服务中集成启动以及SQL变更脚本，通过封装Jekins功能实现CICD。\n- 个人贡献：\n1. 大量CodeReview及代码质量修复，大量单元测试(LLT)\n2. ForkJoinTask优化任务执行速度\n\n# 教育经历\n|学校|专业|期间|\n|---|---|---|\n|中国地质大学(武汉)|计算机技术|2012-2014|\n|湖北师范大学|信息与计算科学|2007-2011|\n\n","updated":"2023-09-13T09:23:08.755Z","path":"about/index.html","comments":1,"layout":"page","_id":"clw5r6oyj0002qwvd08xo23ij","content":"<h1 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h1><p><strong>洪宗敏</strong>  意向: 效能研发</p>\n<table>\n    <tr>\n        <td>34岁</td> \n        <td>男</td> \n        <td>武汉</td> \n   </tr>\n    <tr>  \n           <td>15527282430</td> \n         <td colspan=\"2\">283341330@qq.com</td> \n    </tr>\n</table>\n\n\n\n<h1 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h1><ul>\n<li>有9年的web开发经验、4年运维经验，熟悉阿里云诸多产品</li>\n<li>能运用python&#x2F;shell等脚本语言，有H5&#x2F;微信小程序&#x2F;移动端项目经验</li>\n<li>熟悉Spring源码，熟练掌握Java&#x2F;Spring&#x2F;Mybatis&#x2F;Hibernate&#x2F;MySQL&#x2F;Redis</li>\n<li>熟悉Springboot, 熟练运用Nacos&#x2F;Kafka&#x2F;SpringCache&#x2F;grpc等组件</li>\n<li>理解JVM，有参数调优和线上故障定位经验</li>\n<li>熟悉MySQL&#x2F;PostgreSQL&#x2F;TIDB等多种数据库，熟悉SQL调优<blockquote>\n<p><a href=\"https://hugh126.github.io/\">个人博客 https://hugh126.github.io</a></p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><h3 id=\"1-海伦司科技有限责任公司-2018-11-现在\"><a href=\"#1-海伦司科技有限责任公司-2018-11-现在\" class=\"headerlink\" title=\"1. 海伦司科技有限责任公司 2018.11~现在\"></a>1. 海伦司科技有限责任公司 2018.11~现在</h3><ol>\n<li>为了让研发便于稳定发版但又不接触生产服务器。从0到1研发公司自动化运维平台：<br>主要集成发版、补丁、监控、SQL审批执行等功能</li>\n<li>公司没有运维，积累大量一线问题解决及运维经验</li>\n<li>有实际的公众号开发、小程序开发、IOSApp开发、智能IOT设备接入等项目经验  <blockquote>\n<p>总结: 近5年时间，帮助团队从3人扩展到30人，承担运维开发多重职责，优化系统效率保障线上稳定</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"2-软通动力技术服务有限公司-2016-05-2018-09\"><a href=\"#2-软通动力技术服务有限公司-2016-05-2018-09\" class=\"headerlink\" title=\"2. 软通动力技术服务有限公司 2016.05~2018.09\"></a>2. 软通动力技术服务有限公司 2016.05~2018.09</h3><ol>\n<li>协同华为武汉SDN团队，完成沙箱项目开发及展示</li>\n<li>扩展团队从2人到9人，承接独立项目；熟悉了微服务开发的流程，积累大量CI&#x2F;CD以及LLT经验</li>\n</ol>\n<h3 id=\"3-广州世纪龙信息网络有限责任公司-中国电信-2014-7-2016-04\"><a href=\"#3-广州世纪龙信息网络有限责任公司-中国电信-2014-7-2016-04\" class=\"headerlink\" title=\"3. 广州世纪龙信息网络有限责任公司(中国电信)  2014.7~2016.04\"></a>3. 广州世纪龙信息网络有限责任公司(中国电信)  2014.7~2016.04</h3><p>使用python处理分段日志，完成流量监控分析平台开发与维护；其中熟悉了Linux与日志处理</p>\n<h1 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h1><h3 id=\"1-Ayplot自动运维平台\"><a href=\"#1-Ayplot自动运维平台\" class=\"headerlink\" title=\"1. Ayplot自动运维平台\"></a>1. Ayplot自动运维平台</h3><p>运维平台是参考开源项目Walle的思想，借助开源平台jeecgboot实现自己的企业运维平台。</p>\n<ul>\n<li>技术栈：<br>Ant-design-vue + Vue2 + SpringBoot2 + MybatisPlus3 + Redis+ Druid+ Mysql</li>\n<li>个人贡献：</li>\n</ul>\n<ol start=\"0\">\n<li>集成环境管理、服务器管理、项目管理和部署回滚功能</li>\n<li>支持mvn和ant打包成war或jar的打包方式</li>\n<li>支持了前后置任务服务切量上下线，通过自定义shell关联前端更新部署</li>\n<li>为方便审批发布，支持钉钉移动端审批</li>\n<li>支持各服务自定义各自启动JVM参数</li>\n<li>集成SQL的审批操作:发布前对比测试与正式数据库结构并同步,以及临时开发申请执行的SQL</li>\n</ol>\n<h3 id=\"2-企业ERP\"><a href=\"#2-企业ERP\" class=\"headerlink\" title=\"2. 企业ERP\"></a>2. 企业ERP</h3><p>企业ERP是海伦司的基础服务配置平台，包含了人事、运营、采购、营销、财务几大模块。  </p>\n<ul>\n<li>技术栈：<br>JSP+ EasyUI + Jeecg(SpringMVC) + Hibernate+ Redis&#x2F;Hazelcast + Druid+ Tidb</li>\n<li>个人贡献：</li>\n</ul>\n<ol>\n<li>JVM参数调优，通过arthas解决线上OOM或CPU占用过高等问题</li>\n<li>优化审批流：事务不完整问题；数据库记录与钉钉通知不一致问题；使用策略模式解决分支问题；封装Guava的MapDiff优化审批数据对比</li>\n<li>优化quartz定时任务：使用Reids的发布订阅完成集群任务变更；自定义group控制是否执行；通过Listener记录任务执行详情</li>\n<li>使用SSE优化批量同步金蝶过程中的信息反馈</li>\n<li>优化慢SQL</li>\n</ol>\n<h3 id=\"3-华为开发者社区SDN-WAN沙箱项目开发\"><a href=\"#3-华为开发者社区SDN-WAN沙箱项目开发\" class=\"headerlink\" title=\"3. 华为开发者社区SDN-WAN沙箱项目开发\"></a>3. 华为开发者社区SDN-WAN沙箱项目开发</h3><p>为开发者社区演示SDK控制器操作物理网络设备,最终播放远端高清视频流。</p>\n<ul>\n<li>技术栈：<br>Structs2+JSP+VLC</li>\n<li>个人贡献：</li>\n</ul>\n<ol>\n<li>完成复杂JSON的encode&#x2F;decode，兼容不同版本</li>\n<li>HttpUrlConnection解决http数据分包传输</li>\n</ol>\n<h3 id=\"4-NCE-Super控制器\"><a href=\"#4-NCE-Super控制器\" class=\"headerlink\" title=\"4. NCE-Super控制器\"></a>4. NCE-Super控制器</h3><p>基于华为ServiceStage的微服务开发。总共近80个微服务，每个微服务中集成启动以及SQL变更脚本，通过封装Jekins功能实现CICD。</p>\n<ul>\n<li>个人贡献：</li>\n</ul>\n<ol>\n<li>大量CodeReview及代码质量修复，大量单元测试(LLT)</li>\n<li>ForkJoinTask优化任务执行速度</li>\n</ol>\n<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><table>\n<thead>\n<tr>\n<th>学校</th>\n<th>专业</th>\n<th>期间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>中国地质大学(武汉)</td>\n<td>计算机技术</td>\n<td>2012-2014</td>\n</tr>\n<tr>\n<td>湖北师范大学</td>\n<td>信息与计算科学</td>\n<td>2007-2011</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h1><p><strong>洪宗敏</strong>  意向: 效能研发</p>\n<table>\n    <tr>\n        <td>34岁</td> \n        <td>男</td> \n        <td>武汉</td> \n   </tr>\n    <tr>  \n           <td>15527282430</td> \n         <td colspan=\"2\">283341330@qq.com</td> \n    </tr>\n</table>\n\n\n\n<h1 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h1><ul>\n<li>有9年的web开发经验、4年运维经验，熟悉阿里云诸多产品</li>\n<li>能运用python&#x2F;shell等脚本语言，有H5&#x2F;微信小程序&#x2F;移动端项目经验</li>\n<li>熟悉Spring源码，熟练掌握Java&#x2F;Spring&#x2F;Mybatis&#x2F;Hibernate&#x2F;MySQL&#x2F;Redis</li>\n<li>熟悉Springboot, 熟练运用Nacos&#x2F;Kafka&#x2F;SpringCache&#x2F;grpc等组件</li>\n<li>理解JVM，有参数调优和线上故障定位经验</li>\n<li>熟悉MySQL&#x2F;PostgreSQL&#x2F;TIDB等多种数据库，熟悉SQL调优<blockquote>\n<p><a href=\"https://hugh126.github.io/\">个人博客 https://hugh126.github.io</a></p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><h3 id=\"1-海伦司科技有限责任公司-2018-11-现在\"><a href=\"#1-海伦司科技有限责任公司-2018-11-现在\" class=\"headerlink\" title=\"1. 海伦司科技有限责任公司 2018.11~现在\"></a>1. 海伦司科技有限责任公司 2018.11~现在</h3><ol>\n<li>为了让研发便于稳定发版但又不接触生产服务器。从0到1研发公司自动化运维平台：<br>主要集成发版、补丁、监控、SQL审批执行等功能</li>\n<li>公司没有运维，积累大量一线问题解决及运维经验</li>\n<li>有实际的公众号开发、小程序开发、IOSApp开发、智能IOT设备接入等项目经验  <blockquote>\n<p>总结: 近5年时间，帮助团队从3人扩展到30人，承担运维开发多重职责，优化系统效率保障线上稳定</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"2-软通动力技术服务有限公司-2016-05-2018-09\"><a href=\"#2-软通动力技术服务有限公司-2016-05-2018-09\" class=\"headerlink\" title=\"2. 软通动力技术服务有限公司 2016.05~2018.09\"></a>2. 软通动力技术服务有限公司 2016.05~2018.09</h3><ol>\n<li>协同华为武汉SDN团队，完成沙箱项目开发及展示</li>\n<li>扩展团队从2人到9人，承接独立项目；熟悉了微服务开发的流程，积累大量CI&#x2F;CD以及LLT经验</li>\n</ol>\n<h3 id=\"3-广州世纪龙信息网络有限责任公司-中国电信-2014-7-2016-04\"><a href=\"#3-广州世纪龙信息网络有限责任公司-中国电信-2014-7-2016-04\" class=\"headerlink\" title=\"3. 广州世纪龙信息网络有限责任公司(中国电信)  2014.7~2016.04\"></a>3. 广州世纪龙信息网络有限责任公司(中国电信)  2014.7~2016.04</h3><p>使用python处理分段日志，完成流量监控分析平台开发与维护；其中熟悉了Linux与日志处理</p>\n<h1 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h1><h3 id=\"1-Ayplot自动运维平台\"><a href=\"#1-Ayplot自动运维平台\" class=\"headerlink\" title=\"1. Ayplot自动运维平台\"></a>1. Ayplot自动运维平台</h3><p>运维平台是参考开源项目Walle的思想，借助开源平台jeecgboot实现自己的企业运维平台。</p>\n<ul>\n<li>技术栈：<br>Ant-design-vue + Vue2 + SpringBoot2 + MybatisPlus3 + Redis+ Druid+ Mysql</li>\n<li>个人贡献：</li>\n</ul>\n<ol start=\"0\">\n<li>集成环境管理、服务器管理、项目管理和部署回滚功能</li>\n<li>支持mvn和ant打包成war或jar的打包方式</li>\n<li>支持了前后置任务服务切量上下线，通过自定义shell关联前端更新部署</li>\n<li>为方便审批发布，支持钉钉移动端审批</li>\n<li>支持各服务自定义各自启动JVM参数</li>\n<li>集成SQL的审批操作:发布前对比测试与正式数据库结构并同步,以及临时开发申请执行的SQL</li>\n</ol>\n<h3 id=\"2-企业ERP\"><a href=\"#2-企业ERP\" class=\"headerlink\" title=\"2. 企业ERP\"></a>2. 企业ERP</h3><p>企业ERP是海伦司的基础服务配置平台，包含了人事、运营、采购、营销、财务几大模块。  </p>\n<ul>\n<li>技术栈：<br>JSP+ EasyUI + Jeecg(SpringMVC) + Hibernate+ Redis&#x2F;Hazelcast + Druid+ Tidb</li>\n<li>个人贡献：</li>\n</ul>\n<ol>\n<li>JVM参数调优，通过arthas解决线上OOM或CPU占用过高等问题</li>\n<li>优化审批流：事务不完整问题；数据库记录与钉钉通知不一致问题；使用策略模式解决分支问题；封装Guava的MapDiff优化审批数据对比</li>\n<li>优化quartz定时任务：使用Reids的发布订阅完成集群任务变更；自定义group控制是否执行；通过Listener记录任务执行详情</li>\n<li>使用SSE优化批量同步金蝶过程中的信息反馈</li>\n<li>优化慢SQL</li>\n</ol>\n<h3 id=\"3-华为开发者社区SDN-WAN沙箱项目开发\"><a href=\"#3-华为开发者社区SDN-WAN沙箱项目开发\" class=\"headerlink\" title=\"3. 华为开发者社区SDN-WAN沙箱项目开发\"></a>3. 华为开发者社区SDN-WAN沙箱项目开发</h3><p>为开发者社区演示SDK控制器操作物理网络设备,最终播放远端高清视频流。</p>\n<ul>\n<li>技术栈：<br>Structs2+JSP+VLC</li>\n<li>个人贡献：</li>\n</ul>\n<ol>\n<li>完成复杂JSON的encode&#x2F;decode，兼容不同版本</li>\n<li>HttpUrlConnection解决http数据分包传输</li>\n</ol>\n<h3 id=\"4-NCE-Super控制器\"><a href=\"#4-NCE-Super控制器\" class=\"headerlink\" title=\"4. NCE-Super控制器\"></a>4. NCE-Super控制器</h3><p>基于华为ServiceStage的微服务开发。总共近80个微服务，每个微服务中集成启动以及SQL变更脚本，通过封装Jekins功能实现CICD。</p>\n<ul>\n<li>个人贡献：</li>\n</ul>\n<ol>\n<li>大量CodeReview及代码质量修复，大量单元测试(LLT)</li>\n<li>ForkJoinTask优化任务执行速度</li>\n</ol>\n<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><table>\n<thead>\n<tr>\n<th>学校</th>\n<th>专业</th>\n<th>期间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>中国地质大学(武汉)</td>\n<td>计算机技术</td>\n<td>2012-2014</td>\n</tr>\n<tr>\n<td>湖北师范大学</td>\n<td>信息与计算科学</td>\n<td>2007-2011</td>\n</tr>\n</tbody></table>\n"},{"title":"tags","type":"tags","date":"2023-03-22T03:22:34.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ndate: 2023-03-22 11:22:34\n---\n","updated":"2024-02-18T07:29:15.637Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clw5r6oym0006qwvd9fu98wml","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","type":"categories","date":"2023-03-22T03:22:28.000Z","_content":"根据个人偏向分类，后续有必要再调整\n<!--more-->\n- 前端\n- Spring+\n- 中间件\n- 数据库\n- 问题/经验\n- 大数据\n- 云原生","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\ndate: 2023-03-22 11:22:28\n---\n根据个人偏向分类，后续有必要再调整\n<!--more-->\n- 前端\n- Spring+\n- 中间件\n- 数据库\n- 问题/经验\n- 大数据\n- 云原生","updated":"2024-02-18T07:49:58.310Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clw5r6oyn0008qwvd8oz38v2h","content":"<p>根据个人偏向分类，后续有必要再调整</p>\n<span id=\"more\"></span>\n<ul>\n<li>前端</li>\n<li>Spring+</li>\n<li>中间件</li>\n<li>数据库</li>\n<li>问题&#x2F;经验</li>\n<li>大数据</li>\n<li>云原生</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>根据个人偏向分类，后续有必要再调整</p>","more":"<ul>\n<li>前端</li>\n<li>Spring+</li>\n<li>中间件</li>\n<li>数据库</li>\n<li>问题&#x2F;经验</li>\n<li>大数据</li>\n<li>云原生</li>\n</ul>"}],"Post":[{"title":"DDD领域驱动设计","date":"2023-06-13T02:17:38.000Z","_content":"要理解DDD(Domain-Driven Design，领域驱动设计)，首要就得明白它解决了什么问题。微服务架构解决了高可用、可扩展问题，但随之带来了性能下降，复杂度暴增的问题。DDD分别从战略（业务）和战术（应用）出发，建立领域模型和架构模式，指导微服务的设计和拆分。\n<!--more-->\n## 一、复杂度的来源及解法\n- 高性能  \n    - 内部: \n        - 多进程： 为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令\n        - 进程间通信：管道、消息队列、信号量、共享存储等\n        - 多线程：任务可以并行，但同时也带来了并发问题和锁\n        \n    - 集群：最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限\n- 高可用\n    - 计算高可用：\n    - 存储高可用：\n- 可扩展  \n- 低成本  \n- 安全 \n- 规模  \n\n\n> 复杂度来源参考：  \n[从0开始学架构-李运华](https://time.geekbang.org/column/article/6990)\n\n## 二、软件架构的演进\n微服务的划分一直是软件工程的一个争议点，到底如何拆分，拆分到怎么样的程度一直缺乏一个理论指导。  \n其实，从服务架构的演进过程可以看到，微服务中基础设施服务、同领域业务服务同样也逐渐聚合收敛了。因此，在大型架构中，类似DDD思想的融入其实早已产生。\n![](/images/DDD-软件架构演进.png)\n\n## 三、DDD四层模型\n![](/images/DDD四层模型.jpg)  \n\n> 用户界面层：网络协议的转化/统一鉴权/Session 管理/限流配置/前置缓存/异常转换  \n> 应用层：业务流程编排（仅编排，不能存在业务逻辑）/ DTO 出入转化  \n> 领域层：领域模型/领域服务/仓储和防腐层的接口定义  \n>  基础设施层：仓储和防腐层接口实现/存储等基础层能力\n  \n**简言之，更加抽象技术层次划分，更加聚合资源结构，更加强调用户体验**\n\n## 四、DDD的概念与核心思想  \n\n\n### 领域模型\n![](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJpmMBl8RNx7xT4PTlDr0Byxm894iaHgWXxiclo5bXfUwKFibJPgB59YRIq0ZfOsQvIHvrfM8aX2AyOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1) \n\n**DDD的改造，其核心是是如何划定边界，以确定技术架构**  \n\n\n### 划分边界\n1. 在领域驱动设计的战略设计中，我们采用事件风暴方法梳理业务过程中的用户操作、事件以及外部依赖关系等，从而梳理出领域实体等领域对象。\n2. 然后，我们根据领域实体之间的业务关联性，形成聚合，并确定聚合中的聚合根、值对象和实体。\n3. 接着，根据业务及语义边界等因素，将一个或多个聚合划定在一个限界上下文内，形成领域模型。这个过程中，我们建立了领域模型，划定了业务领域的边界，建立了通用语言和限界上下文，确定了领域模型中各个领域对象的关系。这些限界上下文可以作为微服务设计的参考边界，从而确定了应用端的微服务边界。\n\n\n\n\n\n\n\n","source":"_posts/DDD领域驱动设计.md","raw":"---\ntitle: DDD领域驱动设计\ndate: 2023-06-13 10:17:38\ntags:\n- DDD\ncategories: 其他\n---\n要理解DDD(Domain-Driven Design，领域驱动设计)，首要就得明白它解决了什么问题。微服务架构解决了高可用、可扩展问题，但随之带来了性能下降，复杂度暴增的问题。DDD分别从战略（业务）和战术（应用）出发，建立领域模型和架构模式，指导微服务的设计和拆分。\n<!--more-->\n## 一、复杂度的来源及解法\n- 高性能  \n    - 内部: \n        - 多进程： 为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令\n        - 进程间通信：管道、消息队列、信号量、共享存储等\n        - 多线程：任务可以并行，但同时也带来了并发问题和锁\n        \n    - 集群：最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限\n- 高可用\n    - 计算高可用：\n    - 存储高可用：\n- 可扩展  \n- 低成本  \n- 安全 \n- 规模  \n\n\n> 复杂度来源参考：  \n[从0开始学架构-李运华](https://time.geekbang.org/column/article/6990)\n\n## 二、软件架构的演进\n微服务的划分一直是软件工程的一个争议点，到底如何拆分，拆分到怎么样的程度一直缺乏一个理论指导。  \n其实，从服务架构的演进过程可以看到，微服务中基础设施服务、同领域业务服务同样也逐渐聚合收敛了。因此，在大型架构中，类似DDD思想的融入其实早已产生。\n![](/images/DDD-软件架构演进.png)\n\n## 三、DDD四层模型\n![](/images/DDD四层模型.jpg)  \n\n> 用户界面层：网络协议的转化/统一鉴权/Session 管理/限流配置/前置缓存/异常转换  \n> 应用层：业务流程编排（仅编排，不能存在业务逻辑）/ DTO 出入转化  \n> 领域层：领域模型/领域服务/仓储和防腐层的接口定义  \n>  基础设施层：仓储和防腐层接口实现/存储等基础层能力\n  \n**简言之，更加抽象技术层次划分，更加聚合资源结构，更加强调用户体验**\n\n## 四、DDD的概念与核心思想  \n\n\n### 领域模型\n![](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJpmMBl8RNx7xT4PTlDr0Byxm894iaHgWXxiclo5bXfUwKFibJPgB59YRIq0ZfOsQvIHvrfM8aX2AyOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1) \n\n**DDD的改造，其核心是是如何划定边界，以确定技术架构**  \n\n\n### 划分边界\n1. 在领域驱动设计的战略设计中，我们采用事件风暴方法梳理业务过程中的用户操作、事件以及外部依赖关系等，从而梳理出领域实体等领域对象。\n2. 然后，我们根据领域实体之间的业务关联性，形成聚合，并确定聚合中的聚合根、值对象和实体。\n3. 接着，根据业务及语义边界等因素，将一个或多个聚合划定在一个限界上下文内，形成领域模型。这个过程中，我们建立了领域模型，划定了业务领域的边界，建立了通用语言和限界上下文，确定了领域模型中各个领域对象的关系。这些限界上下文可以作为微服务设计的参考边界，从而确定了应用端的微服务边界。\n\n\n\n\n\n\n\n","slug":"DDD领域驱动设计","published":1,"updated":"2024-05-14T09:06:57.764Z","_id":"clw5r6oyh0001qwvdfuqcd0wr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>要理解DDD(Domain-Driven Design，领域驱动设计)，首要就得明白它解决了什么问题。微服务架构解决了高可用、可扩展问题，但随之带来了性能下降，复杂度暴增的问题。DDD分别从战略（业务）和战术（应用）出发，建立领域模型和架构模式，指导微服务的设计和拆分。</p>\n<span id=\"more\"></span>\n<h2 id=\"一、复杂度的来源及解法\"><a href=\"#一、复杂度的来源及解法\" class=\"headerlink\" title=\"一、复杂度的来源及解法\"></a>一、复杂度的来源及解法</h2><ul>\n<li>高性能  <ul>\n<li><p>内部: </p>\n<ul>\n<li>多进程： 为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令</li>\n<li>进程间通信：管道、消息队列、信号量、共享存储等</li>\n<li>多线程：任务可以并行，但同时也带来了并发问题和锁</li>\n</ul>\n</li>\n<li><p>集群：最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限</p>\n</li>\n</ul>\n</li>\n<li>高可用<ul>\n<li>计算高可用：</li>\n<li>存储高可用：</li>\n</ul>\n</li>\n<li>可扩展  </li>\n<li>低成本  </li>\n<li>安全 </li>\n<li>规模</li>\n</ul>\n<blockquote>\n<p>复杂度来源参考：<br><a href=\"https://time.geekbang.org/column/article/6990\">从0开始学架构-李运华</a></p>\n</blockquote>\n<h2 id=\"二、软件架构的演进\"><a href=\"#二、软件架构的演进\" class=\"headerlink\" title=\"二、软件架构的演进\"></a>二、软件架构的演进</h2><p>微服务的划分一直是软件工程的一个争议点，到底如何拆分，拆分到怎么样的程度一直缺乏一个理论指导。<br>其实，从服务架构的演进过程可以看到，微服务中基础设施服务、同领域业务服务同样也逐渐聚合收敛了。因此，在大型架构中，类似DDD思想的融入其实早已产生。<br><img src=\"/images/DDD-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.png\"></p>\n<h2 id=\"三、DDD四层模型\"><a href=\"#三、DDD四层模型\" class=\"headerlink\" title=\"三、DDD四层模型\"></a>三、DDD四层模型</h2><p><img src=\"/images/DDD%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg\">  </p>\n<blockquote>\n<p>用户界面层：网络协议的转化&#x2F;统一鉴权&#x2F;Session 管理&#x2F;限流配置&#x2F;前置缓存&#x2F;异常转换<br>应用层：业务流程编排（仅编排，不能存在业务逻辑）&#x2F; DTO 出入转化<br>领域层：领域模型&#x2F;领域服务&#x2F;仓储和防腐层的接口定义<br> 基础设施层：仓储和防腐层接口实现&#x2F;存储等基础层能力</p>\n</blockquote>\n<p><strong>简言之，更加抽象技术层次划分，更加聚合资源结构，更加强调用户体验</strong></p>\n<h2 id=\"四、DDD的概念与核心思想\"><a href=\"#四、DDD的概念与核心思想\" class=\"headerlink\" title=\"四、DDD的概念与核心思想\"></a>四、DDD的概念与核心思想</h2><h3 id=\"领域模型\"><a href=\"#领域模型\" class=\"headerlink\" title=\"领域模型\"></a>领域模型</h3><p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJpmMBl8RNx7xT4PTlDr0Byxm894iaHgWXxiclo5bXfUwKFibJPgB59YRIq0ZfOsQvIHvrfM8aX2AyOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\"> </p>\n<p><strong>DDD的改造，其核心是是如何划定边界，以确定技术架构</strong>  </p>\n<h3 id=\"划分边界\"><a href=\"#划分边界\" class=\"headerlink\" title=\"划分边界\"></a>划分边界</h3><ol>\n<li>在领域驱动设计的战略设计中，我们采用事件风暴方法梳理业务过程中的用户操作、事件以及外部依赖关系等，从而梳理出领域实体等领域对象。</li>\n<li>然后，我们根据领域实体之间的业务关联性，形成聚合，并确定聚合中的聚合根、值对象和实体。</li>\n<li>接着，根据业务及语义边界等因素，将一个或多个聚合划定在一个限界上下文内，形成领域模型。这个过程中，我们建立了领域模型，划定了业务领域的边界，建立了通用语言和限界上下文，确定了领域模型中各个领域对象的关系。这些限界上下文可以作为微服务设计的参考边界，从而确定了应用端的微服务边界。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>要理解DDD(Domain-Driven Design，领域驱动设计)，首要就得明白它解决了什么问题。微服务架构解决了高可用、可扩展问题，但随之带来了性能下降，复杂度暴增的问题。DDD分别从战略（业务）和战术（应用）出发，建立领域模型和架构模式，指导微服务的设计和拆分。</p>","more":"<h2 id=\"一、复杂度的来源及解法\"><a href=\"#一、复杂度的来源及解法\" class=\"headerlink\" title=\"一、复杂度的来源及解法\"></a>一、复杂度的来源及解法</h2><ul>\n<li>高性能  <ul>\n<li><p>内部: </p>\n<ul>\n<li>多进程： 为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令</li>\n<li>进程间通信：管道、消息队列、信号量、共享存储等</li>\n<li>多线程：任务可以并行，但同时也带来了并发问题和锁</li>\n</ul>\n</li>\n<li><p>集群：最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限</p>\n</li>\n</ul>\n</li>\n<li>高可用<ul>\n<li>计算高可用：</li>\n<li>存储高可用：</li>\n</ul>\n</li>\n<li>可扩展  </li>\n<li>低成本  </li>\n<li>安全 </li>\n<li>规模</li>\n</ul>\n<blockquote>\n<p>复杂度来源参考：<br><a href=\"https://time.geekbang.org/column/article/6990\">从0开始学架构-李运华</a></p>\n</blockquote>\n<h2 id=\"二、软件架构的演进\"><a href=\"#二、软件架构的演进\" class=\"headerlink\" title=\"二、软件架构的演进\"></a>二、软件架构的演进</h2><p>微服务的划分一直是软件工程的一个争议点，到底如何拆分，拆分到怎么样的程度一直缺乏一个理论指导。<br>其实，从服务架构的演进过程可以看到，微服务中基础设施服务、同领域业务服务同样也逐渐聚合收敛了。因此，在大型架构中，类似DDD思想的融入其实早已产生。<br><img src=\"/images/DDD-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.png\"></p>\n<h2 id=\"三、DDD四层模型\"><a href=\"#三、DDD四层模型\" class=\"headerlink\" title=\"三、DDD四层模型\"></a>三、DDD四层模型</h2><p><img src=\"/images/DDD%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg\">  </p>\n<blockquote>\n<p>用户界面层：网络协议的转化&#x2F;统一鉴权&#x2F;Session 管理&#x2F;限流配置&#x2F;前置缓存&#x2F;异常转换<br>应用层：业务流程编排（仅编排，不能存在业务逻辑）&#x2F; DTO 出入转化<br>领域层：领域模型&#x2F;领域服务&#x2F;仓储和防腐层的接口定义<br> 基础设施层：仓储和防腐层接口实现&#x2F;存储等基础层能力</p>\n</blockquote>\n<p><strong>简言之，更加抽象技术层次划分，更加聚合资源结构，更加强调用户体验</strong></p>\n<h2 id=\"四、DDD的概念与核心思想\"><a href=\"#四、DDD的概念与核心思想\" class=\"headerlink\" title=\"四、DDD的概念与核心思想\"></a>四、DDD的概念与核心思想</h2><h3 id=\"领域模型\"><a href=\"#领域模型\" class=\"headerlink\" title=\"领域模型\"></a>领域模型</h3><p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJpmMBl8RNx7xT4PTlDr0Byxm894iaHgWXxiclo5bXfUwKFibJPgB59YRIq0ZfOsQvIHvrfM8aX2AyOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\"> </p>\n<p><strong>DDD的改造，其核心是是如何划定边界，以确定技术架构</strong>  </p>\n<h3 id=\"划分边界\"><a href=\"#划分边界\" class=\"headerlink\" title=\"划分边界\"></a>划分边界</h3><ol>\n<li>在领域驱动设计的战略设计中，我们采用事件风暴方法梳理业务过程中的用户操作、事件以及外部依赖关系等，从而梳理出领域实体等领域对象。</li>\n<li>然后，我们根据领域实体之间的业务关联性，形成聚合，并确定聚合中的聚合根、值对象和实体。</li>\n<li>接着，根据业务及语义边界等因素，将一个或多个聚合划定在一个限界上下文内，形成领域模型。这个过程中，我们建立了领域模型，划定了业务领域的边界，建立了通用语言和限界上下文，确定了领域模型中各个领域对象的关系。这些限界上下文可以作为微服务设计的参考边界，从而确定了应用端的微服务边界。</li>\n</ol>"},{"title":"Flink","date":"2023-12-26T06:24:16.000Z","_content":"\n","source":"_posts/Flink.md","raw":"---\ntitle: Flink\ndate: 2023-12-26 14:24:16\ntags: \n- Flink\n- 大数据\ncategories: 大数据\n---\n\n","slug":"Flink","published":1,"updated":"2024-02-18T08:20:31.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyk0003qwvd0g5c2b5x","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"CompletableFuture","date":"2024-04-28T11:19:02.000Z","_content":"你是否曾经为了追求任务更高性能而使用多线程，又是否因为多线程任务组合搞得代码散乱。那么一个适合任务编排的神奇来了\n<!--more-->\n# 一，使用方法\n\n方法太多，层次不同，但有规律可寻。\n\n\n## 1. 开始异步调用\n\n> runAsync / supplyAsync\n\n* runAsync 无返回值\n* supplyAsync 有返回值\n\n```java\n    @Test\n    void test0() throws ExecutionException, InterruptedException {\n        CompletableFuture.runAsync(() -> {\n           log.info(\"异步task1\");\n        });\n\n        CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {\n            String name = \"异步task2\";\n            log.info(name);\n            return name;\n        });\n  \n        log.info(cf2.get());\n    }\n\n11:29:09.352 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - 异步task1\n11:29:09.352 [ForkJoinPool.commonPool-worker-2] INFO java8.CompletableFutureTest - 异步task2\n```\n\n类似的都有一个参数类型为 Executor 的同名方法，其实就是指定执行的线程池。默认的是 ForkJoinPool\n\n```java\n    /**\n     * Default executor -- ForkJoinPool.commonPool() unless it cannot\n     * support parallelism.\n     */\n    private static final Executor asyncPool = useCommonPool ?\n        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\n```\n\n\n## 2.强大的管道\n\n> thenRun / thenApply / thenAccept\n\n* thenRun          <Runnable> 无参无输出\n* thenApply      <Function>    入参并返回\n* thenAccept     <Consumer>  入参无返回\n\n```java\n    @Test\n    void test1() {\n        CompletableFuture<Void> completableFuture = new CompletableFuture();\n        completableFuture.thenRun(() -> {\n            log.info(\"task 1\");\n        }).supplyAsync(() -> {\n            log.info(\"task 2\");\n            return \"task2\";\n        }).thenApply((param) -> {\n            String result = String.format(\"[apply param = %s]\", param);\n            log.info(result);\n            return result;\n        }).thenAccept((consumeData) -> {\n            log.info(\"[accept = {}]\", consumeData);\n        });\n        completableFuture.complete(null);\n    }\n\n\n11:39:19.631 [main] INFO java8.CompletableFutureTest - task 1\n11:39:19.631 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - task 2\n11:39:19.635 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - [apply param = task2]\n11:39:19.635 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - [accept = [apply param = task2]]\n```\n\n同样的，对应的方法有 支持异步的， 和 支持自定义执行线程池的\n\n> 注意：默认情况下，使用的是ForkJoinPool.commonPool\n\n\n## 3.CompletableFuture组合\n\n> thenCompose / thenCombine / allOf / anyOf\n\nthenCompose      将链式 CompletableFuture 调用拍平，避免了嵌套 get\n\nthenCombine       两个 CompletableFuture 完成后组合调用\n\nCompletableFuture<Void> allOf (CompletableFuture<?>... cfs)        多个 CompletableFuture 组合，所有任务完成，异常返回\n\n> 不会反映过程结果，典型用例为\n>\n> CompletableFuture.allOf(c1, c2, c3).join();\n\nCompletableFuture<Object> anyOf (CompletableFuture<?>... cfs)   多个 CompletableFuture 组合，任意 1 个任务完成，异常返回\n\n```java\n    CompletableFuture<String> foo1(String id) {\n        return CompletableFuture.supplyAsync(() -> \"id = \" + id );\n    }\n\n    CompletableFuture<String> foo2(String idKey) {\n        return CompletableFuture.supplyAsync(() -> String.format(\"desc = [%s]\", idKey));\n    }\n\n    @Test\n    void test3() throws ExecutionException, InterruptedException {\n        CompletableFuture<String> f1 = foo1(\"001\");\n        CompletableFuture<CompletableFuture<String>> f2 = f1.thenApplyAsync((key) -> {\n            return foo2(key);\n        });\n        log.warn(\"end = \" + f2.get().get());\n        log.info(\"end2 = \" + f1.thenCompose((key) -> foo2(key)).get());\n    }\n\n\n15:19:18.838 [main] WARN java8.CompletableFutureTest - end = desc = [id = 001]\n15:19:18.842 [main] INFO java8.CompletableFutureTest - end2 = desc = [id = 001]\n\n\n    @Test\n    void test4() throws ExecutionException, InterruptedException {\n        System.out.println(foo1(\"foo1\").thenCombine(foo2(\"foo2\"), (a, b) -> a + \"__\" + b).get());\n    }\n\nid = foo1__desc = [foo2]\n\n```\n\n## 4.异常处理\n\n> exceptionly / handle / whenComplete\n\n获取结果（异常处理）\n\n借用一个总结：\n\n|                     | handle | whenComplete | exceptionly   |\n| --------------------- | -------- | -------------- | --------------- |\n| 访问成功            | Yes    | Yes          | No            |\n| 访问失败            | Yes    | Yes          | Yes           |\n| 能从失败中恢复      | Yes    | No           | Yes           |\n| 能转换结果从 T 到 U | Yes    | No           | No            |\n| 成功时触发          | Yes    | Yes          | No            |\n| 失败时触发          | Yes    | Yes          | Yes           |\n| 有异步版本          | Yes    | Yes          | Yes (12 版本) |\n\n可以看出，handle 各种情况都支持的很好。一般用它就是了\n\n```java\n    @Test\n    void test5() throws ExecutionException, InterruptedException {\n        CompletableFuture<Integer> cf = CompletableFuture.supplyAsync(() -> {\n            log.info(\"--supplyAsync1--\");\n            return null;\n        }).thenApply((p) -> {\n            log.info(\"--thenApply2--\");\n            Assert.notNull(p, \"参数不允许为空\");\n            return Integer.valueOf(2);\n        }).handle( (res, ex) -> {\n            if(ex != null) {\n                log.error(ex.getMessage());\n            }else {\n                log.info(\"--success--\");\n            }\n            return res;\n        });\n        log.warn(\"end \" + cf.get());\n    }\n\n15:55:29.020 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - --supplyAsync1--\n15:55:29.024 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - --thenApply2--\n15:55:29.026 [ForkJoinPool.commonPool-worker-9] ERROR java8.CompletableFutureTest - java.lang.IllegalArgumentException: 参数不允许为空\n15:55:29.026 [main] WARN java8.CompletableFutureTest - end null\n```\n\n> 注意：\n>\n> handle 中不允许抛出异常；参数为 BiFunction，有返回值\n>\n> whenComplete 在 get 的时候，如果有异常会继续抛出异常；参数为 BiConsumer，无返回值\n\n\n## 5.结果获取\n\n* get / join\n\n两者都是 获取结果的，只是 join 更偏向于 Future 组合，其异常会被封装。\n\n* complate\n\n主动计算，如果未完成，则会 Set 传入的值。\n\n```java\n    @Test\n    void test6() throws ExecutionException, InterruptedException {\n        CompletableFuture<String> cf = CompletableFuture.runAsync(() -> {\n            log.info(\"--111--\");\n        }).supplyAsync(() -> {\n            log.info(\"--222--\");\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            log.info(\"--333---\");\n            return \"333\";\n        });\n        log.info(String.valueOf(cf.complete(\"123\")));\n        log.warn(\"end = \" + cf.get());\n    }\n\n16:23:43.479 [main] INFO java8.CompletableFutureTest - true\n16:23:43.479 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - --111--\n16:23:43.484 [main] WARN java8.CompletableFutureTest - end = 123\n```\n\n# 二，示例\n\n## 2.1 多任务并行，正确或异常\n\n多任务并发执行，获取正确或错误结果\n\n```java\n    @Test\n    void multiTaskRunAndReturn() {\n        //记录开始时间\n        Long start = System.currentTimeMillis();\n        //任务\n        final List<Integer> taskList = Arrays.asList(1, 2, 3, 4, 5);\n        List<String> resultList = new ArrayList<>();\n        Map<String, String> errorList = new HashMap<>();\n        log.warn(\"start\");\n        Stream<CompletableFuture<String>> completableFutureStream = taskList.stream()\n                .map(num -> {\n                            return CompletableFuture\n                                    .supplyAsync(() -> doubleInteger(num))\n                                    .handle((res, th) -> {\n                                        if (th == null) {\n                                            log.info(\"任务\" + num + \"完成! result=\" + res + \", \" + LocalTime.now().toString());\n                                            resultList.add(res.toString());\n                                        } else {\n                                            log.error(\"任务\" + num + \"异常! e=\" + th + \", \" +  LocalTime.now().toString());\n                                            errorList.put(num.toString(), th.getMessage());\n                                        }\n                                        return \"\";\n                                    });\n                        }\n                );\n        CompletableFuture[] completableFutures = completableFutureStream.toArray(CompletableFuture[]::new);\n        CompletableFuture.allOf(completableFutures)\n                .whenComplete((v, th) -> {\n                    log.warn(\"所有任务执行完成触发\\n resultList=\" + resultList + \"\\n errorList=\" + errorList+ \"\\n耗时=\" + (System.currentTimeMillis() - start));\n                }).join();\n        log.warn(\"end\");\n\n    }\n\n\n    //根据数字判断线程休眠的时间\n    public static Integer doubleInteger(Integer i) {\n        try {\n            log.warn(\"任务\" + i + \" 开始 ...\");\n            TimeUnit.SECONDS.sleep(i);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        if (i ==3) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return 2 * i;\n    }\n```\n\n\n## 2.2 任务组，组内并行，组外依赖\n\n两组任务可分组执行，但任务组2依赖任务组1结果。 实现方式很多，但是要实现优雅，易扩展可不容易：\n\n```java\n\n/**\n * 将两队任务组合\n *\n * task1组完成后，再完成task2，组装成1个 CompletableFuture\n */\n@Slf4j\npublic class CompletableFutureTest2 {\n\n    List<String> task1ResultList = new ArrayList<>();\n\n    CompletableFuture<String> runTask1(String name) {\n        return CompletableFuture.supplyAsync(() -> {\n            log.info(\"taskName={}\",name);\n            return name + \"_Result_\" + Thread.currentThread().getId();\n        }).handle((res, e) -> {\n            // 不侵入任务本身 收集结果\n            if (e == null) {\n                task1ResultList.add(res);\n            }else {\n                task1ResultList.add(e.getMessage());\n            }\n            return res;\n        });\n    }\n\n    CompletableFuture<String> runTask2(CompletableFuture preTask, String name) {\n        return preTask.thenRunAsync(() -> {\n            log.info(\"taskName={}\",name);\n            // 利用task1的结果 process\n            log.warn(\"preResult=\" + task1ResultList.stream().collect(Collectors.joining(\",\")));\n        });\n    }\n\n    @Test\n    void test3() {\n        // 1\n        List<CompletableFuture> list1 = new ArrayList<>();\n        for (int i=0; i<3; i++) {\n            CompletableFuture cf1 = runTask1(\"task1\");\n            list1.add(cf1);\n        }\n        CompletableFuture[] arr1 = list1.toArray(new CompletableFuture[list1.size()]);\n        CompletableFuture<Void> f11 = CompletableFuture.allOf(arr1);\n\n\n        // 2\n        List<CompletableFuture> list2 = new ArrayList<>();\n        for(int i=0;i<7;i++) {\n            CompletableFuture cf2 = runTask2( f11 , \"task2\");\n            list1.add(cf2);\n        }\n        CompletableFuture[] arr2 = list1.toArray(new CompletableFuture[list2.size()]);\n        CompletableFuture.allOf(arr2).join();\n    }\n\n\n}\n\n```\n\n\n## 2.3 泡茶\n\n设想现在有个任务：泡茶。需要步骤大概可以分为烧水和准备茶具、茶叶，最终泡茶。\n\n在这个任务重，烧水、准备茶具茶叶是分开的两个支线，他们是无无关联，可以并行的。示意如下：\n\n1. 任务支线1  洗水壶 --\\> 烧开水\n2. 任务支线2  洗茶壶 --\\> 洗茶杯 --\\> 取茶叶\n3. 任务汇总   泡茶\n\n使用`CompletableFuture` 可以实现如下：\n\n```java\n\n/**\n * 任务支线1  洗水壶 --> 烧开水\n * 任务支线2  洗茶壶 --> 洗茶杯 --> 取茶叶\n * 任务汇总   泡茶\n */\n@Slf4j\npublic class TeaMakingExample {\n\n    public static void randomSleep() {\n        try {\n            TimeUnit.SECONDS.sleep(new Random().nextInt(5));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    final static List<String> resList = new ArrayList<>();\n\n    static CompletableFuture buildSupplier(Supplier<String> function) {\n        return CompletableFuture.supplyAsync(function).handle((res, ex) -> {\n            resList.add(res);\n            return res;\n        });\n    }\n\n    public static void main(String[] args) {\n\n        CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n            log.info(\"任务11：洗水壶\");\n            randomSleep();\n            return \"干净的水壶\";\n        }).thenApplyAsync( x -> {\n            log.info(\"任务12：烧开水\");\n//            log.info(\"参数=\" + x);\n            randomSleep();\n            return \"开水\";\n        }).handle((res, ex) -> {\n            resList.add(res);\n            return res;\n        });\n\n        CompletableFuture<String> task21 = buildSupplier(() -> {\n            log.info(\"任务21: 洗茶壶\");\n            randomSleep();\n            return \"干净的茶壶\";\n        });\n\n        CompletableFuture<String> task22 = buildSupplier(() -> {\n            log.info(\"任务22: 洗茶杯\");\n            randomSleep();\n            return \"干净的茶杯\";\n        });\n\n        CompletableFuture<String> task23 = buildSupplier(() -> {\n            log.info(\"任务23: 取茶叶\");\n            randomSleep();\n            return \"干净的茶叶\";\n        });\n\n        // 组装任务\n        CompletableFuture<Void> allTasks = CompletableFuture.allOf(task1, task21, task22, task23).thenRunAsync( () -> {\n            log.warn(\"---所有材料准备齐全---\");\n            log.warn(\"[{}]\", resList.stream().collect(Collectors.joining(\",\")));\n            log.warn(\"===最终步骤：：泡茶===\");\n        });\n\n        // 阻塞直到所有 CompletableFuture 完成\n        allTasks.join();\n\n    }\n}\n```\n","source":"_posts/CompletableFuture.md","raw":"---\ntitle: CompletableFuture\ndate: 2024-04-28 19:19:02\ntags:\n- java\ncategories: Spring+\n---\n你是否曾经为了追求任务更高性能而使用多线程，又是否因为多线程任务组合搞得代码散乱。那么一个适合任务编排的神奇来了\n<!--more-->\n# 一，使用方法\n\n方法太多，层次不同，但有规律可寻。\n\n\n## 1. 开始异步调用\n\n> runAsync / supplyAsync\n\n* runAsync 无返回值\n* supplyAsync 有返回值\n\n```java\n    @Test\n    void test0() throws ExecutionException, InterruptedException {\n        CompletableFuture.runAsync(() -> {\n           log.info(\"异步task1\");\n        });\n\n        CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {\n            String name = \"异步task2\";\n            log.info(name);\n            return name;\n        });\n  \n        log.info(cf2.get());\n    }\n\n11:29:09.352 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - 异步task1\n11:29:09.352 [ForkJoinPool.commonPool-worker-2] INFO java8.CompletableFutureTest - 异步task2\n```\n\n类似的都有一个参数类型为 Executor 的同名方法，其实就是指定执行的线程池。默认的是 ForkJoinPool\n\n```java\n    /**\n     * Default executor -- ForkJoinPool.commonPool() unless it cannot\n     * support parallelism.\n     */\n    private static final Executor asyncPool = useCommonPool ?\n        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\n```\n\n\n## 2.强大的管道\n\n> thenRun / thenApply / thenAccept\n\n* thenRun          <Runnable> 无参无输出\n* thenApply      <Function>    入参并返回\n* thenAccept     <Consumer>  入参无返回\n\n```java\n    @Test\n    void test1() {\n        CompletableFuture<Void> completableFuture = new CompletableFuture();\n        completableFuture.thenRun(() -> {\n            log.info(\"task 1\");\n        }).supplyAsync(() -> {\n            log.info(\"task 2\");\n            return \"task2\";\n        }).thenApply((param) -> {\n            String result = String.format(\"[apply param = %s]\", param);\n            log.info(result);\n            return result;\n        }).thenAccept((consumeData) -> {\n            log.info(\"[accept = {}]\", consumeData);\n        });\n        completableFuture.complete(null);\n    }\n\n\n11:39:19.631 [main] INFO java8.CompletableFutureTest - task 1\n11:39:19.631 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - task 2\n11:39:19.635 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - [apply param = task2]\n11:39:19.635 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - [accept = [apply param = task2]]\n```\n\n同样的，对应的方法有 支持异步的， 和 支持自定义执行线程池的\n\n> 注意：默认情况下，使用的是ForkJoinPool.commonPool\n\n\n## 3.CompletableFuture组合\n\n> thenCompose / thenCombine / allOf / anyOf\n\nthenCompose      将链式 CompletableFuture 调用拍平，避免了嵌套 get\n\nthenCombine       两个 CompletableFuture 完成后组合调用\n\nCompletableFuture<Void> allOf (CompletableFuture<?>... cfs)        多个 CompletableFuture 组合，所有任务完成，异常返回\n\n> 不会反映过程结果，典型用例为\n>\n> CompletableFuture.allOf(c1, c2, c3).join();\n\nCompletableFuture<Object> anyOf (CompletableFuture<?>... cfs)   多个 CompletableFuture 组合，任意 1 个任务完成，异常返回\n\n```java\n    CompletableFuture<String> foo1(String id) {\n        return CompletableFuture.supplyAsync(() -> \"id = \" + id );\n    }\n\n    CompletableFuture<String> foo2(String idKey) {\n        return CompletableFuture.supplyAsync(() -> String.format(\"desc = [%s]\", idKey));\n    }\n\n    @Test\n    void test3() throws ExecutionException, InterruptedException {\n        CompletableFuture<String> f1 = foo1(\"001\");\n        CompletableFuture<CompletableFuture<String>> f2 = f1.thenApplyAsync((key) -> {\n            return foo2(key);\n        });\n        log.warn(\"end = \" + f2.get().get());\n        log.info(\"end2 = \" + f1.thenCompose((key) -> foo2(key)).get());\n    }\n\n\n15:19:18.838 [main] WARN java8.CompletableFutureTest - end = desc = [id = 001]\n15:19:18.842 [main] INFO java8.CompletableFutureTest - end2 = desc = [id = 001]\n\n\n    @Test\n    void test4() throws ExecutionException, InterruptedException {\n        System.out.println(foo1(\"foo1\").thenCombine(foo2(\"foo2\"), (a, b) -> a + \"__\" + b).get());\n    }\n\nid = foo1__desc = [foo2]\n\n```\n\n## 4.异常处理\n\n> exceptionly / handle / whenComplete\n\n获取结果（异常处理）\n\n借用一个总结：\n\n|                     | handle | whenComplete | exceptionly   |\n| --------------------- | -------- | -------------- | --------------- |\n| 访问成功            | Yes    | Yes          | No            |\n| 访问失败            | Yes    | Yes          | Yes           |\n| 能从失败中恢复      | Yes    | No           | Yes           |\n| 能转换结果从 T 到 U | Yes    | No           | No            |\n| 成功时触发          | Yes    | Yes          | No            |\n| 失败时触发          | Yes    | Yes          | Yes           |\n| 有异步版本          | Yes    | Yes          | Yes (12 版本) |\n\n可以看出，handle 各种情况都支持的很好。一般用它就是了\n\n```java\n    @Test\n    void test5() throws ExecutionException, InterruptedException {\n        CompletableFuture<Integer> cf = CompletableFuture.supplyAsync(() -> {\n            log.info(\"--supplyAsync1--\");\n            return null;\n        }).thenApply((p) -> {\n            log.info(\"--thenApply2--\");\n            Assert.notNull(p, \"参数不允许为空\");\n            return Integer.valueOf(2);\n        }).handle( (res, ex) -> {\n            if(ex != null) {\n                log.error(ex.getMessage());\n            }else {\n                log.info(\"--success--\");\n            }\n            return res;\n        });\n        log.warn(\"end \" + cf.get());\n    }\n\n15:55:29.020 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - --supplyAsync1--\n15:55:29.024 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - --thenApply2--\n15:55:29.026 [ForkJoinPool.commonPool-worker-9] ERROR java8.CompletableFutureTest - java.lang.IllegalArgumentException: 参数不允许为空\n15:55:29.026 [main] WARN java8.CompletableFutureTest - end null\n```\n\n> 注意：\n>\n> handle 中不允许抛出异常；参数为 BiFunction，有返回值\n>\n> whenComplete 在 get 的时候，如果有异常会继续抛出异常；参数为 BiConsumer，无返回值\n\n\n## 5.结果获取\n\n* get / join\n\n两者都是 获取结果的，只是 join 更偏向于 Future 组合，其异常会被封装。\n\n* complate\n\n主动计算，如果未完成，则会 Set 传入的值。\n\n```java\n    @Test\n    void test6() throws ExecutionException, InterruptedException {\n        CompletableFuture<String> cf = CompletableFuture.runAsync(() -> {\n            log.info(\"--111--\");\n        }).supplyAsync(() -> {\n            log.info(\"--222--\");\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            log.info(\"--333---\");\n            return \"333\";\n        });\n        log.info(String.valueOf(cf.complete(\"123\")));\n        log.warn(\"end = \" + cf.get());\n    }\n\n16:23:43.479 [main] INFO java8.CompletableFutureTest - true\n16:23:43.479 [ForkJoinPool.commonPool-worker-9] INFO java8.CompletableFutureTest - --111--\n16:23:43.484 [main] WARN java8.CompletableFutureTest - end = 123\n```\n\n# 二，示例\n\n## 2.1 多任务并行，正确或异常\n\n多任务并发执行，获取正确或错误结果\n\n```java\n    @Test\n    void multiTaskRunAndReturn() {\n        //记录开始时间\n        Long start = System.currentTimeMillis();\n        //任务\n        final List<Integer> taskList = Arrays.asList(1, 2, 3, 4, 5);\n        List<String> resultList = new ArrayList<>();\n        Map<String, String> errorList = new HashMap<>();\n        log.warn(\"start\");\n        Stream<CompletableFuture<String>> completableFutureStream = taskList.stream()\n                .map(num -> {\n                            return CompletableFuture\n                                    .supplyAsync(() -> doubleInteger(num))\n                                    .handle((res, th) -> {\n                                        if (th == null) {\n                                            log.info(\"任务\" + num + \"完成! result=\" + res + \", \" + LocalTime.now().toString());\n                                            resultList.add(res.toString());\n                                        } else {\n                                            log.error(\"任务\" + num + \"异常! e=\" + th + \", \" +  LocalTime.now().toString());\n                                            errorList.put(num.toString(), th.getMessage());\n                                        }\n                                        return \"\";\n                                    });\n                        }\n                );\n        CompletableFuture[] completableFutures = completableFutureStream.toArray(CompletableFuture[]::new);\n        CompletableFuture.allOf(completableFutures)\n                .whenComplete((v, th) -> {\n                    log.warn(\"所有任务执行完成触发\\n resultList=\" + resultList + \"\\n errorList=\" + errorList+ \"\\n耗时=\" + (System.currentTimeMillis() - start));\n                }).join();\n        log.warn(\"end\");\n\n    }\n\n\n    //根据数字判断线程休眠的时间\n    public static Integer doubleInteger(Integer i) {\n        try {\n            log.warn(\"任务\" + i + \" 开始 ...\");\n            TimeUnit.SECONDS.sleep(i);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        if (i ==3) {\n            throw new IllegalArgumentException(\"\");\n        }\n        return 2 * i;\n    }\n```\n\n\n## 2.2 任务组，组内并行，组外依赖\n\n两组任务可分组执行，但任务组2依赖任务组1结果。 实现方式很多，但是要实现优雅，易扩展可不容易：\n\n```java\n\n/**\n * 将两队任务组合\n *\n * task1组完成后，再完成task2，组装成1个 CompletableFuture\n */\n@Slf4j\npublic class CompletableFutureTest2 {\n\n    List<String> task1ResultList = new ArrayList<>();\n\n    CompletableFuture<String> runTask1(String name) {\n        return CompletableFuture.supplyAsync(() -> {\n            log.info(\"taskName={}\",name);\n            return name + \"_Result_\" + Thread.currentThread().getId();\n        }).handle((res, e) -> {\n            // 不侵入任务本身 收集结果\n            if (e == null) {\n                task1ResultList.add(res);\n            }else {\n                task1ResultList.add(e.getMessage());\n            }\n            return res;\n        });\n    }\n\n    CompletableFuture<String> runTask2(CompletableFuture preTask, String name) {\n        return preTask.thenRunAsync(() -> {\n            log.info(\"taskName={}\",name);\n            // 利用task1的结果 process\n            log.warn(\"preResult=\" + task1ResultList.stream().collect(Collectors.joining(\",\")));\n        });\n    }\n\n    @Test\n    void test3() {\n        // 1\n        List<CompletableFuture> list1 = new ArrayList<>();\n        for (int i=0; i<3; i++) {\n            CompletableFuture cf1 = runTask1(\"task1\");\n            list1.add(cf1);\n        }\n        CompletableFuture[] arr1 = list1.toArray(new CompletableFuture[list1.size()]);\n        CompletableFuture<Void> f11 = CompletableFuture.allOf(arr1);\n\n\n        // 2\n        List<CompletableFuture> list2 = new ArrayList<>();\n        for(int i=0;i<7;i++) {\n            CompletableFuture cf2 = runTask2( f11 , \"task2\");\n            list1.add(cf2);\n        }\n        CompletableFuture[] arr2 = list1.toArray(new CompletableFuture[list2.size()]);\n        CompletableFuture.allOf(arr2).join();\n    }\n\n\n}\n\n```\n\n\n## 2.3 泡茶\n\n设想现在有个任务：泡茶。需要步骤大概可以分为烧水和准备茶具、茶叶，最终泡茶。\n\n在这个任务重，烧水、准备茶具茶叶是分开的两个支线，他们是无无关联，可以并行的。示意如下：\n\n1. 任务支线1  洗水壶 --\\> 烧开水\n2. 任务支线2  洗茶壶 --\\> 洗茶杯 --\\> 取茶叶\n3. 任务汇总   泡茶\n\n使用`CompletableFuture` 可以实现如下：\n\n```java\n\n/**\n * 任务支线1  洗水壶 --> 烧开水\n * 任务支线2  洗茶壶 --> 洗茶杯 --> 取茶叶\n * 任务汇总   泡茶\n */\n@Slf4j\npublic class TeaMakingExample {\n\n    public static void randomSleep() {\n        try {\n            TimeUnit.SECONDS.sleep(new Random().nextInt(5));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    final static List<String> resList = new ArrayList<>();\n\n    static CompletableFuture buildSupplier(Supplier<String> function) {\n        return CompletableFuture.supplyAsync(function).handle((res, ex) -> {\n            resList.add(res);\n            return res;\n        });\n    }\n\n    public static void main(String[] args) {\n\n        CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {\n            log.info(\"任务11：洗水壶\");\n            randomSleep();\n            return \"干净的水壶\";\n        }).thenApplyAsync( x -> {\n            log.info(\"任务12：烧开水\");\n//            log.info(\"参数=\" + x);\n            randomSleep();\n            return \"开水\";\n        }).handle((res, ex) -> {\n            resList.add(res);\n            return res;\n        });\n\n        CompletableFuture<String> task21 = buildSupplier(() -> {\n            log.info(\"任务21: 洗茶壶\");\n            randomSleep();\n            return \"干净的茶壶\";\n        });\n\n        CompletableFuture<String> task22 = buildSupplier(() -> {\n            log.info(\"任务22: 洗茶杯\");\n            randomSleep();\n            return \"干净的茶杯\";\n        });\n\n        CompletableFuture<String> task23 = buildSupplier(() -> {\n            log.info(\"任务23: 取茶叶\");\n            randomSleep();\n            return \"干净的茶叶\";\n        });\n\n        // 组装任务\n        CompletableFuture<Void> allTasks = CompletableFuture.allOf(task1, task21, task22, task23).thenRunAsync( () -> {\n            log.warn(\"---所有材料准备齐全---\");\n            log.warn(\"[{}]\", resList.stream().collect(Collectors.joining(\",\")));\n            log.warn(\"===最终步骤：：泡茶===\");\n        });\n\n        // 阻塞直到所有 CompletableFuture 完成\n        allTasks.join();\n\n    }\n}\n```\n","slug":"CompletableFuture","published":1,"updated":"2024-04-28T11:26:18.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oym0007qwvd38is4nfg","content":"<p>你是否曾经为了追求任务更高性能而使用多线程，又是否因为多线程任务组合搞得代码散乱。那么一个适合任务编排的神奇来了</p>\n<span id=\"more\"></span>\n<h1 id=\"一，使用方法\"><a href=\"#一，使用方法\" class=\"headerlink\" title=\"一，使用方法\"></a>一，使用方法</h1><p>方法太多，层次不同，但有规律可寻。</p>\n<h2 id=\"1-开始异步调用\"><a href=\"#1-开始异步调用\" class=\"headerlink\" title=\"1. 开始异步调用\"></a>1. 开始异步调用</h2><blockquote>\n<p>runAsync &#x2F; supplyAsync</p>\n</blockquote>\n<ul>\n<li>runAsync 无返回值</li>\n<li>supplyAsync 有返回值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test0</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">           log.info(<span class=\"string\">&quot;异步task1&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            String name = <span class=\"string\">&quot;异步task2&quot;</span>;</span><br><span class=\"line\">            log.info(name);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">        log.info(cf2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">29</span>:<span class=\"number\">09.352</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - 异步task1</span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">29</span>:<span class=\"number\">09.352</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">2</span>] INFO java8.CompletableFutureTest - 异步task2</span><br></pre></td></tr></table></figure>\n\n<p>类似的都有一个参数类型为 Executor 的同名方法，其实就是指定执行的线程池。默认的是 ForkJoinPool</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Default executor -- ForkJoinPool.commonPool() unless it cannot</span></span><br><span class=\"line\"><span class=\"comment\"> * support parallelism.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor asyncPool = useCommonPool ?</span><br><span class=\"line\">    ForkJoinPool.commonPool() : <span class=\"keyword\">new</span> ThreadPerTaskExecutor();</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-强大的管道\"><a href=\"#2-强大的管道\" class=\"headerlink\" title=\"2.强大的管道\"></a>2.强大的管道</h2><blockquote>\n<p>thenRun &#x2F; thenApply &#x2F; thenAccept</p>\n</blockquote>\n<ul>\n<li>thenRun          <Runnable> 无参无输出</Runnable></li>\n<li>thenApply      <Function>    入参并返回</Function></li>\n<li>thenAccept     <Consumer>  入参无返回</Consumer></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; completableFuture = <span class=\"keyword\">new</span> CompletableFuture();</span><br><span class=\"line\">        completableFuture.thenRun(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;task 1&quot;</span>);</span><br><span class=\"line\">        &#125;).supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;task 2&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;task2&quot;</span>;</span><br><span class=\"line\">        &#125;).thenApply((param) -&gt; &#123;</span><br><span class=\"line\">            String result = String.format(<span class=\"string\">&quot;[apply param = %s]&quot;</span>, param);</span><br><span class=\"line\">            log.info(result);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;).thenAccept((consumeData) -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;[accept = &#123;&#125;]&quot;</span>, consumeData);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        completableFuture.complete(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.631</span> [main] INFO java8.CompletableFutureTest - task <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.631</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - task <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.635</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - [apply param = task2]</span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.635</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - [accept = [apply param = task2]]</span><br></pre></td></tr></table></figure>\n\n<p>同样的，对应的方法有 支持异步的， 和 支持自定义执行线程池的</p>\n<blockquote>\n<p>注意：默认情况下，使用的是ForkJoinPool.commonPool</p>\n</blockquote>\n<h2 id=\"3-CompletableFuture组合\"><a href=\"#3-CompletableFuture组合\" class=\"headerlink\" title=\"3.CompletableFuture组合\"></a>3.CompletableFuture组合</h2><blockquote>\n<p>thenCompose &#x2F; thenCombine &#x2F; allOf &#x2F; anyOf</p>\n</blockquote>\n<p>thenCompose      将链式 CompletableFuture 调用拍平，避免了嵌套 get</p>\n<p>thenCombine       两个 CompletableFuture 完成后组合调用</p>\n<p>CompletableFuture<Void> allOf (CompletableFuture&lt;?&gt;… cfs)        多个 CompletableFuture 组合，所有任务完成，异常返回</Void></p>\n<blockquote>\n<p>不会反映过程结果，典型用例为</p>\n<p>CompletableFuture.allOf(c1, c2, c3).join();</p>\n</blockquote>\n<p>CompletableFuture<Object> anyOf (CompletableFuture&lt;?&gt;… cfs)   多个 CompletableFuture 组合，任意 1 个任务完成，异常返回</Object></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">foo1</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"string\">&quot;id = &quot;</span> + id );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">foo2</span><span class=\"params\">(String idKey)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; String.format(<span class=\"string\">&quot;desc = [%s]&quot;</span>, idKey));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;String&gt; f1 = foo1(<span class=\"string\">&quot;001&quot;</span>);</span><br><span class=\"line\">        CompletableFuture&lt;CompletableFuture&lt;String&gt;&gt; f2 = f1.thenApplyAsync((key) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> foo2(key);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end = &quot;</span> + f2.get().get());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;end2 = &quot;</span> + f1.thenCompose((key) -&gt; foo2(key)).get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">19</span>:<span class=\"number\">18.838</span> [main] WARN java8.CompletableFutureTest - end = desc = [id = <span class=\"number\">001</span>]</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">19</span>:<span class=\"number\">18.842</span> [main] INFO java8.CompletableFutureTest - end2 = desc = [id = <span class=\"number\">001</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        System.out.println(foo1(<span class=\"string\">&quot;foo1&quot;</span>).thenCombine(foo2(<span class=\"string\">&quot;foo2&quot;</span>), (a, b) -&gt; a + <span class=\"string\">&quot;__&quot;</span> + b).get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id = foo1__desc = [foo2]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-异常处理\"><a href=\"#4-异常处理\" class=\"headerlink\" title=\"4.异常处理\"></a>4.异常处理</h2><blockquote>\n<p>exceptionly &#x2F; handle &#x2F; whenComplete</p>\n</blockquote>\n<p>获取结果（异常处理）</p>\n<p>借用一个总结：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>handle</th>\n<th>whenComplete</th>\n<th>exceptionly</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>访问成功</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>访问失败</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>能从失败中恢复</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>能转换结果从 T 到 U</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>成功时触发</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>失败时触发</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>有异步版本</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes (12 版本)</td>\n</tr>\n</tbody></table>\n<p>可以看出，handle 各种情况都支持的很好。一般用它就是了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test5</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--supplyAsync1--&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;).thenApply((p) -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--thenApply2--&quot;</span>);</span><br><span class=\"line\">            Assert.notNull(p, <span class=\"string\">&quot;参数不允许为空&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Integer.valueOf(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;).handle( (res, ex) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ex != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                log.error(ex.getMessage());</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;--success--&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end &quot;</span> + cf.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.020</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - --supplyAsync1--</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.024</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - --thenApply2--</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.026</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] ERROR java8.CompletableFutureTest - java.lang.IllegalArgumentException: 参数不允许为空</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.026</span> [main] WARN java8.CompletableFutureTest - end <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<p>handle 中不允许抛出异常；参数为 BiFunction，有返回值</p>\n<p>whenComplete 在 get 的时候，如果有异常会继续抛出异常；参数为 BiConsumer，无返回值</p>\n</blockquote>\n<h2 id=\"5-结果获取\"><a href=\"#5-结果获取\" class=\"headerlink\" title=\"5.结果获取\"></a>5.结果获取</h2><ul>\n<li>get &#x2F; join</li>\n</ul>\n<p>两者都是 获取结果的，只是 join 更偏向于 Future 组合，其异常会被封装。</p>\n<ul>\n<li>complate</li>\n</ul>\n<p>主动计算，如果未完成，则会 Set 传入的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test6</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;String&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--111--&quot;</span>);</span><br><span class=\"line\">        &#125;).supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--222--&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--333---&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;333&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        log.info(String.valueOf(cf.complete(<span class=\"string\">&quot;123&quot;</span>)));</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end = &quot;</span> + cf.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">23</span>:<span class=\"number\">43.479</span> [main] INFO java8.CompletableFutureTest - <span class=\"keyword\">true</span></span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">23</span>:<span class=\"number\">43.479</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - --<span class=\"number\">111</span>--</span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">23</span>:<span class=\"number\">43.484</span> [main] WARN java8.CompletableFutureTest - end = <span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二，示例\"><a href=\"#二，示例\" class=\"headerlink\" title=\"二，示例\"></a>二，示例</h1><h2 id=\"2-1-多任务并行，正确或异常\"><a href=\"#2-1-多任务并行，正确或异常\" class=\"headerlink\" title=\"2.1 多任务并行，正确或异常\"></a>2.1 多任务并行，正确或异常</h2><p>多任务并发执行，获取正确或错误结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">multiTaskRunAndReturn</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//记录开始时间</span></span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//任务</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;Integer&gt; taskList = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    List&lt;String&gt; resultList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Map&lt;String, String&gt; errorList = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    log.warn(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">    Stream&lt;CompletableFuture&lt;String&gt;&gt; completableFutureStream = taskList.stream()</span><br><span class=\"line\">            .map(num -&gt; &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> CompletableFuture</span><br><span class=\"line\">                                .supplyAsync(() -&gt; doubleInteger(num))</span><br><span class=\"line\">                                .handle((res, th) -&gt; &#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (th == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                        log.info(<span class=\"string\">&quot;任务&quot;</span> + num + <span class=\"string\">&quot;完成! result=&quot;</span> + res + <span class=\"string\">&quot;, &quot;</span> + LocalTime.now().toString());</span><br><span class=\"line\">                                        resultList.add(res.toString());</span><br><span class=\"line\">                                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        log.error(<span class=\"string\">&quot;任务&quot;</span> + num + <span class=\"string\">&quot;异常! e=&quot;</span> + th + <span class=\"string\">&quot;, &quot;</span> +  LocalTime.now().toString());</span><br><span class=\"line\">                                        errorList.put(num.toString(), th.getMessage());</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">                                &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            );</span><br><span class=\"line\">    CompletableFuture[] completableFutures = completableFutureStream.toArray(CompletableFuture[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    CompletableFuture.allOf(completableFutures)</span><br><span class=\"line\">            .whenComplete((v, th) -&gt; &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;所有任务执行完成触发\\n resultList=&quot;</span> + resultList + <span class=\"string\">&quot;\\n errorList=&quot;</span> + errorList+ <span class=\"string\">&quot;\\n耗时=&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class=\"line\">            &#125;).join();</span><br><span class=\"line\">    log.warn(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据数字判断线程休眠的时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">doubleInteger</span><span class=\"params\">(Integer i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;任务&quot;</span> + i + <span class=\"string\">&quot; 开始 ...&quot;</span>);</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(i);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i ==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-2-任务组，组内并行，组外依赖\"><a href=\"#2-2-任务组，组内并行，组外依赖\" class=\"headerlink\" title=\"2.2 任务组，组内并行，组外依赖\"></a>2.2 任务组，组内并行，组外依赖</h2><p>两组任务可分组执行，但任务组2依赖任务组1结果。 实现方式很多，但是要实现优雅，易扩展可不容易：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将两队任务组合</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * task1组完成后，再完成task2，组装成1个 CompletableFuture</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompletableFutureTest2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;String&gt; task1ResultList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">runTask1</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;taskName=&#123;&#125;&quot;</span>,name);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> name + <span class=\"string\">&quot;_Result_&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\">        &#125;).handle((res, e) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不侵入任务本身 收集结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                task1ResultList.add(res);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                task1ResultList.add(e.getMessage());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">runTask2</span><span class=\"params\">(CompletableFuture preTask, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> preTask.thenRunAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;taskName=&#123;&#125;&quot;</span>,name);</span><br><span class=\"line\">            <span class=\"comment\">// 利用task1的结果 process</span></span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;preResult=&quot;</span> + task1ResultList.stream().collect(Collectors.joining(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1</span></span><br><span class=\"line\">        List&lt;CompletableFuture&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            CompletableFuture cf1 = runTask1(<span class=\"string\">&quot;task1&quot;</span>);</span><br><span class=\"line\">            list1.add(cf1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        CompletableFuture[] arr1 = list1.toArray(<span class=\"keyword\">new</span> CompletableFuture[list1.size()]);</span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; f11 = CompletableFuture.allOf(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2</span></span><br><span class=\"line\">        List&lt;CompletableFuture&gt; list2 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">7</span>;i++) &#123;</span><br><span class=\"line\">            CompletableFuture cf2 = runTask2( f11 , <span class=\"string\">&quot;task2&quot;</span>);</span><br><span class=\"line\">            list1.add(cf2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        CompletableFuture[] arr2 = list1.toArray(<span class=\"keyword\">new</span> CompletableFuture[list2.size()]);</span><br><span class=\"line\">        CompletableFuture.allOf(arr2).join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-3-泡茶\"><a href=\"#2-3-泡茶\" class=\"headerlink\" title=\"2.3 泡茶\"></a>2.3 泡茶</h2><p>设想现在有个任务：泡茶。需要步骤大概可以分为烧水和准备茶具、茶叶，最终泡茶。</p>\n<p>在这个任务重，烧水、准备茶具茶叶是分开的两个支线，他们是无无关联，可以并行的。示意如下：</p>\n<ol>\n<li>任务支线1  洗水壶 –&gt; 烧开水</li>\n<li>任务支线2  洗茶壶 –&gt; 洗茶杯 –&gt; 取茶叶</li>\n<li>任务汇总   泡茶</li>\n</ol>\n<p>使用<code>CompletableFuture</code> 可以实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务支线1  洗水壶 --&gt; 烧开水</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务支线2  洗茶壶 --&gt; 洗茶杯 --&gt; 取茶叶</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务汇总   泡茶</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeaMakingExample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">randomSleep</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">5</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> List&lt;String&gt; resList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> CompletableFuture <span class=\"title\">buildSupplier</span><span class=\"params\">(Supplier&lt;String&gt; function)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(function).handle((res, ex) -&gt; &#123;</span><br><span class=\"line\">            resList.add(res);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务11：洗水壶&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的水壶&quot;</span>;</span><br><span class=\"line\">        &#125;).thenApplyAsync( x -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务12：烧开水&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//            log.info(&quot;参数=&quot; + x);</span></span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;开水&quot;</span>;</span><br><span class=\"line\">        &#125;).handle((res, ex) -&gt; &#123;</span><br><span class=\"line\">            resList.add(res);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task21 = buildSupplier(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务21: 洗茶壶&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的茶壶&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task22 = buildSupplier(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务22: 洗茶杯&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的茶杯&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task23 = buildSupplier(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务23: 取茶叶&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的茶叶&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 组装任务</span></span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; allTasks = CompletableFuture.allOf(task1, task21, task22, task23).thenRunAsync( () -&gt; &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;---所有材料准备齐全---&quot;</span>);</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;[&#123;&#125;]&quot;</span>, resList.stream().collect(Collectors.joining(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;===最终步骤：：泡茶===&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 阻塞直到所有 CompletableFuture 完成</span></span><br><span class=\"line\">        allTasks.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>你是否曾经为了追求任务更高性能而使用多线程，又是否因为多线程任务组合搞得代码散乱。那么一个适合任务编排的神奇来了</p>","more":"<h1 id=\"一，使用方法\"><a href=\"#一，使用方法\" class=\"headerlink\" title=\"一，使用方法\"></a>一，使用方法</h1><p>方法太多，层次不同，但有规律可寻。</p>\n<h2 id=\"1-开始异步调用\"><a href=\"#1-开始异步调用\" class=\"headerlink\" title=\"1. 开始异步调用\"></a>1. 开始异步调用</h2><blockquote>\n<p>runAsync &#x2F; supplyAsync</p>\n</blockquote>\n<ul>\n<li>runAsync 无返回值</li>\n<li>supplyAsync 有返回值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test0</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">           log.info(<span class=\"string\">&quot;异步task1&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            String name = <span class=\"string\">&quot;异步task2&quot;</span>;</span><br><span class=\"line\">            log.info(name);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">        log.info(cf2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">29</span>:<span class=\"number\">09.352</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - 异步task1</span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">29</span>:<span class=\"number\">09.352</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">2</span>] INFO java8.CompletableFutureTest - 异步task2</span><br></pre></td></tr></table></figure>\n\n<p>类似的都有一个参数类型为 Executor 的同名方法，其实就是指定执行的线程池。默认的是 ForkJoinPool</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Default executor -- ForkJoinPool.commonPool() unless it cannot</span></span><br><span class=\"line\"><span class=\"comment\"> * support parallelism.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor asyncPool = useCommonPool ?</span><br><span class=\"line\">    ForkJoinPool.commonPool() : <span class=\"keyword\">new</span> ThreadPerTaskExecutor();</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-强大的管道\"><a href=\"#2-强大的管道\" class=\"headerlink\" title=\"2.强大的管道\"></a>2.强大的管道</h2><blockquote>\n<p>thenRun &#x2F; thenApply &#x2F; thenAccept</p>\n</blockquote>\n<ul>\n<li>thenRun          <Runnable> 无参无输出</Runnable></li>\n<li>thenApply      <Function>    入参并返回</Function></li>\n<li>thenAccept     <Consumer>  入参无返回</Consumer></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; completableFuture = <span class=\"keyword\">new</span> CompletableFuture();</span><br><span class=\"line\">        completableFuture.thenRun(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;task 1&quot;</span>);</span><br><span class=\"line\">        &#125;).supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;task 2&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;task2&quot;</span>;</span><br><span class=\"line\">        &#125;).thenApply((param) -&gt; &#123;</span><br><span class=\"line\">            String result = String.format(<span class=\"string\">&quot;[apply param = %s]&quot;</span>, param);</span><br><span class=\"line\">            log.info(result);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;).thenAccept((consumeData) -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;[accept = &#123;&#125;]&quot;</span>, consumeData);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        completableFuture.complete(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.631</span> [main] INFO java8.CompletableFutureTest - task <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.631</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - task <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.635</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - [apply param = task2]</span><br><span class=\"line\"><span class=\"number\">11</span>:<span class=\"number\">39</span>:<span class=\"number\">19.635</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - [accept = [apply param = task2]]</span><br></pre></td></tr></table></figure>\n\n<p>同样的，对应的方法有 支持异步的， 和 支持自定义执行线程池的</p>\n<blockquote>\n<p>注意：默认情况下，使用的是ForkJoinPool.commonPool</p>\n</blockquote>\n<h2 id=\"3-CompletableFuture组合\"><a href=\"#3-CompletableFuture组合\" class=\"headerlink\" title=\"3.CompletableFuture组合\"></a>3.CompletableFuture组合</h2><blockquote>\n<p>thenCompose &#x2F; thenCombine &#x2F; allOf &#x2F; anyOf</p>\n</blockquote>\n<p>thenCompose      将链式 CompletableFuture 调用拍平，避免了嵌套 get</p>\n<p>thenCombine       两个 CompletableFuture 完成后组合调用</p>\n<p>CompletableFuture<Void> allOf (CompletableFuture&lt;?&gt;… cfs)        多个 CompletableFuture 组合，所有任务完成，异常返回</Void></p>\n<blockquote>\n<p>不会反映过程结果，典型用例为</p>\n<p>CompletableFuture.allOf(c1, c2, c3).join();</p>\n</blockquote>\n<p>CompletableFuture<Object> anyOf (CompletableFuture&lt;?&gt;… cfs)   多个 CompletableFuture 组合，任意 1 个任务完成，异常返回</Object></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">foo1</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"string\">&quot;id = &quot;</span> + id );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">foo2</span><span class=\"params\">(String idKey)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; String.format(<span class=\"string\">&quot;desc = [%s]&quot;</span>, idKey));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;String&gt; f1 = foo1(<span class=\"string\">&quot;001&quot;</span>);</span><br><span class=\"line\">        CompletableFuture&lt;CompletableFuture&lt;String&gt;&gt; f2 = f1.thenApplyAsync((key) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> foo2(key);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end = &quot;</span> + f2.get().get());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;end2 = &quot;</span> + f1.thenCompose((key) -&gt; foo2(key)).get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">19</span>:<span class=\"number\">18.838</span> [main] WARN java8.CompletableFutureTest - end = desc = [id = <span class=\"number\">001</span>]</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">19</span>:<span class=\"number\">18.842</span> [main] INFO java8.CompletableFutureTest - end2 = desc = [id = <span class=\"number\">001</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        System.out.println(foo1(<span class=\"string\">&quot;foo1&quot;</span>).thenCombine(foo2(<span class=\"string\">&quot;foo2&quot;</span>), (a, b) -&gt; a + <span class=\"string\">&quot;__&quot;</span> + b).get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id = foo1__desc = [foo2]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-异常处理\"><a href=\"#4-异常处理\" class=\"headerlink\" title=\"4.异常处理\"></a>4.异常处理</h2><blockquote>\n<p>exceptionly &#x2F; handle &#x2F; whenComplete</p>\n</blockquote>\n<p>获取结果（异常处理）</p>\n<p>借用一个总结：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>handle</th>\n<th>whenComplete</th>\n<th>exceptionly</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>访问成功</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>访问失败</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>能从失败中恢复</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>能转换结果从 T 到 U</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>成功时触发</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>失败时触发</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>有异步版本</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes (12 版本)</td>\n</tr>\n</tbody></table>\n<p>可以看出，handle 各种情况都支持的很好。一般用它就是了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test5</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--supplyAsync1--&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;).thenApply((p) -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--thenApply2--&quot;</span>);</span><br><span class=\"line\">            Assert.notNull(p, <span class=\"string\">&quot;参数不允许为空&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Integer.valueOf(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;).handle( (res, ex) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ex != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                log.error(ex.getMessage());</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;--success--&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end &quot;</span> + cf.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.020</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - --supplyAsync1--</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.024</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - --thenApply2--</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.026</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] ERROR java8.CompletableFutureTest - java.lang.IllegalArgumentException: 参数不允许为空</span><br><span class=\"line\"><span class=\"number\">15</span>:<span class=\"number\">55</span>:<span class=\"number\">29.026</span> [main] WARN java8.CompletableFutureTest - end <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<p>handle 中不允许抛出异常；参数为 BiFunction，有返回值</p>\n<p>whenComplete 在 get 的时候，如果有异常会继续抛出异常；参数为 BiConsumer，无返回值</p>\n</blockquote>\n<h2 id=\"5-结果获取\"><a href=\"#5-结果获取\" class=\"headerlink\" title=\"5.结果获取\"></a>5.结果获取</h2><ul>\n<li>get &#x2F; join</li>\n</ul>\n<p>两者都是 获取结果的，只是 join 更偏向于 Future 组合，其异常会被封装。</p>\n<ul>\n<li>complate</li>\n</ul>\n<p>主动计算，如果未完成，则会 Set 传入的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test6</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;String&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--111--&quot;</span>);</span><br><span class=\"line\">        &#125;).supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--222--&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;--333---&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;333&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        log.info(String.valueOf(cf.complete(<span class=\"string\">&quot;123&quot;</span>)));</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end = &quot;</span> + cf.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">23</span>:<span class=\"number\">43.479</span> [main] INFO java8.CompletableFutureTest - <span class=\"keyword\">true</span></span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">23</span>:<span class=\"number\">43.479</span> [ForkJoinPool.commonPool-worker-<span class=\"number\">9</span>] INFO java8.CompletableFutureTest - --<span class=\"number\">111</span>--</span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">23</span>:<span class=\"number\">43.484</span> [main] WARN java8.CompletableFutureTest - end = <span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二，示例\"><a href=\"#二，示例\" class=\"headerlink\" title=\"二，示例\"></a>二，示例</h1><h2 id=\"2-1-多任务并行，正确或异常\"><a href=\"#2-1-多任务并行，正确或异常\" class=\"headerlink\" title=\"2.1 多任务并行，正确或异常\"></a>2.1 多任务并行，正确或异常</h2><p>多任务并发执行，获取正确或错误结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">multiTaskRunAndReturn</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//记录开始时间</span></span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//任务</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;Integer&gt; taskList = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    List&lt;String&gt; resultList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Map&lt;String, String&gt; errorList = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    log.warn(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">    Stream&lt;CompletableFuture&lt;String&gt;&gt; completableFutureStream = taskList.stream()</span><br><span class=\"line\">            .map(num -&gt; &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> CompletableFuture</span><br><span class=\"line\">                                .supplyAsync(() -&gt; doubleInteger(num))</span><br><span class=\"line\">                                .handle((res, th) -&gt; &#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (th == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                        log.info(<span class=\"string\">&quot;任务&quot;</span> + num + <span class=\"string\">&quot;完成! result=&quot;</span> + res + <span class=\"string\">&quot;, &quot;</span> + LocalTime.now().toString());</span><br><span class=\"line\">                                        resultList.add(res.toString());</span><br><span class=\"line\">                                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        log.error(<span class=\"string\">&quot;任务&quot;</span> + num + <span class=\"string\">&quot;异常! e=&quot;</span> + th + <span class=\"string\">&quot;, &quot;</span> +  LocalTime.now().toString());</span><br><span class=\"line\">                                        errorList.put(num.toString(), th.getMessage());</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">                                &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            );</span><br><span class=\"line\">    CompletableFuture[] completableFutures = completableFutureStream.toArray(CompletableFuture[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    CompletableFuture.allOf(completableFutures)</span><br><span class=\"line\">            .whenComplete((v, th) -&gt; &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;所有任务执行完成触发\\n resultList=&quot;</span> + resultList + <span class=\"string\">&quot;\\n errorList=&quot;</span> + errorList+ <span class=\"string\">&quot;\\n耗时=&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class=\"line\">            &#125;).join();</span><br><span class=\"line\">    log.warn(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据数字判断线程休眠的时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">doubleInteger</span><span class=\"params\">(Integer i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;任务&quot;</span> + i + <span class=\"string\">&quot; 开始 ...&quot;</span>);</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(i);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i ==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-2-任务组，组内并行，组外依赖\"><a href=\"#2-2-任务组，组内并行，组外依赖\" class=\"headerlink\" title=\"2.2 任务组，组内并行，组外依赖\"></a>2.2 任务组，组内并行，组外依赖</h2><p>两组任务可分组执行，但任务组2依赖任务组1结果。 实现方式很多，但是要实现优雅，易扩展可不容易：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将两队任务组合</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * task1组完成后，再完成task2，组装成1个 CompletableFuture</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompletableFutureTest2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;String&gt; task1ResultList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">runTask1</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;taskName=&#123;&#125;&quot;</span>,name);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> name + <span class=\"string\">&quot;_Result_&quot;</span> + Thread.currentThread().getId();</span><br><span class=\"line\">        &#125;).handle((res, e) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不侵入任务本身 收集结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                task1ResultList.add(res);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                task1ResultList.add(e.getMessage());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CompletableFuture&lt;String&gt; <span class=\"title\">runTask2</span><span class=\"params\">(CompletableFuture preTask, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> preTask.thenRunAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;taskName=&#123;&#125;&quot;</span>,name);</span><br><span class=\"line\">            <span class=\"comment\">// 利用task1的结果 process</span></span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;preResult=&quot;</span> + task1ResultList.stream().collect(Collectors.joining(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1</span></span><br><span class=\"line\">        List&lt;CompletableFuture&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            CompletableFuture cf1 = runTask1(<span class=\"string\">&quot;task1&quot;</span>);</span><br><span class=\"line\">            list1.add(cf1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        CompletableFuture[] arr1 = list1.toArray(<span class=\"keyword\">new</span> CompletableFuture[list1.size()]);</span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; f11 = CompletableFuture.allOf(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2</span></span><br><span class=\"line\">        List&lt;CompletableFuture&gt; list2 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">7</span>;i++) &#123;</span><br><span class=\"line\">            CompletableFuture cf2 = runTask2( f11 , <span class=\"string\">&quot;task2&quot;</span>);</span><br><span class=\"line\">            list1.add(cf2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        CompletableFuture[] arr2 = list1.toArray(<span class=\"keyword\">new</span> CompletableFuture[list2.size()]);</span><br><span class=\"line\">        CompletableFuture.allOf(arr2).join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-3-泡茶\"><a href=\"#2-3-泡茶\" class=\"headerlink\" title=\"2.3 泡茶\"></a>2.3 泡茶</h2><p>设想现在有个任务：泡茶。需要步骤大概可以分为烧水和准备茶具、茶叶，最终泡茶。</p>\n<p>在这个任务重，烧水、准备茶具茶叶是分开的两个支线，他们是无无关联，可以并行的。示意如下：</p>\n<ol>\n<li>任务支线1  洗水壶 –&gt; 烧开水</li>\n<li>任务支线2  洗茶壶 –&gt; 洗茶杯 –&gt; 取茶叶</li>\n<li>任务汇总   泡茶</li>\n</ol>\n<p>使用<code>CompletableFuture</code> 可以实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务支线1  洗水壶 --&gt; 烧开水</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务支线2  洗茶壶 --&gt; 洗茶杯 --&gt; 取茶叶</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务汇总   泡茶</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeaMakingExample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">randomSleep</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">5</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> List&lt;String&gt; resList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> CompletableFuture <span class=\"title\">buildSupplier</span><span class=\"params\">(Supplier&lt;String&gt; function)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.supplyAsync(function).handle((res, ex) -&gt; &#123;</span><br><span class=\"line\">            resList.add(res);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务11：洗水壶&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的水壶&quot;</span>;</span><br><span class=\"line\">        &#125;).thenApplyAsync( x -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务12：烧开水&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//            log.info(&quot;参数=&quot; + x);</span></span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;开水&quot;</span>;</span><br><span class=\"line\">        &#125;).handle((res, ex) -&gt; &#123;</span><br><span class=\"line\">            resList.add(res);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task21 = buildSupplier(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务21: 洗茶壶&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的茶壶&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task22 = buildSupplier(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务22: 洗茶杯&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的茶杯&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; task23 = buildSupplier(() -&gt; &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;任务23: 取茶叶&quot;</span>);</span><br><span class=\"line\">            randomSleep();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;干净的茶叶&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 组装任务</span></span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; allTasks = CompletableFuture.allOf(task1, task21, task22, task23).thenRunAsync( () -&gt; &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;---所有材料准备齐全---&quot;</span>);</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;[&#123;&#125;]&quot;</span>, resList.stream().collect(Collectors.joining(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;===最终步骤：：泡茶===&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 阻塞直到所有 CompletableFuture 完成</span></span><br><span class=\"line\">        allTasks.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"G1收集器","date":"2023-05-23T07:19:44.000Z","_content":"在JDK9之后JVM默认使用G1(Garbage-First, 垃圾优先)收集器进行垃圾回收。G1是一款分代的 (generational)，增量的 (incremental)，并行的 (parallel)，移动式（evacuating）的，软实时的垃圾回收器。其最大特点是用Region代替传统分代模型，分代成为逻辑上的概念；建立了可预测的停顿时间模型，让暂停时间可配置。从实践结果来看，它能及时有效的回收大对象，增加吞吐量，避免内存碎片，保障程序的长久运行。\n<!-- more -->\n\n\n## 一、内存模型对比\n传统的垃圾收集器（串行、并行、CMS）都将堆结构分为三个部分：年轻代、老年代和固定内存大小的永久代\n- 传统收集器内存结构\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png)\n\nG1中的堆被划分为N个Region，每个region内内存连续，其中一部分被分配为传统的角色(eden、survivor、old)，但它们不是固定的位置和大小，这给内存分配提供了极大的灵活性。\n- G1内存结构\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png)\n\n\n## 二、GC步骤\nG1中有两种回收模式：\n- 年轻代垃圾回收（Young GC）\n- 混合垃圾回收（Mixed GC）\n\n### 2.1 年轻代GC\n年轻代GC是只选择年轻代区域（Eden/Survivor）进入回收集合（Collection Set，简称CSet）进行回收的模式。年轻代GC的过程和其他的分代回收器差不多，新创建的对象分配至Eden区域，然后将标记存活的对象移动至Survivor区，达到晋升年龄的就晋升到老年代区域，然后清空原区域（不过这里可没有年轻代复制算法中两个Survivor的交换过程）。\n\n1. G1在遵循GC暂停时间的基础上，选择最大年轻代Region数(CSSet)\n2. 根扫描(Root Scanning)\n3. RememberedSet扫描(RememberedSet简称RSet,会记录跨代引用的关系)\n4. 移动，遍历上面的标记栈，将栈内的所有所有的对象移动(复制)至Survivor区域\n\n年轻代GC图示：\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png)\n\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png)\n\n### 2.2 混合GC\n\n混合GC会选择所有年轻代区域(Eden/Survivor,最大年轻代分区数)和部分老年代区域进去回收集合进行回收的模式。年轻代区域对象移动到Survivor区，老年代区域移动到老年代区域。\n\n1. 初始标记  \n    > 这个是捎带在年轻代GC完成的\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png)\n2. 并发标记\n    > 并发标记的目的是标记存活对象，为移动过程做准备。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png)\n3. 再次标记\n    > 由于应用程序持续进行,需要修正上一次的标记结果。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)。此时，所有区域的活性都被计算出来了。\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png)\n\n4. 复制清理阶段\n    > G1 选择“活跃度”最低的区域，即可以收集最快的区域。然后与年轻的GC同时收集这些区域\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png)\n\n5. 最终清理阶段\n    > 所选择的区域都被复制，然后压缩\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png)  \n\n**混合GC总结**\n|阶段|是否STW|描述|\n|---|---|---|\n|初始标记|是|捎带在年轻代GC完成|\n|根区域扫描|否|扫描幸存者区域以查找对老年代的引用|\n|并行标记|否|查找整个堆上的活动对象|\n|再次标记|是|遗漏的再标记一次|\n|清理|是|对活动对象和完全自由区域执行记帐;擦洗RSet;重置空区域并将其返回到可用列表|\n|复制|是|疏散或复制活动对象到未使用区域|\n\n## 三、GC日志\n\nG1 GC的垃圾回收过程主要包括如下三个环节：  \n年轻代GC (Young GC)、老年代并发标记过程 (Concurrent Marking)、混合回收(Mixed GC)。并发标记是全局的，和回收过程是两个阶段。\n\n### 年轻代GC日志\n``` log\n//[GC pause (G1 Evacuation Pause) (young) 代表完全年轻代回收\n// 0.0182341 secs 是本次GC的暂停时间\n0.184: [GC pause (G1 Evacuation Pause) (young), 0.0182341 secs 是本次GC的暂停时间]\n// 并行GC线程，一共有8个\n   [Parallel Time: 16.7 ms, GC Workers: 8]\n      /*这一行信息说明的是这8个线程开始的时间，Min表示最早开始的线程时间，Avg表示平均开始时间，Max表示的是最晚开始时间，Diff为最早和最晚的时间差。这个值越大说明线程启动时间越不均衡。线程启动的时间依赖于GC进入安全点的情况。关于安全点可以参考后文的介绍。*/\n      [GC Worker Start (ms):  184.2  184.2  184.2  184.3  184.3  184.4  186.1  186.1\n       Min: 184.2, Avg: 184.7, Max: 186.1, Diff: 1.9]\n      /*根处理的时间，这个时间包含了所有强根的时间，分为Java根，分别为Thread、JNI、CLDG；和JVM根下面的StringTable、Universe、JNI Handles、ObjectSynchronizer、FlatProfiler、Management、SystemDictionary、JVMTI */\n      [Ext Root Scanning (ms):  0.3  0.2  0.2  0.1  0.1  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.3, Sum: 0.8]\n         /*Java线程处理时间，主要是线程栈。这个时间包含了根直接引用对象的复制时间，如果根超级大，这个时间可能会增加 */\n         [Thread Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n         [StringTable Roots (ms):  0.0  0.1  0.1  0.1  0.1  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]\n         [Universe Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [JNI Handles Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [ObjectSynchronizer Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [FlatProfiler Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Management Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [SystemDictionary Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [CLDG Roots (ms):  0.3  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.3, Diff: 0.3, Sum: 0.3]\n         [JVMTI Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n       // CodeCache Roots实际上是在处理Rset的时候的统计值，它包含下面的\n       // UpdateRS，ScanRS和Code Root Scanning\n         [CodeCache Roots (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2\n          Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.6]\n         [CM RefProcessor Roots (ms):  0.0\n         0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Wait For Strong CLD (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Weak CLD Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [SATB Filtering (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n       // 这个就是GC线程更新RSet的时间花费，注意这里的时间和我们在Refine里面处理RSet\n       // 的时间没有关系，因为它们是不同的线程处理\n       [Update RS (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2\n        Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.5]\n          // 这里就是GC线程处理的白区中的dcq个数\n         [Processed Buffers:  8  8  7  8  8  7  2  4\n          Min: 2, Avg: 6.5, Max: 8, Diff: 6, Sum: 52]\n      // 扫描RSet找到被引用的对象\n      [Scan RS (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n      [Code Root Scanning (ms):  0.0  0.0  0.0  0.0  0.0  0.1  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]\n      // 这个就是所有活着的对象（除了强根直接引用的对象，在Java根处理时会直接复制）复制\n      // 到新的分区花费的时间。从这里也可以看出复制基本上是最花费时间的操作。        \n      [Object Copy (ms):  11.3  12.5  14.2  13.1  14.3  14.2  14.2  12.5\n       Min: 11.3, Avg: 13.3, Max: 14.3, Diff: 3.0, Sum: 106.3]\n      // GC线程结束的时间信息。\n      [Termination (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts:  1  1  1  1  1  1  1  1\n          Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8]\n      // 这个是并行处理时其他处理所花费的时间，通常是由于JVM析构释放资源等\n      [GC Worker Other (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n      // 并行GC花费的总体时间\n      [GC Worker Total (ms):  16.6  16.6  16.6  16.5  16.5  16.4  14.7  14.7\n       Min: 14.7, Avg: 16.1, Max: 16.6, Diff: 1.9, Sum: 128.7]\n      // GC线程结束的时间信息\n      [GC Worker End (ms):  200.8  200.8  200.8  200.8  200.8  200.8  200.8  200.8\n       Min: 200.8, Avg: 200.8, Max: 200.8, Diff: 0.0]\n    // 下面是其他任务部分。\n    // 代码扫描属于并行执行部分，包含了代码的调整和回收时间\n    [Code Root Fixup: 0.0 ms]   \n    [Code Root Purge: 0.0 ms]\n    // 清除卡表的时间\n    [Clear CT: 0.1 ms]\n    [Other: 1.5 ms]\n      // 选择CSet的时间，YGC通常是0\n      [Choose CSet: 0.0 ms]\n      // 引用处理的时间，这个时间是发现哪些引用对象可以清除，这个是可以并行处理的\n      [Ref Proc: 1.1 ms]\n      // 引用重新激活\n      [Ref Enq: 0.2 ms]\n      // 重构RSet花费的时间\n      [Redirty Cards: 0.1 ms]\n         [Parallel Redirty:  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n         [Redirtied Cards:  8118  7583  6892  4496  0  0  0  0\n          Min: 0, Avg: 3386.1, Max: 8118, Diff: 8118, Sum: 27089]\n          // 这个信息是是可以并行处理的，这里是线程重构RSet的数目\n       // 大对象处理时间\n      [Humongous Register: 0.0 ms]\n         [Humongous Total: 2]\n          // 这里说明有2个大对象\n         [Humongous Candidate: 0]\n          // 可回收的大对象0个\n      // 如果有大对象要回收，回收花费的时间，回收的个数\n      [Humongous Reclaim: 0.0 ms]\n         [Humongous Reclaimed: 0]\n      // 释放CSet中的分区花费的时间，有新生代的信息和老生代的信息。\n      [Free CSet: 0.0 ms]\n         [Young Free CSet: 0.0 ms]\n         [Non-Young Free CSet: 0.0 ms]\n    // GC结束后Eden从15M变成0，下一次使用的空间为21M，S从2M变成3M，整个堆从\n    // 23.7M变成20M\n    [Eden: 15.0M(15.0M)->0.0B(21.0M) Survivors: 2048.0K->3072.0K \n     Heap: 23.7M(256.0M)->20.0M(256.0M)]\n```\n\n### 并发标记日志\n``` log\n//并发标记 - 初始标记阶段，在年轻代GC中完成\n100.070: [GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0751469 secs]\n  [Parallel Time: 74.7 ms, GC Workers: 8]\n    [GC Worker Start (ms): Min: 100070.4, Avg: 100070.5, Max: 100070.6, Diff: \n      0.1]\n    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.2, Max: 0.3, Diff: 0.2, Sum: \n      1.6]\n    [Update RS (ms): Min: 0.6, Avg: 1.1, Max: 1.5, Diff: 0.9, Sum: 8.9]\n       [Processed Buffers: Min: 1, Avg: 1.6, Max: 4, Diff: 3, Sum: 13]\n    [Scan RS (ms): Min: 1.0, Avg: 1.4, Max: 1.9, Diff: 0.9, Sum: 10.8]\n    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: \n      0.0]\n    [Object Copy (ms): Min: 71.5, Avg: 71.5, Max: 71.6, Diff: 0.1, Sum: 572.1]\n    [Termination (ms): Min: 0.3, Avg: 0.3, Max: 0.4, Diff: 0.1, Sum: 2.6]\n       [Termination Attempts: Min: 1382, Avg: 1515.5, Max: 1609, Diff: 227, \n         Sum: 12124]\n    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2]\n    [GC Worker Total (ms): Min: 74.5, Avg: 74.5, Max: 74.6, Diff: 0.1, Sum: \n      596.3]\n    [GC Worker End (ms): Min: 100145.1, Avg: 100145.1, Max: 100145.1, Diff: \n      0.0]\n  [Code Root Fixup: 0.0 ms]\n  [Code Root Purge: 0.0 ms]\n  [Clear CT: 0.1 ms]\n  [Other: 0.4 ms]\n    [Choose CSet: 0.0 ms]\n    [Ref Proc: 0.1 ms]\n    [Ref Enq: 0.0 ms]\n    [Redirty Cards: 0.1 ms]\n    [Humongous Register: 0.0 ms]\n    [Humongous Reclaim: 0.0 ms]\n    [Free CSet: 0.0 ms]\n  [Eden: 23.0M(23.0M)->0.0B(14.0M) Survivors: 4096.0K->4096.0K Heap: 84.5M\n    (128.0M)->86.5M(128.0M)]\n[Times: user=0.63 sys=0.00, real=0.08 secs]\n\n// 把YHR中Survivor分区作为根，开始并发标记根扫描\n100.146: [GC concurrent-root-region-scan-start]\n// 并发标记根扫描结束，花费了0.0196297，注意扫描和Mutator是并发进行，同时有多个线程并行\n100.165: [GC concurrent-root-region-scan-end, 0.0196297 secs]\n// 开始并发标记子阶段，这里从所有的根引用：包括Survivor和强根如栈等出发，对整个堆进行标记\n100.165: [GC concurrent-mark-start]\n// 标记结束，花费0.08848s\n100.254: [GC concurrent-mark-end, 0.0884800 secs]\n// 这里是再标记子阶段，包括再标记、引用处理、类卸载处理信息\n100.254: [GC remark 100.254: [Finalize Marking, 0.0002228 secs] 100.254: \n  [GC ref-proc, 0.0001515 secs] 100.254: [Unloading, 0.0004694 secs], \n  0.0011610 secs]\n  [Times: user=0.00 sys=0.00, real=0.00 secs]\n// 清除处理，这里的清除仅仅回收整个分区中的垃圾\n// 这里还会调整RSet，以减轻后续GC中RSet根的处理时间\n100.255: [GC cleanup 86M->86M(128M), 0.0005376 secs]\n  [Times: user=0.00 sys=0.00, real=0.00 secs]\n```\n\n### 混合GC日志\n``` log\n// 混合回收Mixed GC其实和YGC的日志类似，能看到GC pause(G1EvacuationPause)(mixed)这样的信息\n// 日志分析参考Y年轻代GC。\n  122.132: [GC pause (G1 Evacuation Pause) (mixed), 0.0106092 secs]\n  [Parallel Time: 9.8 ms, GC Workers: 8]\n    [GC Worker Start (ms): Min: 122131.9, Avg: 122132.0, Max: 122132.0, \n      Diff: 0.1]\n    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.7]\n    [Update RS (ms): Min: 0.5, Avg: 0.7, Max: 0.9, Diff: 0.4, Sum: 5.4]\n      [Processed Buffers: Min: 1, Avg: 1.8, Max: 3, Diff: 2, Sum: 14]\n    [Scan RS (ms): Min: 1.0, Avg: 1.3, Max: 1.5, Diff: 0.5, Sum: 10.4]\n    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: \n      0.0]\n    [Object Copy (ms): Min: 7.5, Avg: 7.6, Max: 7.7, Diff: 0.2, Sum: 60.9]\n    [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n      [Termination Attempts: Min: 92, Avg: 105.1, Max: 121, Diff: 29, Sum: 841]\n    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n    [GC Worker Total (ms): Min: 9.7, Avg: 9.7, Max: 9.8, Diff: 0.1, Sum: 77.6]\n    [GC Worker End (ms): Min: 122141.7, Avg: 122141.7, Max: 122141.7, Diff: 0.0]\n  [Code Root Fixup: 0.0 ms]\n  [Code Root Purge: 0.0 ms]\n  [Clear CT: 0.2 ms]\n  [Other: 0.7 ms]\n    [Choose CSet: 0.0 ms]\n    [Ref Proc: 0.1 ms]\n    [Ref Enq: 0.0 ms]\n    [Redirty Cards: 0.5 ms]\n    [Humongous Register: 0.0 ms]\n    [Humongous Reclaim: 0.0 ms]\n    [Free CSet: 0.0 ms]\n  [Eden: 3072.0K(3072.0K)->0.0B(5120.0K) Survivors: 3072.0K->1024.0K \n    Heap: 105.5M(128.0M)->104.0M(128.0M)]\n[Times: user=0.00 sys=0.00, real=0.01 secs]\n```\n\n\n## 四、GC算法\n|算法|分代|优缺点|\n|---|---|---|\n|标记清除(Mark-Sweep)|年轻代|效率低，产生内存碎片|\n|复制(Copying)|老年代|效率高，空间利用率低|\n|标记压缩(Mark-Compact)|老年代|针对老年代对象特征优化|\n|分代收集|年轻代使用复制，老年代使用标记压缩||\n||||\n\n### 4.1 标记清除\n![](images/GC/mark-clean.png)\n\n### 4.2 复制算法\n![](images/GC/copy.png)\n\n### 4.3 标记压缩\n![](images/GC/mark-compress.png)\n\n## 五、参数设置\n|参数|含义|\n|---|---|\n|-XX:+UseG1GC|JDK8需要设置|\n|-XX:G1HeapRegionSize|设置每个Region的大小。值是2的幂,范围是1MB到32MB之间|\n|-XX:MaxGCPauseMillis|期望达到的最大GC停顿时间指标,默认200ms|\n|-XX:ParallelGCThread:|垃圾回收线程,最多为8,STW时|\n|-XX:ConcGCThreads|并发标记线程数,一般=ParallelGCThreads/4|\n|||\n\n#### 参数设置参考\n由于是传统ERP项目，存量业务和大对象很多，所以Xmx设置的也比较大： \n``` bash\n-Xms6g -Xmx12g -XX:+UseG1GC -XX:ParallelGCThreads=8 -XX:ConcGCThreads=8 -Xss512k -XX:MetaspaceSize=768m -XX:MaxMetaspaceSize=2g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/log/erp-%t.hprof -XX:MaxDirectMemorySize=256m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/data/log/erp-gc-%t.log\n```\n\n\n## 参考  \nG1垃圾回收期入门    \nhttps://www.oracle.com/technetwork/tutorials/tutorials-1876574.html  \nG1详解   \nhttps://juejin.cn/post/7010034105165299725  \n最清晰易懂的G1\nhttps://segmentfault.com/a/1190000039411521\n\n\n\n\n\n\n\n\n","source":"_posts/G1收集器.md","raw":"---\ntitle: G1收集器\ndate: 2023-05-23 15:19:44\ntags:\n    - JVM\n    - 垃圾回收\ncategories: Spring+\n---\n在JDK9之后JVM默认使用G1(Garbage-First, 垃圾优先)收集器进行垃圾回收。G1是一款分代的 (generational)，增量的 (incremental)，并行的 (parallel)，移动式（evacuating）的，软实时的垃圾回收器。其最大特点是用Region代替传统分代模型，分代成为逻辑上的概念；建立了可预测的停顿时间模型，让暂停时间可配置。从实践结果来看，它能及时有效的回收大对象，增加吞吐量，避免内存碎片，保障程序的长久运行。\n<!-- more -->\n\n\n## 一、内存模型对比\n传统的垃圾收集器（串行、并行、CMS）都将堆结构分为三个部分：年轻代、老年代和固定内存大小的永久代\n- 传统收集器内存结构\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png)\n\nG1中的堆被划分为N个Region，每个region内内存连续，其中一部分被分配为传统的角色(eden、survivor、old)，但它们不是固定的位置和大小，这给内存分配提供了极大的灵活性。\n- G1内存结构\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png)\n\n\n## 二、GC步骤\nG1中有两种回收模式：\n- 年轻代垃圾回收（Young GC）\n- 混合垃圾回收（Mixed GC）\n\n### 2.1 年轻代GC\n年轻代GC是只选择年轻代区域（Eden/Survivor）进入回收集合（Collection Set，简称CSet）进行回收的模式。年轻代GC的过程和其他的分代回收器差不多，新创建的对象分配至Eden区域，然后将标记存活的对象移动至Survivor区，达到晋升年龄的就晋升到老年代区域，然后清空原区域（不过这里可没有年轻代复制算法中两个Survivor的交换过程）。\n\n1. G1在遵循GC暂停时间的基础上，选择最大年轻代Region数(CSSet)\n2. 根扫描(Root Scanning)\n3. RememberedSet扫描(RememberedSet简称RSet,会记录跨代引用的关系)\n4. 移动，遍历上面的标记栈，将栈内的所有所有的对象移动(复制)至Survivor区域\n\n年轻代GC图示：\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png)\n\n![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png)\n\n### 2.2 混合GC\n\n混合GC会选择所有年轻代区域(Eden/Survivor,最大年轻代分区数)和部分老年代区域进去回收集合进行回收的模式。年轻代区域对象移动到Survivor区，老年代区域移动到老年代区域。\n\n1. 初始标记  \n    > 这个是捎带在年轻代GC完成的\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png)\n2. 并发标记\n    > 并发标记的目的是标记存活对象，为移动过程做准备。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png)\n3. 再次标记\n    > 由于应用程序持续进行,需要修正上一次的标记结果。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)。此时，所有区域的活性都被计算出来了。\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png)\n\n4. 复制清理阶段\n    > G1 选择“活跃度”最低的区域，即可以收集最快的区域。然后与年轻的GC同时收集这些区域\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png)\n\n5. 最终清理阶段\n    > 所选择的区域都被复制，然后压缩\n    ![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png)  \n\n**混合GC总结**\n|阶段|是否STW|描述|\n|---|---|---|\n|初始标记|是|捎带在年轻代GC完成|\n|根区域扫描|否|扫描幸存者区域以查找对老年代的引用|\n|并行标记|否|查找整个堆上的活动对象|\n|再次标记|是|遗漏的再标记一次|\n|清理|是|对活动对象和完全自由区域执行记帐;擦洗RSet;重置空区域并将其返回到可用列表|\n|复制|是|疏散或复制活动对象到未使用区域|\n\n## 三、GC日志\n\nG1 GC的垃圾回收过程主要包括如下三个环节：  \n年轻代GC (Young GC)、老年代并发标记过程 (Concurrent Marking)、混合回收(Mixed GC)。并发标记是全局的，和回收过程是两个阶段。\n\n### 年轻代GC日志\n``` log\n//[GC pause (G1 Evacuation Pause) (young) 代表完全年轻代回收\n// 0.0182341 secs 是本次GC的暂停时间\n0.184: [GC pause (G1 Evacuation Pause) (young), 0.0182341 secs 是本次GC的暂停时间]\n// 并行GC线程，一共有8个\n   [Parallel Time: 16.7 ms, GC Workers: 8]\n      /*这一行信息说明的是这8个线程开始的时间，Min表示最早开始的线程时间，Avg表示平均开始时间，Max表示的是最晚开始时间，Diff为最早和最晚的时间差。这个值越大说明线程启动时间越不均衡。线程启动的时间依赖于GC进入安全点的情况。关于安全点可以参考后文的介绍。*/\n      [GC Worker Start (ms):  184.2  184.2  184.2  184.3  184.3  184.4  186.1  186.1\n       Min: 184.2, Avg: 184.7, Max: 186.1, Diff: 1.9]\n      /*根处理的时间，这个时间包含了所有强根的时间，分为Java根，分别为Thread、JNI、CLDG；和JVM根下面的StringTable、Universe、JNI Handles、ObjectSynchronizer、FlatProfiler、Management、SystemDictionary、JVMTI */\n      [Ext Root Scanning (ms):  0.3  0.2  0.2  0.1  0.1  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.3, Sum: 0.8]\n         /*Java线程处理时间，主要是线程栈。这个时间包含了根直接引用对象的复制时间，如果根超级大，这个时间可能会增加 */\n         [Thread Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n         [StringTable Roots (ms):  0.0  0.1  0.1  0.1  0.1  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]\n         [Universe Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [JNI Handles Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [ObjectSynchronizer Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [FlatProfiler Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Management Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [SystemDictionary Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [CLDG Roots (ms):  0.3  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.3, Diff: 0.3, Sum: 0.3]\n         [JVMTI Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n       // CodeCache Roots实际上是在处理Rset的时候的统计值，它包含下面的\n       // UpdateRS，ScanRS和Code Root Scanning\n         [CodeCache Roots (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2\n          Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.6]\n         [CM RefProcessor Roots (ms):  0.0\n         0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Wait For Strong CLD (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Weak CLD Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [SATB Filtering (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n       // 这个就是GC线程更新RSet的时间花费，注意这里的时间和我们在Refine里面处理RSet\n       // 的时间没有关系，因为它们是不同的线程处理\n       [Update RS (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2\n        Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.5]\n          // 这里就是GC线程处理的白区中的dcq个数\n         [Processed Buffers:  8  8  7  8  8  7  2  4\n          Min: 2, Avg: 6.5, Max: 8, Diff: 6, Sum: 52]\n      // 扫描RSet找到被引用的对象\n      [Scan RS (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n      [Code Root Scanning (ms):  0.0  0.0  0.0  0.0  0.0  0.1  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]\n      // 这个就是所有活着的对象（除了强根直接引用的对象，在Java根处理时会直接复制）复制\n      // 到新的分区花费的时间。从这里也可以看出复制基本上是最花费时间的操作。        \n      [Object Copy (ms):  11.3  12.5  14.2  13.1  14.3  14.2  14.2  12.5\n       Min: 11.3, Avg: 13.3, Max: 14.3, Diff: 3.0, Sum: 106.3]\n      // GC线程结束的时间信息。\n      [Termination (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts:  1  1  1  1  1  1  1  1\n          Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8]\n      // 这个是并行处理时其他处理所花费的时间，通常是由于JVM析构释放资源等\n      [GC Worker Other (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n      // 并行GC花费的总体时间\n      [GC Worker Total (ms):  16.6  16.6  16.6  16.5  16.5  16.4  14.7  14.7\n       Min: 14.7, Avg: 16.1, Max: 16.6, Diff: 1.9, Sum: 128.7]\n      // GC线程结束的时间信息\n      [GC Worker End (ms):  200.8  200.8  200.8  200.8  200.8  200.8  200.8  200.8\n       Min: 200.8, Avg: 200.8, Max: 200.8, Diff: 0.0]\n    // 下面是其他任务部分。\n    // 代码扫描属于并行执行部分，包含了代码的调整和回收时间\n    [Code Root Fixup: 0.0 ms]   \n    [Code Root Purge: 0.0 ms]\n    // 清除卡表的时间\n    [Clear CT: 0.1 ms]\n    [Other: 1.5 ms]\n      // 选择CSet的时间，YGC通常是0\n      [Choose CSet: 0.0 ms]\n      // 引用处理的时间，这个时间是发现哪些引用对象可以清除，这个是可以并行处理的\n      [Ref Proc: 1.1 ms]\n      // 引用重新激活\n      [Ref Enq: 0.2 ms]\n      // 重构RSet花费的时间\n      [Redirty Cards: 0.1 ms]\n         [Parallel Redirty:  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n         [Redirtied Cards:  8118  7583  6892  4496  0  0  0  0\n          Min: 0, Avg: 3386.1, Max: 8118, Diff: 8118, Sum: 27089]\n          // 这个信息是是可以并行处理的，这里是线程重构RSet的数目\n       // 大对象处理时间\n      [Humongous Register: 0.0 ms]\n         [Humongous Total: 2]\n          // 这里说明有2个大对象\n         [Humongous Candidate: 0]\n          // 可回收的大对象0个\n      // 如果有大对象要回收，回收花费的时间，回收的个数\n      [Humongous Reclaim: 0.0 ms]\n         [Humongous Reclaimed: 0]\n      // 释放CSet中的分区花费的时间，有新生代的信息和老生代的信息。\n      [Free CSet: 0.0 ms]\n         [Young Free CSet: 0.0 ms]\n         [Non-Young Free CSet: 0.0 ms]\n    // GC结束后Eden从15M变成0，下一次使用的空间为21M，S从2M变成3M，整个堆从\n    // 23.7M变成20M\n    [Eden: 15.0M(15.0M)->0.0B(21.0M) Survivors: 2048.0K->3072.0K \n     Heap: 23.7M(256.0M)->20.0M(256.0M)]\n```\n\n### 并发标记日志\n``` log\n//并发标记 - 初始标记阶段，在年轻代GC中完成\n100.070: [GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0751469 secs]\n  [Parallel Time: 74.7 ms, GC Workers: 8]\n    [GC Worker Start (ms): Min: 100070.4, Avg: 100070.5, Max: 100070.6, Diff: \n      0.1]\n    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.2, Max: 0.3, Diff: 0.2, Sum: \n      1.6]\n    [Update RS (ms): Min: 0.6, Avg: 1.1, Max: 1.5, Diff: 0.9, Sum: 8.9]\n       [Processed Buffers: Min: 1, Avg: 1.6, Max: 4, Diff: 3, Sum: 13]\n    [Scan RS (ms): Min: 1.0, Avg: 1.4, Max: 1.9, Diff: 0.9, Sum: 10.8]\n    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: \n      0.0]\n    [Object Copy (ms): Min: 71.5, Avg: 71.5, Max: 71.6, Diff: 0.1, Sum: 572.1]\n    [Termination (ms): Min: 0.3, Avg: 0.3, Max: 0.4, Diff: 0.1, Sum: 2.6]\n       [Termination Attempts: Min: 1382, Avg: 1515.5, Max: 1609, Diff: 227, \n         Sum: 12124]\n    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2]\n    [GC Worker Total (ms): Min: 74.5, Avg: 74.5, Max: 74.6, Diff: 0.1, Sum: \n      596.3]\n    [GC Worker End (ms): Min: 100145.1, Avg: 100145.1, Max: 100145.1, Diff: \n      0.0]\n  [Code Root Fixup: 0.0 ms]\n  [Code Root Purge: 0.0 ms]\n  [Clear CT: 0.1 ms]\n  [Other: 0.4 ms]\n    [Choose CSet: 0.0 ms]\n    [Ref Proc: 0.1 ms]\n    [Ref Enq: 0.0 ms]\n    [Redirty Cards: 0.1 ms]\n    [Humongous Register: 0.0 ms]\n    [Humongous Reclaim: 0.0 ms]\n    [Free CSet: 0.0 ms]\n  [Eden: 23.0M(23.0M)->0.0B(14.0M) Survivors: 4096.0K->4096.0K Heap: 84.5M\n    (128.0M)->86.5M(128.0M)]\n[Times: user=0.63 sys=0.00, real=0.08 secs]\n\n// 把YHR中Survivor分区作为根，开始并发标记根扫描\n100.146: [GC concurrent-root-region-scan-start]\n// 并发标记根扫描结束，花费了0.0196297，注意扫描和Mutator是并发进行，同时有多个线程并行\n100.165: [GC concurrent-root-region-scan-end, 0.0196297 secs]\n// 开始并发标记子阶段，这里从所有的根引用：包括Survivor和强根如栈等出发，对整个堆进行标记\n100.165: [GC concurrent-mark-start]\n// 标记结束，花费0.08848s\n100.254: [GC concurrent-mark-end, 0.0884800 secs]\n// 这里是再标记子阶段，包括再标记、引用处理、类卸载处理信息\n100.254: [GC remark 100.254: [Finalize Marking, 0.0002228 secs] 100.254: \n  [GC ref-proc, 0.0001515 secs] 100.254: [Unloading, 0.0004694 secs], \n  0.0011610 secs]\n  [Times: user=0.00 sys=0.00, real=0.00 secs]\n// 清除处理，这里的清除仅仅回收整个分区中的垃圾\n// 这里还会调整RSet，以减轻后续GC中RSet根的处理时间\n100.255: [GC cleanup 86M->86M(128M), 0.0005376 secs]\n  [Times: user=0.00 sys=0.00, real=0.00 secs]\n```\n\n### 混合GC日志\n``` log\n// 混合回收Mixed GC其实和YGC的日志类似，能看到GC pause(G1EvacuationPause)(mixed)这样的信息\n// 日志分析参考Y年轻代GC。\n  122.132: [GC pause (G1 Evacuation Pause) (mixed), 0.0106092 secs]\n  [Parallel Time: 9.8 ms, GC Workers: 8]\n    [GC Worker Start (ms): Min: 122131.9, Avg: 122132.0, Max: 122132.0, \n      Diff: 0.1]\n    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.7]\n    [Update RS (ms): Min: 0.5, Avg: 0.7, Max: 0.9, Diff: 0.4, Sum: 5.4]\n      [Processed Buffers: Min: 1, Avg: 1.8, Max: 3, Diff: 2, Sum: 14]\n    [Scan RS (ms): Min: 1.0, Avg: 1.3, Max: 1.5, Diff: 0.5, Sum: 10.4]\n    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: \n      0.0]\n    [Object Copy (ms): Min: 7.5, Avg: 7.6, Max: 7.7, Diff: 0.2, Sum: 60.9]\n    [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n      [Termination Attempts: Min: 92, Avg: 105.1, Max: 121, Diff: 29, Sum: 841]\n    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n    [GC Worker Total (ms): Min: 9.7, Avg: 9.7, Max: 9.8, Diff: 0.1, Sum: 77.6]\n    [GC Worker End (ms): Min: 122141.7, Avg: 122141.7, Max: 122141.7, Diff: 0.0]\n  [Code Root Fixup: 0.0 ms]\n  [Code Root Purge: 0.0 ms]\n  [Clear CT: 0.2 ms]\n  [Other: 0.7 ms]\n    [Choose CSet: 0.0 ms]\n    [Ref Proc: 0.1 ms]\n    [Ref Enq: 0.0 ms]\n    [Redirty Cards: 0.5 ms]\n    [Humongous Register: 0.0 ms]\n    [Humongous Reclaim: 0.0 ms]\n    [Free CSet: 0.0 ms]\n  [Eden: 3072.0K(3072.0K)->0.0B(5120.0K) Survivors: 3072.0K->1024.0K \n    Heap: 105.5M(128.0M)->104.0M(128.0M)]\n[Times: user=0.00 sys=0.00, real=0.01 secs]\n```\n\n\n## 四、GC算法\n|算法|分代|优缺点|\n|---|---|---|\n|标记清除(Mark-Sweep)|年轻代|效率低，产生内存碎片|\n|复制(Copying)|老年代|效率高，空间利用率低|\n|标记压缩(Mark-Compact)|老年代|针对老年代对象特征优化|\n|分代收集|年轻代使用复制，老年代使用标记压缩||\n||||\n\n### 4.1 标记清除\n![](images/GC/mark-clean.png)\n\n### 4.2 复制算法\n![](images/GC/copy.png)\n\n### 4.3 标记压缩\n![](images/GC/mark-compress.png)\n\n## 五、参数设置\n|参数|含义|\n|---|---|\n|-XX:+UseG1GC|JDK8需要设置|\n|-XX:G1HeapRegionSize|设置每个Region的大小。值是2的幂,范围是1MB到32MB之间|\n|-XX:MaxGCPauseMillis|期望达到的最大GC停顿时间指标,默认200ms|\n|-XX:ParallelGCThread:|垃圾回收线程,最多为8,STW时|\n|-XX:ConcGCThreads|并发标记线程数,一般=ParallelGCThreads/4|\n|||\n\n#### 参数设置参考\n由于是传统ERP项目，存量业务和大对象很多，所以Xmx设置的也比较大： \n``` bash\n-Xms6g -Xmx12g -XX:+UseG1GC -XX:ParallelGCThreads=8 -XX:ConcGCThreads=8 -Xss512k -XX:MetaspaceSize=768m -XX:MaxMetaspaceSize=2g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/log/erp-%t.hprof -XX:MaxDirectMemorySize=256m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/data/log/erp-gc-%t.log\n```\n\n\n## 参考  \nG1垃圾回收期入门    \nhttps://www.oracle.com/technetwork/tutorials/tutorials-1876574.html  \nG1详解   \nhttps://juejin.cn/post/7010034105165299725  \n最清晰易懂的G1\nhttps://segmentfault.com/a/1190000039411521\n\n\n\n\n\n\n\n\n","slug":"G1收集器","published":1,"updated":"2024-04-11T03:39:00.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyo0009qwvd6ji90kws","content":"<p>在JDK9之后JVM默认使用G1(Garbage-First, 垃圾优先)收集器进行垃圾回收。G1是一款分代的 (generational)，增量的 (incremental)，并行的 (parallel)，移动式（evacuating）的，软实时的垃圾回收器。其最大特点是用Region代替传统分代模型，分代成为逻辑上的概念；建立了可预测的停顿时间模型，让暂停时间可配置。从实践结果来看，它能及时有效的回收大对象，增加吞吐量，避免内存碎片，保障程序的长久运行。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"一、内存模型对比\"><a href=\"#一、内存模型对比\" class=\"headerlink\" title=\"一、内存模型对比\"></a>一、内存模型对比</h2><p>传统的垃圾收集器（串行、并行、CMS）都将堆结构分为三个部分：年轻代、老年代和固定内存大小的永久代</p>\n<ul>\n<li>传统收集器内存结构<br><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png\"></li>\n</ul>\n<p>G1中的堆被划分为N个Region，每个region内内存连续，其中一部分被分配为传统的角色(eden、survivor、old)，但它们不是固定的位置和大小，这给内存分配提供了极大的灵活性。</p>\n<ul>\n<li>G1内存结构<br><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png\"></li>\n</ul>\n<h2 id=\"二、GC步骤\"><a href=\"#二、GC步骤\" class=\"headerlink\" title=\"二、GC步骤\"></a>二、GC步骤</h2><p>G1中有两种回收模式：</p>\n<ul>\n<li>年轻代垃圾回收（Young GC）</li>\n<li>混合垃圾回收（Mixed GC）</li>\n</ul>\n<h3 id=\"2-1-年轻代GC\"><a href=\"#2-1-年轻代GC\" class=\"headerlink\" title=\"2.1 年轻代GC\"></a>2.1 年轻代GC</h3><p>年轻代GC是只选择年轻代区域（Eden&#x2F;Survivor）进入回收集合（Collection Set，简称CSet）进行回收的模式。年轻代GC的过程和其他的分代回收器差不多，新创建的对象分配至Eden区域，然后将标记存活的对象移动至Survivor区，达到晋升年龄的就晋升到老年代区域，然后清空原区域（不过这里可没有年轻代复制算法中两个Survivor的交换过程）。</p>\n<ol>\n<li>G1在遵循GC暂停时间的基础上，选择最大年轻代Region数(CSSet)</li>\n<li>根扫描(Root Scanning)</li>\n<li>RememberedSet扫描(RememberedSet简称RSet,会记录跨代引用的关系)</li>\n<li>移动，遍历上面的标记栈，将栈内的所有所有的对象移动(复制)至Survivor区域</li>\n</ol>\n<p>年轻代GC图示：<br><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png\"></p>\n<p><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png\"></p>\n<h3 id=\"2-2-混合GC\"><a href=\"#2-2-混合GC\" class=\"headerlink\" title=\"2.2 混合GC\"></a>2.2 混合GC</h3><p>混合GC会选择所有年轻代区域(Eden&#x2F;Survivor,最大年轻代分区数)和部分老年代区域进去回收集合进行回收的模式。年轻代区域对象移动到Survivor区，老年代区域移动到老年代区域。</p>\n<ol>\n<li><p>初始标记  </p>\n<blockquote>\n<p>这个是捎带在年轻代GC完成的<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png\"></p>\n</blockquote>\n</li>\n<li><p>并发标记</p>\n<blockquote>\n<p>并发标记的目的是标记存活对象，为移动过程做准备。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png\"></p>\n</blockquote>\n</li>\n<li><p>再次标记</p>\n<blockquote>\n<p>由于应用程序持续进行,需要修正上一次的标记结果。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)。此时，所有区域的活性都被计算出来了。<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png\"></p>\n</blockquote>\n</li>\n<li><p>复制清理阶段</p>\n<blockquote>\n<p>G1 选择“活跃度”最低的区域，即可以收集最快的区域。然后与年轻的GC同时收集这些区域<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png\"></p>\n</blockquote>\n</li>\n<li><p>最终清理阶段</p>\n<blockquote>\n<p>所选择的区域都被复制，然后压缩<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png\"></p>\n</blockquote>\n</li>\n</ol>\n<p><strong>混合GC总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>是否STW</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>初始标记</td>\n<td>是</td>\n<td>捎带在年轻代GC完成</td>\n</tr>\n<tr>\n<td>根区域扫描</td>\n<td>否</td>\n<td>扫描幸存者区域以查找对老年代的引用</td>\n</tr>\n<tr>\n<td>并行标记</td>\n<td>否</td>\n<td>查找整个堆上的活动对象</td>\n</tr>\n<tr>\n<td>再次标记</td>\n<td>是</td>\n<td>遗漏的再标记一次</td>\n</tr>\n<tr>\n<td>清理</td>\n<td>是</td>\n<td>对活动对象和完全自由区域执行记帐;擦洗RSet;重置空区域并将其返回到可用列表</td>\n</tr>\n<tr>\n<td>复制</td>\n<td>是</td>\n<td>疏散或复制活动对象到未使用区域</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、GC日志\"><a href=\"#三、GC日志\" class=\"headerlink\" title=\"三、GC日志\"></a>三、GC日志</h2><p>G1 GC的垃圾回收过程主要包括如下三个环节：<br>年轻代GC (Young GC)、老年代并发标记过程 (Concurrent Marking)、混合回收(Mixed GC)。并发标记是全局的，和回收过程是两个阶段。</p>\n<h3 id=\"年轻代GC日志\"><a href=\"#年轻代GC日志\" class=\"headerlink\" title=\"年轻代GC日志\"></a>年轻代GC日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//[GC pause (G1 Evacuation Pause) (young) 代表完全年轻代回收</span><br><span class=\"line\">// 0.0182341 secs 是本次GC的暂停时间</span><br><span class=\"line\">0.184: [GC pause (G1 Evacuation Pause) (young), 0.0182341 secs 是本次GC的暂停时间]</span><br><span class=\"line\">// 并行GC线程，一共有8个</span><br><span class=\"line\">   [Parallel Time: 16.7 ms, GC Workers: 8]</span><br><span class=\"line\">      /*这一行信息说明的是这8个线程开始的时间，Min表示最早开始的线程时间，Avg表示平均开始时间，Max表示的是最晚开始时间，Diff为最早和最晚的时间差。这个值越大说明线程启动时间越不均衡。线程启动的时间依赖于GC进入安全点的情况。关于安全点可以参考后文的介绍。*/</span><br><span class=\"line\">      [GC Worker Start (ms):  184.2  184.2  184.2  184.3  184.3  184.4  186.1  186.1</span><br><span class=\"line\">       Min: 184.2, Avg: 184.7, Max: 186.1, Diff: 1.9]</span><br><span class=\"line\">      /*根处理的时间，这个时间包含了所有强根的时间，分为Java根，分别为Thread、JNI、CLDG；和JVM根下面的StringTable、Universe、JNI Handles、ObjectSynchronizer、FlatProfiler、Management、SystemDictionary、JVMTI */</span><br><span class=\"line\">      [Ext Root Scanning (ms):  0.3  0.2  0.2  0.1  0.1  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.3, Sum: 0.8]</span><br><span class=\"line\">         /*Java线程处理时间，主要是线程栈。这个时间包含了根直接引用对象的复制时间，如果根超级大，这个时间可能会增加 */</span><br><span class=\"line\">         [Thread Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">         [StringTable Roots (ms):  0.0  0.1  0.1  0.1  0.1  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]</span><br><span class=\"line\">         [Universe Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [JNI Handles Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [ObjectSynchronizer Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [FlatProfiler Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Management Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [SystemDictionary Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [CLDG Roots (ms):  0.3  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.3, Diff: 0.3, Sum: 0.3]</span><br><span class=\"line\">         [JVMTI Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">       // CodeCache Roots实际上是在处理Rset的时候的统计值，它包含下面的</span><br><span class=\"line\">       // UpdateRS，ScanRS和Code Root Scanning</span><br><span class=\"line\">         [CodeCache Roots (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2</span><br><span class=\"line\">          Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.6]</span><br><span class=\"line\">         [CM RefProcessor Roots (ms):  0.0</span><br><span class=\"line\">         0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Wait For Strong CLD (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Weak CLD Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [SATB Filtering (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">       // 这个就是GC线程更新RSet的时间花费，注意这里的时间和我们在Refine里面处理RSet</span><br><span class=\"line\">       // 的时间没有关系，因为它们是不同的线程处理</span><br><span class=\"line\">       [Update RS (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2</span><br><span class=\"line\">        Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.5]</span><br><span class=\"line\">          // 这里就是GC线程处理的白区中的dcq个数</span><br><span class=\"line\">         [Processed Buffers:  8  8  7  8  8  7  2  4</span><br><span class=\"line\">          Min: 2, Avg: 6.5, Max: 8, Diff: 6, Sum: 52]</span><br><span class=\"line\">      // 扫描RSet找到被引用的对象</span><br><span class=\"line\">      [Scan RS (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">      [Code Root Scanning (ms):  0.0  0.0  0.0  0.0  0.0  0.1  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]</span><br><span class=\"line\">      // 这个就是所有活着的对象（除了强根直接引用的对象，在Java根处理时会直接复制）复制</span><br><span class=\"line\">      // 到新的分区花费的时间。从这里也可以看出复制基本上是最花费时间的操作。        </span><br><span class=\"line\">      [Object Copy (ms):  11.3  12.5  14.2  13.1  14.3  14.2  14.2  12.5</span><br><span class=\"line\">       Min: 11.3, Avg: 13.3, Max: 14.3, Diff: 3.0, Sum: 106.3]</span><br><span class=\"line\">      // GC线程结束的时间信息。</span><br><span class=\"line\">      [Termination (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Termination Attempts:  1  1  1  1  1  1  1  1</span><br><span class=\"line\">          Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8]</span><br><span class=\"line\">      // 这个是并行处理时其他处理所花费的时间，通常是由于JVM析构释放资源等</span><br><span class=\"line\">      [GC Worker Other (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">      // 并行GC花费的总体时间</span><br><span class=\"line\">      [GC Worker Total (ms):  16.6  16.6  16.6  16.5  16.5  16.4  14.7  14.7</span><br><span class=\"line\">       Min: 14.7, Avg: 16.1, Max: 16.6, Diff: 1.9, Sum: 128.7]</span><br><span class=\"line\">      // GC线程结束的时间信息</span><br><span class=\"line\">      [GC Worker End (ms):  200.8  200.8  200.8  200.8  200.8  200.8  200.8  200.8</span><br><span class=\"line\">       Min: 200.8, Avg: 200.8, Max: 200.8, Diff: 0.0]</span><br><span class=\"line\">    // 下面是其他任务部分。</span><br><span class=\"line\">    // 代码扫描属于并行执行部分，包含了代码的调整和回收时间</span><br><span class=\"line\">    [Code Root Fixup: 0.0 ms]   </span><br><span class=\"line\">    [Code Root Purge: 0.0 ms]</span><br><span class=\"line\">    // 清除卡表的时间</span><br><span class=\"line\">    [Clear CT: 0.1 ms]</span><br><span class=\"line\">    [Other: 1.5 ms]</span><br><span class=\"line\">      // 选择CSet的时间，YGC通常是0</span><br><span class=\"line\">      [Choose CSet: 0.0 ms]</span><br><span class=\"line\">      // 引用处理的时间，这个时间是发现哪些引用对象可以清除，这个是可以并行处理的</span><br><span class=\"line\">      [Ref Proc: 1.1 ms]</span><br><span class=\"line\">      // 引用重新激活</span><br><span class=\"line\">      [Ref Enq: 0.2 ms]</span><br><span class=\"line\">      // 重构RSet花费的时间</span><br><span class=\"line\">      [Redirty Cards: 0.1 ms]</span><br><span class=\"line\">         [Parallel Redirty:  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">         [Redirtied Cards:  8118  7583  6892  4496  0  0  0  0</span><br><span class=\"line\">          Min: 0, Avg: 3386.1, Max: 8118, Diff: 8118, Sum: 27089]</span><br><span class=\"line\">          // 这个信息是是可以并行处理的，这里是线程重构RSet的数目</span><br><span class=\"line\">       // 大对象处理时间</span><br><span class=\"line\">      [Humongous Register: 0.0 ms]</span><br><span class=\"line\">         [Humongous Total: 2]</span><br><span class=\"line\">          // 这里说明有2个大对象</span><br><span class=\"line\">         [Humongous Candidate: 0]</span><br><span class=\"line\">          // 可回收的大对象0个</span><br><span class=\"line\">      // 如果有大对象要回收，回收花费的时间，回收的个数</span><br><span class=\"line\">      [Humongous Reclaim: 0.0 ms]</span><br><span class=\"line\">         [Humongous Reclaimed: 0]</span><br><span class=\"line\">      // 释放CSet中的分区花费的时间，有新生代的信息和老生代的信息。</span><br><span class=\"line\">      [Free CSet: 0.0 ms]</span><br><span class=\"line\">         [Young Free CSet: 0.0 ms]</span><br><span class=\"line\">         [Non-Young Free CSet: 0.0 ms]</span><br><span class=\"line\">    // GC结束后Eden从15M变成0，下一次使用的空间为21M，S从2M变成3M，整个堆从</span><br><span class=\"line\">    // 23.7M变成20M</span><br><span class=\"line\">    [Eden: 15.0M(15.0M)-&gt;0.0B(21.0M) Survivors: 2048.0K-&gt;3072.0K </span><br><span class=\"line\">     Heap: 23.7M(256.0M)-&gt;20.0M(256.0M)]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"并发标记日志\"><a href=\"#并发标记日志\" class=\"headerlink\" title=\"并发标记日志\"></a>并发标记日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//并发标记 - 初始标记阶段，在年轻代GC中完成</span><br><span class=\"line\">100.070: [GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0751469 secs]</span><br><span class=\"line\">  [Parallel Time: 74.7 ms, GC Workers: 8]</span><br><span class=\"line\">    [GC Worker Start (ms): Min: 100070.4, Avg: 100070.5, Max: 100070.6, Diff: </span><br><span class=\"line\">      0.1]</span><br><span class=\"line\">    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.2, Max: 0.3, Diff: 0.2, Sum: </span><br><span class=\"line\">      1.6]</span><br><span class=\"line\">    [Update RS (ms): Min: 0.6, Avg: 1.1, Max: 1.5, Diff: 0.9, Sum: 8.9]</span><br><span class=\"line\">       [Processed Buffers: Min: 1, Avg: 1.6, Max: 4, Diff: 3, Sum: 13]</span><br><span class=\"line\">    [Scan RS (ms): Min: 1.0, Avg: 1.4, Max: 1.9, Diff: 0.9, Sum: 10.8]</span><br><span class=\"line\">    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: </span><br><span class=\"line\">      0.0]</span><br><span class=\"line\">    [Object Copy (ms): Min: 71.5, Avg: 71.5, Max: 71.6, Diff: 0.1, Sum: 572.1]</span><br><span class=\"line\">    [Termination (ms): Min: 0.3, Avg: 0.3, Max: 0.4, Diff: 0.1, Sum: 2.6]</span><br><span class=\"line\">       [Termination Attempts: Min: 1382, Avg: 1515.5, Max: 1609, Diff: 227, </span><br><span class=\"line\">         Sum: 12124]</span><br><span class=\"line\">    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2]</span><br><span class=\"line\">    [GC Worker Total (ms): Min: 74.5, Avg: 74.5, Max: 74.6, Diff: 0.1, Sum: </span><br><span class=\"line\">      596.3]</span><br><span class=\"line\">    [GC Worker End (ms): Min: 100145.1, Avg: 100145.1, Max: 100145.1, Diff: </span><br><span class=\"line\">      0.0]</span><br><span class=\"line\">  [Code Root Fixup: 0.0 ms]</span><br><span class=\"line\">  [Code Root Purge: 0.0 ms]</span><br><span class=\"line\">  [Clear CT: 0.1 ms]</span><br><span class=\"line\">  [Other: 0.4 ms]</span><br><span class=\"line\">    [Choose CSet: 0.0 ms]</span><br><span class=\"line\">    [Ref Proc: 0.1 ms]</span><br><span class=\"line\">    [Ref Enq: 0.0 ms]</span><br><span class=\"line\">    [Redirty Cards: 0.1 ms]</span><br><span class=\"line\">    [Humongous Register: 0.0 ms]</span><br><span class=\"line\">    [Humongous Reclaim: 0.0 ms]</span><br><span class=\"line\">    [Free CSet: 0.0 ms]</span><br><span class=\"line\">  [Eden: 23.0M(23.0M)-&gt;0.0B(14.0M) Survivors: 4096.0K-&gt;4096.0K Heap: 84.5M</span><br><span class=\"line\">    (128.0M)-&gt;86.5M(128.0M)]</span><br><span class=\"line\">[Times: user=0.63 sys=0.00, real=0.08 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">// 把YHR中Survivor分区作为根，开始并发标记根扫描</span><br><span class=\"line\">100.146: [GC concurrent-root-region-scan-start]</span><br><span class=\"line\">// 并发标记根扫描结束，花费了0.0196297，注意扫描和Mutator是并发进行，同时有多个线程并行</span><br><span class=\"line\">100.165: [GC concurrent-root-region-scan-end, 0.0196297 secs]</span><br><span class=\"line\">// 开始并发标记子阶段，这里从所有的根引用：包括Survivor和强根如栈等出发，对整个堆进行标记</span><br><span class=\"line\">100.165: [GC concurrent-mark-start]</span><br><span class=\"line\">// 标记结束，花费0.08848s</span><br><span class=\"line\">100.254: [GC concurrent-mark-end, 0.0884800 secs]</span><br><span class=\"line\">// 这里是再标记子阶段，包括再标记、引用处理、类卸载处理信息</span><br><span class=\"line\">100.254: [GC remark 100.254: [Finalize Marking, 0.0002228 secs] 100.254: </span><br><span class=\"line\">  [GC ref-proc, 0.0001515 secs] 100.254: [Unloading, 0.0004694 secs], </span><br><span class=\"line\">  0.0011610 secs]</span><br><span class=\"line\">  [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class=\"line\">// 清除处理，这里的清除仅仅回收整个分区中的垃圾</span><br><span class=\"line\">// 这里还会调整RSet，以减轻后续GC中RSet根的处理时间</span><br><span class=\"line\">100.255: [GC cleanup 86M-&gt;86M(128M), 0.0005376 secs]</span><br><span class=\"line\">  [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"混合GC日志\"><a href=\"#混合GC日志\" class=\"headerlink\" title=\"混合GC日志\"></a>混合GC日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 混合回收Mixed GC其实和YGC的日志类似，能看到GC pause(G1EvacuationPause)(mixed)这样的信息</span><br><span class=\"line\">// 日志分析参考Y年轻代GC。</span><br><span class=\"line\">  122.132: [GC pause (G1 Evacuation Pause) (mixed), 0.0106092 secs]</span><br><span class=\"line\">  [Parallel Time: 9.8 ms, GC Workers: 8]</span><br><span class=\"line\">    [GC Worker Start (ms): Min: 122131.9, Avg: 122132.0, Max: 122132.0, </span><br><span class=\"line\">      Diff: 0.1]</span><br><span class=\"line\">    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.7]</span><br><span class=\"line\">    [Update RS (ms): Min: 0.5, Avg: 0.7, Max: 0.9, Diff: 0.4, Sum: 5.4]</span><br><span class=\"line\">      [Processed Buffers: Min: 1, Avg: 1.8, Max: 3, Diff: 2, Sum: 14]</span><br><span class=\"line\">    [Scan RS (ms): Min: 1.0, Avg: 1.3, Max: 1.5, Diff: 0.5, Sum: 10.4]</span><br><span class=\"line\">    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: </span><br><span class=\"line\">      0.0]</span><br><span class=\"line\">    [Object Copy (ms): Min: 7.5, Avg: 7.6, Max: 7.7, Diff: 0.2, Sum: 60.9]</span><br><span class=\"line\">    [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">      [Termination Attempts: Min: 92, Avg: 105.1, Max: 121, Diff: 29, Sum: 841]</span><br><span class=\"line\">    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">    [GC Worker Total (ms): Min: 9.7, Avg: 9.7, Max: 9.8, Diff: 0.1, Sum: 77.6]</span><br><span class=\"line\">    [GC Worker End (ms): Min: 122141.7, Avg: 122141.7, Max: 122141.7, Diff: 0.0]</span><br><span class=\"line\">  [Code Root Fixup: 0.0 ms]</span><br><span class=\"line\">  [Code Root Purge: 0.0 ms]</span><br><span class=\"line\">  [Clear CT: 0.2 ms]</span><br><span class=\"line\">  [Other: 0.7 ms]</span><br><span class=\"line\">    [Choose CSet: 0.0 ms]</span><br><span class=\"line\">    [Ref Proc: 0.1 ms]</span><br><span class=\"line\">    [Ref Enq: 0.0 ms]</span><br><span class=\"line\">    [Redirty Cards: 0.5 ms]</span><br><span class=\"line\">    [Humongous Register: 0.0 ms]</span><br><span class=\"line\">    [Humongous Reclaim: 0.0 ms]</span><br><span class=\"line\">    [Free CSet: 0.0 ms]</span><br><span class=\"line\">  [Eden: 3072.0K(3072.0K)-&gt;0.0B(5120.0K) Survivors: 3072.0K-&gt;1024.0K </span><br><span class=\"line\">    Heap: 105.5M(128.0M)-&gt;104.0M(128.0M)]</span><br><span class=\"line\">[Times: user=0.00 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"四、GC算法\"><a href=\"#四、GC算法\" class=\"headerlink\" title=\"四、GC算法\"></a>四、GC算法</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>分代</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标记清除(Mark-Sweep)</td>\n<td>年轻代</td>\n<td>效率低，产生内存碎片</td>\n</tr>\n<tr>\n<td>复制(Copying)</td>\n<td>老年代</td>\n<td>效率高，空间利用率低</td>\n</tr>\n<tr>\n<td>标记压缩(Mark-Compact)</td>\n<td>老年代</td>\n<td>针对老年代对象特征优化</td>\n</tr>\n<tr>\n<td>分代收集</td>\n<td>年轻代使用复制，老年代使用标记压缩</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"4-1-标记清除\"><a href=\"#4-1-标记清除\" class=\"headerlink\" title=\"4.1 标记清除\"></a>4.1 标记清除</h3><p><img src=\"/images/GC/mark-clean.png\"></p>\n<h3 id=\"4-2-复制算法\"><a href=\"#4-2-复制算法\" class=\"headerlink\" title=\"4.2 复制算法\"></a>4.2 复制算法</h3><p><img src=\"/images/GC/copy.png\"></p>\n<h3 id=\"4-3-标记压缩\"><a href=\"#4-3-标记压缩\" class=\"headerlink\" title=\"4.3 标记压缩\"></a>4.3 标记压缩</h3><p><img src=\"/images/GC/mark-compress.png\"></p>\n<h2 id=\"五、参数设置\"><a href=\"#五、参数设置\" class=\"headerlink\" title=\"五、参数设置\"></a>五、参数设置</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:+UseG1GC</td>\n<td>JDK8需要设置</td>\n</tr>\n<tr>\n<td>-XX:G1HeapRegionSize</td>\n<td>设置每个Region的大小。值是2的幂,范围是1MB到32MB之间</td>\n</tr>\n<tr>\n<td>-XX:MaxGCPauseMillis</td>\n<td>期望达到的最大GC停顿时间指标,默认200ms</td>\n</tr>\n<tr>\n<td>-XX:ParallelGCThread:</td>\n<td>垃圾回收线程,最多为8,STW时</td>\n</tr>\n<tr>\n<td>-XX:ConcGCThreads</td>\n<td>并发标记线程数,一般&#x3D;ParallelGCThreads&#x2F;4</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"参数设置参考\"><a href=\"#参数设置参考\" class=\"headerlink\" title=\"参数设置参考\"></a>参数设置参考</h4><p>由于是传统ERP项目，存量业务和大对象很多，所以Xmx设置的也比较大： </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms6g -Xmx12g -XX:+UseG1GC -XX:ParallelGCThreads=8 -XX:ConcGCThreads=8 -Xss512k -XX:MetaspaceSize=768m -XX:MaxMetaspaceSize=2g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/<span class=\"built_in\">log</span>/erp-%t.hprof -XX:MaxDirectMemorySize=256m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/data/<span class=\"built_in\">log</span>/erp-gc-%t.log</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>G1垃圾回收期入门<br><a href=\"https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html\">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a><br>G1详解<br><a href=\"https://juejin.cn/post/7010034105165299725\">https://juejin.cn/post/7010034105165299725</a><br>最清晰易懂的G1<br><a href=\"https://segmentfault.com/a/1190000039411521\">https://segmentfault.com/a/1190000039411521</a></p>\n","site":{"data":{}},"excerpt":"<p>在JDK9之后JVM默认使用G1(Garbage-First, 垃圾优先)收集器进行垃圾回收。G1是一款分代的 (generational)，增量的 (incremental)，并行的 (parallel)，移动式（evacuating）的，软实时的垃圾回收器。其最大特点是用Region代替传统分代模型，分代成为逻辑上的概念；建立了可预测的停顿时间模型，让暂停时间可配置。从实践结果来看，它能及时有效的回收大对象，增加吞吐量，避免内存碎片，保障程序的长久运行。</p>","more":"<h2 id=\"一、内存模型对比\"><a href=\"#一、内存模型对比\" class=\"headerlink\" title=\"一、内存模型对比\"></a>一、内存模型对比</h2><p>传统的垃圾收集器（串行、并行、CMS）都将堆结构分为三个部分：年轻代、老年代和固定内存大小的永久代</p>\n<ul>\n<li>传统收集器内存结构<br><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png\"></li>\n</ul>\n<p>G1中的堆被划分为N个Region，每个region内内存连续，其中一部分被分配为传统的角色(eden、survivor、old)，但它们不是固定的位置和大小，这给内存分配提供了极大的灵活性。</p>\n<ul>\n<li>G1内存结构<br><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png\"></li>\n</ul>\n<h2 id=\"二、GC步骤\"><a href=\"#二、GC步骤\" class=\"headerlink\" title=\"二、GC步骤\"></a>二、GC步骤</h2><p>G1中有两种回收模式：</p>\n<ul>\n<li>年轻代垃圾回收（Young GC）</li>\n<li>混合垃圾回收（Mixed GC）</li>\n</ul>\n<h3 id=\"2-1-年轻代GC\"><a href=\"#2-1-年轻代GC\" class=\"headerlink\" title=\"2.1 年轻代GC\"></a>2.1 年轻代GC</h3><p>年轻代GC是只选择年轻代区域（Eden&#x2F;Survivor）进入回收集合（Collection Set，简称CSet）进行回收的模式。年轻代GC的过程和其他的分代回收器差不多，新创建的对象分配至Eden区域，然后将标记存活的对象移动至Survivor区，达到晋升年龄的就晋升到老年代区域，然后清空原区域（不过这里可没有年轻代复制算法中两个Survivor的交换过程）。</p>\n<ol>\n<li>G1在遵循GC暂停时间的基础上，选择最大年轻代Region数(CSSet)</li>\n<li>根扫描(Root Scanning)</li>\n<li>RememberedSet扫描(RememberedSet简称RSet,会记录跨代引用的关系)</li>\n<li>移动，遍历上面的标记栈，将栈内的所有所有的对象移动(复制)至Survivor区域</li>\n</ol>\n<p>年轻代GC图示：<br><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png\"></p>\n<p><img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png\"></p>\n<h3 id=\"2-2-混合GC\"><a href=\"#2-2-混合GC\" class=\"headerlink\" title=\"2.2 混合GC\"></a>2.2 混合GC</h3><p>混合GC会选择所有年轻代区域(Eden&#x2F;Survivor,最大年轻代分区数)和部分老年代区域进去回收集合进行回收的模式。年轻代区域对象移动到Survivor区，老年代区域移动到老年代区域。</p>\n<ol>\n<li><p>初始标记  </p>\n<blockquote>\n<p>这个是捎带在年轻代GC完成的<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png\"></p>\n</blockquote>\n</li>\n<li><p>并发标记</p>\n<blockquote>\n<p>并发标记的目的是标记存活对象，为移动过程做准备。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png\"></p>\n</blockquote>\n</li>\n<li><p>再次标记</p>\n<blockquote>\n<p>由于应用程序持续进行,需要修正上一次的标记结果。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB)。此时，所有区域的活性都被计算出来了。<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png\"></p>\n</blockquote>\n</li>\n<li><p>复制清理阶段</p>\n<blockquote>\n<p>G1 选择“活跃度”最低的区域，即可以收集最快的区域。然后与年轻的GC同时收集这些区域<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png\"></p>\n</blockquote>\n</li>\n<li><p>最终清理阶段</p>\n<blockquote>\n<p>所选择的区域都被复制，然后压缩<br> <img src=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png\"></p>\n</blockquote>\n</li>\n</ol>\n<p><strong>混合GC总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>是否STW</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>初始标记</td>\n<td>是</td>\n<td>捎带在年轻代GC完成</td>\n</tr>\n<tr>\n<td>根区域扫描</td>\n<td>否</td>\n<td>扫描幸存者区域以查找对老年代的引用</td>\n</tr>\n<tr>\n<td>并行标记</td>\n<td>否</td>\n<td>查找整个堆上的活动对象</td>\n</tr>\n<tr>\n<td>再次标记</td>\n<td>是</td>\n<td>遗漏的再标记一次</td>\n</tr>\n<tr>\n<td>清理</td>\n<td>是</td>\n<td>对活动对象和完全自由区域执行记帐;擦洗RSet;重置空区域并将其返回到可用列表</td>\n</tr>\n<tr>\n<td>复制</td>\n<td>是</td>\n<td>疏散或复制活动对象到未使用区域</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、GC日志\"><a href=\"#三、GC日志\" class=\"headerlink\" title=\"三、GC日志\"></a>三、GC日志</h2><p>G1 GC的垃圾回收过程主要包括如下三个环节：<br>年轻代GC (Young GC)、老年代并发标记过程 (Concurrent Marking)、混合回收(Mixed GC)。并发标记是全局的，和回收过程是两个阶段。</p>\n<h3 id=\"年轻代GC日志\"><a href=\"#年轻代GC日志\" class=\"headerlink\" title=\"年轻代GC日志\"></a>年轻代GC日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//[GC pause (G1 Evacuation Pause) (young) 代表完全年轻代回收</span><br><span class=\"line\">// 0.0182341 secs 是本次GC的暂停时间</span><br><span class=\"line\">0.184: [GC pause (G1 Evacuation Pause) (young), 0.0182341 secs 是本次GC的暂停时间]</span><br><span class=\"line\">// 并行GC线程，一共有8个</span><br><span class=\"line\">   [Parallel Time: 16.7 ms, GC Workers: 8]</span><br><span class=\"line\">      /*这一行信息说明的是这8个线程开始的时间，Min表示最早开始的线程时间，Avg表示平均开始时间，Max表示的是最晚开始时间，Diff为最早和最晚的时间差。这个值越大说明线程启动时间越不均衡。线程启动的时间依赖于GC进入安全点的情况。关于安全点可以参考后文的介绍。*/</span><br><span class=\"line\">      [GC Worker Start (ms):  184.2  184.2  184.2  184.3  184.3  184.4  186.1  186.1</span><br><span class=\"line\">       Min: 184.2, Avg: 184.7, Max: 186.1, Diff: 1.9]</span><br><span class=\"line\">      /*根处理的时间，这个时间包含了所有强根的时间，分为Java根，分别为Thread、JNI、CLDG；和JVM根下面的StringTable、Universe、JNI Handles、ObjectSynchronizer、FlatProfiler、Management、SystemDictionary、JVMTI */</span><br><span class=\"line\">      [Ext Root Scanning (ms):  0.3  0.2  0.2  0.1  0.1  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.3, Sum: 0.8]</span><br><span class=\"line\">         /*Java线程处理时间，主要是线程栈。这个时间包含了根直接引用对象的复制时间，如果根超级大，这个时间可能会增加 */</span><br><span class=\"line\">         [Thread Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">         [StringTable Roots (ms):  0.0  0.1  0.1  0.1  0.1  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]</span><br><span class=\"line\">         [Universe Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [JNI Handles Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [ObjectSynchronizer Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [FlatProfiler Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Management Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [SystemDictionary Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [CLDG Roots (ms):  0.3  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.3, Diff: 0.3, Sum: 0.3]</span><br><span class=\"line\">         [JVMTI Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">       // CodeCache Roots实际上是在处理Rset的时候的统计值，它包含下面的</span><br><span class=\"line\">       // UpdateRS，ScanRS和Code Root Scanning</span><br><span class=\"line\">         [CodeCache Roots (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2</span><br><span class=\"line\">          Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.6]</span><br><span class=\"line\">         [CM RefProcessor Roots (ms):  0.0</span><br><span class=\"line\">         0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Wait For Strong CLD (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Weak CLD Roots (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [SATB Filtering (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">       // 这个就是GC线程更新RSet的时间花费，注意这里的时间和我们在Refine里面处理RSet</span><br><span class=\"line\">       // 的时间没有关系，因为它们是不同的线程处理</span><br><span class=\"line\">       [Update RS (ms):  5.0  3.9  2.2  3.3  2.1  2.2  0.6  2.2</span><br><span class=\"line\">        Min: 0.6, Avg: 2.7, Max: 5.0, Diff: 4.4, Sum: 21.5]</span><br><span class=\"line\">          // 这里就是GC线程处理的白区中的dcq个数</span><br><span class=\"line\">         [Processed Buffers:  8  8  7  8  8  7  2  4</span><br><span class=\"line\">          Min: 2, Avg: 6.5, Max: 8, Diff: 6, Sum: 52]</span><br><span class=\"line\">      // 扫描RSet找到被引用的对象</span><br><span class=\"line\">      [Scan RS (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">      [Code Root Scanning (ms):  0.0  0.0  0.0  0.0  0.0  0.1  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]</span><br><span class=\"line\">      // 这个就是所有活着的对象（除了强根直接引用的对象，在Java根处理时会直接复制）复制</span><br><span class=\"line\">      // 到新的分区花费的时间。从这里也可以看出复制基本上是最花费时间的操作。        </span><br><span class=\"line\">      [Object Copy (ms):  11.3  12.5  14.2  13.1  14.3  14.2  14.2  12.5</span><br><span class=\"line\">       Min: 11.3, Avg: 13.3, Max: 14.3, Diff: 3.0, Sum: 106.3]</span><br><span class=\"line\">      // GC线程结束的时间信息。</span><br><span class=\"line\">      [Termination (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class=\"line\">         [Termination Attempts:  1  1  1  1  1  1  1  1</span><br><span class=\"line\">          Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 8]</span><br><span class=\"line\">      // 这个是并行处理时其他处理所花费的时间，通常是由于JVM析构释放资源等</span><br><span class=\"line\">      [GC Worker Other (ms):  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">       Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">      // 并行GC花费的总体时间</span><br><span class=\"line\">      [GC Worker Total (ms):  16.6  16.6  16.6  16.5  16.5  16.4  14.7  14.7</span><br><span class=\"line\">       Min: 14.7, Avg: 16.1, Max: 16.6, Diff: 1.9, Sum: 128.7]</span><br><span class=\"line\">      // GC线程结束的时间信息</span><br><span class=\"line\">      [GC Worker End (ms):  200.8  200.8  200.8  200.8  200.8  200.8  200.8  200.8</span><br><span class=\"line\">       Min: 200.8, Avg: 200.8, Max: 200.8, Diff: 0.0]</span><br><span class=\"line\">    // 下面是其他任务部分。</span><br><span class=\"line\">    // 代码扫描属于并行执行部分，包含了代码的调整和回收时间</span><br><span class=\"line\">    [Code Root Fixup: 0.0 ms]   </span><br><span class=\"line\">    [Code Root Purge: 0.0 ms]</span><br><span class=\"line\">    // 清除卡表的时间</span><br><span class=\"line\">    [Clear CT: 0.1 ms]</span><br><span class=\"line\">    [Other: 1.5 ms]</span><br><span class=\"line\">      // 选择CSet的时间，YGC通常是0</span><br><span class=\"line\">      [Choose CSet: 0.0 ms]</span><br><span class=\"line\">      // 引用处理的时间，这个时间是发现哪些引用对象可以清除，这个是可以并行处理的</span><br><span class=\"line\">      [Ref Proc: 1.1 ms]</span><br><span class=\"line\">      // 引用重新激活</span><br><span class=\"line\">      [Ref Enq: 0.2 ms]</span><br><span class=\"line\">      // 重构RSet花费的时间</span><br><span class=\"line\">      [Redirty Cards: 0.1 ms]</span><br><span class=\"line\">         [Parallel Redirty:  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</span><br><span class=\"line\">          Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">         [Redirtied Cards:  8118  7583  6892  4496  0  0  0  0</span><br><span class=\"line\">          Min: 0, Avg: 3386.1, Max: 8118, Diff: 8118, Sum: 27089]</span><br><span class=\"line\">          // 这个信息是是可以并行处理的，这里是线程重构RSet的数目</span><br><span class=\"line\">       // 大对象处理时间</span><br><span class=\"line\">      [Humongous Register: 0.0 ms]</span><br><span class=\"line\">         [Humongous Total: 2]</span><br><span class=\"line\">          // 这里说明有2个大对象</span><br><span class=\"line\">         [Humongous Candidate: 0]</span><br><span class=\"line\">          // 可回收的大对象0个</span><br><span class=\"line\">      // 如果有大对象要回收，回收花费的时间，回收的个数</span><br><span class=\"line\">      [Humongous Reclaim: 0.0 ms]</span><br><span class=\"line\">         [Humongous Reclaimed: 0]</span><br><span class=\"line\">      // 释放CSet中的分区花费的时间，有新生代的信息和老生代的信息。</span><br><span class=\"line\">      [Free CSet: 0.0 ms]</span><br><span class=\"line\">         [Young Free CSet: 0.0 ms]</span><br><span class=\"line\">         [Non-Young Free CSet: 0.0 ms]</span><br><span class=\"line\">    // GC结束后Eden从15M变成0，下一次使用的空间为21M，S从2M变成3M，整个堆从</span><br><span class=\"line\">    // 23.7M变成20M</span><br><span class=\"line\">    [Eden: 15.0M(15.0M)-&gt;0.0B(21.0M) Survivors: 2048.0K-&gt;3072.0K </span><br><span class=\"line\">     Heap: 23.7M(256.0M)-&gt;20.0M(256.0M)]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"并发标记日志\"><a href=\"#并发标记日志\" class=\"headerlink\" title=\"并发标记日志\"></a>并发标记日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//并发标记 - 初始标记阶段，在年轻代GC中完成</span><br><span class=\"line\">100.070: [GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0751469 secs]</span><br><span class=\"line\">  [Parallel Time: 74.7 ms, GC Workers: 8]</span><br><span class=\"line\">    [GC Worker Start (ms): Min: 100070.4, Avg: 100070.5, Max: 100070.6, Diff: </span><br><span class=\"line\">      0.1]</span><br><span class=\"line\">    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.2, Max: 0.3, Diff: 0.2, Sum: </span><br><span class=\"line\">      1.6]</span><br><span class=\"line\">    [Update RS (ms): Min: 0.6, Avg: 1.1, Max: 1.5, Diff: 0.9, Sum: 8.9]</span><br><span class=\"line\">       [Processed Buffers: Min: 1, Avg: 1.6, Max: 4, Diff: 3, Sum: 13]</span><br><span class=\"line\">    [Scan RS (ms): Min: 1.0, Avg: 1.4, Max: 1.9, Diff: 0.9, Sum: 10.8]</span><br><span class=\"line\">    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: </span><br><span class=\"line\">      0.0]</span><br><span class=\"line\">    [Object Copy (ms): Min: 71.5, Avg: 71.5, Max: 71.6, Diff: 0.1, Sum: 572.1]</span><br><span class=\"line\">    [Termination (ms): Min: 0.3, Avg: 0.3, Max: 0.4, Diff: 0.1, Sum: 2.6]</span><br><span class=\"line\">       [Termination Attempts: Min: 1382, Avg: 1515.5, Max: 1609, Diff: 227, </span><br><span class=\"line\">         Sum: 12124]</span><br><span class=\"line\">    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2]</span><br><span class=\"line\">    [GC Worker Total (ms): Min: 74.5, Avg: 74.5, Max: 74.6, Diff: 0.1, Sum: </span><br><span class=\"line\">      596.3]</span><br><span class=\"line\">    [GC Worker End (ms): Min: 100145.1, Avg: 100145.1, Max: 100145.1, Diff: </span><br><span class=\"line\">      0.0]</span><br><span class=\"line\">  [Code Root Fixup: 0.0 ms]</span><br><span class=\"line\">  [Code Root Purge: 0.0 ms]</span><br><span class=\"line\">  [Clear CT: 0.1 ms]</span><br><span class=\"line\">  [Other: 0.4 ms]</span><br><span class=\"line\">    [Choose CSet: 0.0 ms]</span><br><span class=\"line\">    [Ref Proc: 0.1 ms]</span><br><span class=\"line\">    [Ref Enq: 0.0 ms]</span><br><span class=\"line\">    [Redirty Cards: 0.1 ms]</span><br><span class=\"line\">    [Humongous Register: 0.0 ms]</span><br><span class=\"line\">    [Humongous Reclaim: 0.0 ms]</span><br><span class=\"line\">    [Free CSet: 0.0 ms]</span><br><span class=\"line\">  [Eden: 23.0M(23.0M)-&gt;0.0B(14.0M) Survivors: 4096.0K-&gt;4096.0K Heap: 84.5M</span><br><span class=\"line\">    (128.0M)-&gt;86.5M(128.0M)]</span><br><span class=\"line\">[Times: user=0.63 sys=0.00, real=0.08 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">// 把YHR中Survivor分区作为根，开始并发标记根扫描</span><br><span class=\"line\">100.146: [GC concurrent-root-region-scan-start]</span><br><span class=\"line\">// 并发标记根扫描结束，花费了0.0196297，注意扫描和Mutator是并发进行，同时有多个线程并行</span><br><span class=\"line\">100.165: [GC concurrent-root-region-scan-end, 0.0196297 secs]</span><br><span class=\"line\">// 开始并发标记子阶段，这里从所有的根引用：包括Survivor和强根如栈等出发，对整个堆进行标记</span><br><span class=\"line\">100.165: [GC concurrent-mark-start]</span><br><span class=\"line\">// 标记结束，花费0.08848s</span><br><span class=\"line\">100.254: [GC concurrent-mark-end, 0.0884800 secs]</span><br><span class=\"line\">// 这里是再标记子阶段，包括再标记、引用处理、类卸载处理信息</span><br><span class=\"line\">100.254: [GC remark 100.254: [Finalize Marking, 0.0002228 secs] 100.254: </span><br><span class=\"line\">  [GC ref-proc, 0.0001515 secs] 100.254: [Unloading, 0.0004694 secs], </span><br><span class=\"line\">  0.0011610 secs]</span><br><span class=\"line\">  [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class=\"line\">// 清除处理，这里的清除仅仅回收整个分区中的垃圾</span><br><span class=\"line\">// 这里还会调整RSet，以减轻后续GC中RSet根的处理时间</span><br><span class=\"line\">100.255: [GC cleanup 86M-&gt;86M(128M), 0.0005376 secs]</span><br><span class=\"line\">  [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"混合GC日志\"><a href=\"#混合GC日志\" class=\"headerlink\" title=\"混合GC日志\"></a>混合GC日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 混合回收Mixed GC其实和YGC的日志类似，能看到GC pause(G1EvacuationPause)(mixed)这样的信息</span><br><span class=\"line\">// 日志分析参考Y年轻代GC。</span><br><span class=\"line\">  122.132: [GC pause (G1 Evacuation Pause) (mixed), 0.0106092 secs]</span><br><span class=\"line\">  [Parallel Time: 9.8 ms, GC Workers: 8]</span><br><span class=\"line\">    [GC Worker Start (ms): Min: 122131.9, Avg: 122132.0, Max: 122132.0, </span><br><span class=\"line\">      Diff: 0.1]</span><br><span class=\"line\">    [Ext Root Scanning (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.7]</span><br><span class=\"line\">    [Update RS (ms): Min: 0.5, Avg: 0.7, Max: 0.9, Diff: 0.4, Sum: 5.4]</span><br><span class=\"line\">      [Processed Buffers: Min: 1, Avg: 1.8, Max: 3, Diff: 2, Sum: 14]</span><br><span class=\"line\">    [Scan RS (ms): Min: 1.0, Avg: 1.3, Max: 1.5, Diff: 0.5, Sum: 10.4]</span><br><span class=\"line\">    [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: </span><br><span class=\"line\">      0.0]</span><br><span class=\"line\">    [Object Copy (ms): Min: 7.5, Avg: 7.6, Max: 7.7, Diff: 0.2, Sum: 60.9]</span><br><span class=\"line\">    [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">      [Termination Attempts: Min: 92, Avg: 105.1, Max: 121, Diff: 29, Sum: 841]</span><br><span class=\"line\">    [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class=\"line\">    [GC Worker Total (ms): Min: 9.7, Avg: 9.7, Max: 9.8, Diff: 0.1, Sum: 77.6]</span><br><span class=\"line\">    [GC Worker End (ms): Min: 122141.7, Avg: 122141.7, Max: 122141.7, Diff: 0.0]</span><br><span class=\"line\">  [Code Root Fixup: 0.0 ms]</span><br><span class=\"line\">  [Code Root Purge: 0.0 ms]</span><br><span class=\"line\">  [Clear CT: 0.2 ms]</span><br><span class=\"line\">  [Other: 0.7 ms]</span><br><span class=\"line\">    [Choose CSet: 0.0 ms]</span><br><span class=\"line\">    [Ref Proc: 0.1 ms]</span><br><span class=\"line\">    [Ref Enq: 0.0 ms]</span><br><span class=\"line\">    [Redirty Cards: 0.5 ms]</span><br><span class=\"line\">    [Humongous Register: 0.0 ms]</span><br><span class=\"line\">    [Humongous Reclaim: 0.0 ms]</span><br><span class=\"line\">    [Free CSet: 0.0 ms]</span><br><span class=\"line\">  [Eden: 3072.0K(3072.0K)-&gt;0.0B(5120.0K) Survivors: 3072.0K-&gt;1024.0K </span><br><span class=\"line\">    Heap: 105.5M(128.0M)-&gt;104.0M(128.0M)]</span><br><span class=\"line\">[Times: user=0.00 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"四、GC算法\"><a href=\"#四、GC算法\" class=\"headerlink\" title=\"四、GC算法\"></a>四、GC算法</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>分代</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标记清除(Mark-Sweep)</td>\n<td>年轻代</td>\n<td>效率低，产生内存碎片</td>\n</tr>\n<tr>\n<td>复制(Copying)</td>\n<td>老年代</td>\n<td>效率高，空间利用率低</td>\n</tr>\n<tr>\n<td>标记压缩(Mark-Compact)</td>\n<td>老年代</td>\n<td>针对老年代对象特征优化</td>\n</tr>\n<tr>\n<td>分代收集</td>\n<td>年轻代使用复制，老年代使用标记压缩</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"4-1-标记清除\"><a href=\"#4-1-标记清除\" class=\"headerlink\" title=\"4.1 标记清除\"></a>4.1 标记清除</h3><p><img src=\"/images/GC/mark-clean.png\"></p>\n<h3 id=\"4-2-复制算法\"><a href=\"#4-2-复制算法\" class=\"headerlink\" title=\"4.2 复制算法\"></a>4.2 复制算法</h3><p><img src=\"/images/GC/copy.png\"></p>\n<h3 id=\"4-3-标记压缩\"><a href=\"#4-3-标记压缩\" class=\"headerlink\" title=\"4.3 标记压缩\"></a>4.3 标记压缩</h3><p><img src=\"/images/GC/mark-compress.png\"></p>\n<h2 id=\"五、参数设置\"><a href=\"#五、参数设置\" class=\"headerlink\" title=\"五、参数设置\"></a>五、参数设置</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:+UseG1GC</td>\n<td>JDK8需要设置</td>\n</tr>\n<tr>\n<td>-XX:G1HeapRegionSize</td>\n<td>设置每个Region的大小。值是2的幂,范围是1MB到32MB之间</td>\n</tr>\n<tr>\n<td>-XX:MaxGCPauseMillis</td>\n<td>期望达到的最大GC停顿时间指标,默认200ms</td>\n</tr>\n<tr>\n<td>-XX:ParallelGCThread:</td>\n<td>垃圾回收线程,最多为8,STW时</td>\n</tr>\n<tr>\n<td>-XX:ConcGCThreads</td>\n<td>并发标记线程数,一般&#x3D;ParallelGCThreads&#x2F;4</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"参数设置参考\"><a href=\"#参数设置参考\" class=\"headerlink\" title=\"参数设置参考\"></a>参数设置参考</h4><p>由于是传统ERP项目，存量业务和大对象很多，所以Xmx设置的也比较大： </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms6g -Xmx12g -XX:+UseG1GC -XX:ParallelGCThreads=8 -XX:ConcGCThreads=8 -Xss512k -XX:MetaspaceSize=768m -XX:MaxMetaspaceSize=2g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/<span class=\"built_in\">log</span>/erp-%t.hprof -XX:MaxDirectMemorySize=256m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/data/<span class=\"built_in\">log</span>/erp-gc-%t.log</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>G1垃圾回收期入门<br><a href=\"https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html\">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a><br>G1详解<br><a href=\"https://juejin.cn/post/7010034105165299725\">https://juejin.cn/post/7010034105165299725</a><br>最清晰易懂的G1<br><a href=\"https://segmentfault.com/a/1190000039411521\">https://segmentfault.com/a/1190000039411521</a></p>"},{"title":"Gradle入门","date":"2023-04-11T07:10:05.000Z","_content":"现在越来越多的开源项目都使用gradle来构建，而且基于gradle灵活的语法和增量构建等特性，在大型项目构建的时候大大节约了时间，实乃高效干活的利器，不得不学起来~\n<!--more-->\n\n\n# 1. Gradle与 Maven的比较  \n> Gradle和Maven两种构建方式存在一些根本差异。 Gradle基于任务依赖关系图-其中任务就是工作，而Maven是基于固定的过程和线性模型。使用Maven构建项目时，目标将附加到项目阶段，目标的作用类似于Gradle的任务，即“完成任务的事物”。  \n>\n> 1.1 在性能方面，两者都允许多模块构建并行运行。但是，Gradle允许增量构建，因为它检查是否更新了哪些任务。如果是这样，则不执行任务，从而使构建时间大大缩短。Gradle上其他出色的性能功能包括：  \n>- Java类的增量编译\n>- 防止反编译\n>- 对增量子任务使用API\n>- 编译器守护程序加快编译速度  \n> \n> 1.2 在管理依赖项时，Gradle和Maven都可以处理动态和传递性依赖项，以使用第三方依赖项缓存，并读取POM元数据格式。还可以通过中央版本控制定义声明库版本并强制执行中央版本控制。两者都从其artifact 仓库下载可传递依赖项。Maven具有Maven Central，而Gradle具有JCenter，也可以定义自己的私人公司存储库。如果需要多个依赖项，Maven可以同时下载它们。\n\n\n\n# 2. 安装与配置  \n## 2.1 安装\n从[安装目录](https://services.gradle.org/distributions/)找一个不那么早的下载，然后配置环境变量：  \n`GRADLE_HOME`,然后`%GRADLE_HOME%\\bin`目录加入到path  \n`gradle -v` 验证  \n\n## 2.2 配置镜像\ninit.d文件夹下新增 **init.gradle** 设置国内代理\n``` bash\nallprojects {\n    repositories {\n        maven { url 'file://D:/maven_repo'}\n        mavenLocal()\n        maven { name \"Alibaba\" ; url \"https://maven.aliyun.com/repository/public\" }\n        maven { name \"Bstek\" ; url \"http://nexus.bsdn.org/content/groups/public/\"}\n        mavenCentral()\n    }\n    buildscript { \n        repositories { \n            maven { name \"Alibaba\" ; url 'https://maven.aliyun.com/repository/public'}\n            maven { name \"Bstek\" ; url 'http://nexus.bsdn.org/content/groups/public/' }\n            maven { name \"M2\" ; url 'https://plugins.gradle.org/m2/'}\n        }\n    }\n}\n```\n**注意：** 这里有个指向本地目录是gradle本地仓库，其实也可以是maven本地仓库  \n\n\n## 2.3 IDEA配置与wrapper  \n如果我们直接使用IDEA新建一个用gradle构建的项目，会发现它的结构有点不一样：  \n``` \n-src\n-gradle\n\t-warpper\n\t\t-gradle-wrapper.jar\n\t\t-gradle-wrapper.properties\n-build.gradle #构建脚本，类似pom.xml\n-gradlew #Linux系统的包装启动脚本\n-gradlew.bat #windows系统的包装启动脚本\n-settings.gradle #定义项目信息\n```\nwarpper文件夹其实是对gradle的一层包装，为了：  \n1. 在未安装gradle的环境运行  \n2. gradle的发展太快了，有时候需要切换版本，也可以使用gradlew代替。这样就使用的是附带jar的版本了。  \ngradle-wrapper.properties\n``` ini\n# Gradle解包后存储的父目录\ndistributionBase=GRADLE_USER_HOME\n# 指定目录的子目录\ndistributionPath=wrapper/dists\n# Gradle指定版本的压缩包下载地址\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-7.6.1-bin.zip\n# Gradle压缩包下载后存储父目录\nzipStoreBase=GRADLE_USER_HOME\n# Gradle压缩包下载后存储子目录\nzipStorePath=wrapper/dists\n```\n`GRADLE_USER_HOME`类似maven的本地仓库，如果不指定一般会放到用户\\.gradle目录，C盘估计又要爆炸了。这里可以指定为maven的本地仓库目录，然后设置到环境变量。虽然它并不会使用maven的缓存（两者缓存格式不一致）。  \n\n以下是gradlew工作流程：  \n![gradlew工作流程](https://docs.gradle.org/current/userguide/img/wrapper-workflow.png)  \n\n以下是IDEA的配置截图\n![](/images/gradle-idea-config.png)  \n\n# 3. Gradle使用  \n常用gradle指令,与maven类似  \n```  \n# 构建项目\ngradle build\n# 清空build目录\ngradle clean\n# 编译测试代码，生成测试报告\ngradle test\n# 跳过测试构建\ngradle build-x test\n```\nIDEA自带的Gradle集成了这些常见命令，另外还对应用也做了支持：  \n比如这里可以直接Run应用的Main：  \n![](/images/gradle-command.png)\n\n---\n---\n关于gradle自定义任务及groovy语言，以后需要再深入研究吧。。\n\nGroovy语法参考：   \nhttp://www.groovy-lang.org/testing.html#_introduction\n\ngradle_wrapper更多：  \nhttps://docs.gradle.org/current/userguide/gradle_wrapper.html#gradle_wrapper\n\n","source":"_posts/Gradle入门.md","raw":"---\ntitle: Gradle入门\ndate: 2023-04-11 15:10:05\ntags: gradle\ncategories: Spring+\n---\n现在越来越多的开源项目都使用gradle来构建，而且基于gradle灵活的语法和增量构建等特性，在大型项目构建的时候大大节约了时间，实乃高效干活的利器，不得不学起来~\n<!--more-->\n\n\n# 1. Gradle与 Maven的比较  \n> Gradle和Maven两种构建方式存在一些根本差异。 Gradle基于任务依赖关系图-其中任务就是工作，而Maven是基于固定的过程和线性模型。使用Maven构建项目时，目标将附加到项目阶段，目标的作用类似于Gradle的任务，即“完成任务的事物”。  \n>\n> 1.1 在性能方面，两者都允许多模块构建并行运行。但是，Gradle允许增量构建，因为它检查是否更新了哪些任务。如果是这样，则不执行任务，从而使构建时间大大缩短。Gradle上其他出色的性能功能包括：  \n>- Java类的增量编译\n>- 防止反编译\n>- 对增量子任务使用API\n>- 编译器守护程序加快编译速度  \n> \n> 1.2 在管理依赖项时，Gradle和Maven都可以处理动态和传递性依赖项，以使用第三方依赖项缓存，并读取POM元数据格式。还可以通过中央版本控制定义声明库版本并强制执行中央版本控制。两者都从其artifact 仓库下载可传递依赖项。Maven具有Maven Central，而Gradle具有JCenter，也可以定义自己的私人公司存储库。如果需要多个依赖项，Maven可以同时下载它们。\n\n\n\n# 2. 安装与配置  \n## 2.1 安装\n从[安装目录](https://services.gradle.org/distributions/)找一个不那么早的下载，然后配置环境变量：  \n`GRADLE_HOME`,然后`%GRADLE_HOME%\\bin`目录加入到path  \n`gradle -v` 验证  \n\n## 2.2 配置镜像\ninit.d文件夹下新增 **init.gradle** 设置国内代理\n``` bash\nallprojects {\n    repositories {\n        maven { url 'file://D:/maven_repo'}\n        mavenLocal()\n        maven { name \"Alibaba\" ; url \"https://maven.aliyun.com/repository/public\" }\n        maven { name \"Bstek\" ; url \"http://nexus.bsdn.org/content/groups/public/\"}\n        mavenCentral()\n    }\n    buildscript { \n        repositories { \n            maven { name \"Alibaba\" ; url 'https://maven.aliyun.com/repository/public'}\n            maven { name \"Bstek\" ; url 'http://nexus.bsdn.org/content/groups/public/' }\n            maven { name \"M2\" ; url 'https://plugins.gradle.org/m2/'}\n        }\n    }\n}\n```\n**注意：** 这里有个指向本地目录是gradle本地仓库，其实也可以是maven本地仓库  \n\n\n## 2.3 IDEA配置与wrapper  \n如果我们直接使用IDEA新建一个用gradle构建的项目，会发现它的结构有点不一样：  \n``` \n-src\n-gradle\n\t-warpper\n\t\t-gradle-wrapper.jar\n\t\t-gradle-wrapper.properties\n-build.gradle #构建脚本，类似pom.xml\n-gradlew #Linux系统的包装启动脚本\n-gradlew.bat #windows系统的包装启动脚本\n-settings.gradle #定义项目信息\n```\nwarpper文件夹其实是对gradle的一层包装，为了：  \n1. 在未安装gradle的环境运行  \n2. gradle的发展太快了，有时候需要切换版本，也可以使用gradlew代替。这样就使用的是附带jar的版本了。  \ngradle-wrapper.properties\n``` ini\n# Gradle解包后存储的父目录\ndistributionBase=GRADLE_USER_HOME\n# 指定目录的子目录\ndistributionPath=wrapper/dists\n# Gradle指定版本的压缩包下载地址\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-7.6.1-bin.zip\n# Gradle压缩包下载后存储父目录\nzipStoreBase=GRADLE_USER_HOME\n# Gradle压缩包下载后存储子目录\nzipStorePath=wrapper/dists\n```\n`GRADLE_USER_HOME`类似maven的本地仓库，如果不指定一般会放到用户\\.gradle目录，C盘估计又要爆炸了。这里可以指定为maven的本地仓库目录，然后设置到环境变量。虽然它并不会使用maven的缓存（两者缓存格式不一致）。  \n\n以下是gradlew工作流程：  \n![gradlew工作流程](https://docs.gradle.org/current/userguide/img/wrapper-workflow.png)  \n\n以下是IDEA的配置截图\n![](/images/gradle-idea-config.png)  \n\n# 3. Gradle使用  \n常用gradle指令,与maven类似  \n```  \n# 构建项目\ngradle build\n# 清空build目录\ngradle clean\n# 编译测试代码，生成测试报告\ngradle test\n# 跳过测试构建\ngradle build-x test\n```\nIDEA自带的Gradle集成了这些常见命令，另外还对应用也做了支持：  \n比如这里可以直接Run应用的Main：  \n![](/images/gradle-command.png)\n\n---\n---\n关于gradle自定义任务及groovy语言，以后需要再深入研究吧。。\n\nGroovy语法参考：   \nhttp://www.groovy-lang.org/testing.html#_introduction\n\ngradle_wrapper更多：  \nhttps://docs.gradle.org/current/userguide/gradle_wrapper.html#gradle_wrapper\n\n","slug":"Gradle入门","published":1,"updated":"2024-02-18T08:23:45.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyo000aqwvd1y9v1f0n","content":"<p>现在越来越多的开源项目都使用gradle来构建，而且基于gradle灵活的语法和增量构建等特性，在大型项目构建的时候大大节约了时间，实乃高效干活的利器，不得不学起来~</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"1-Gradle与-Maven的比较\"><a href=\"#1-Gradle与-Maven的比较\" class=\"headerlink\" title=\"1. Gradle与 Maven的比较\"></a>1. Gradle与 Maven的比较</h1><blockquote>\n<p>Gradle和Maven两种构建方式存在一些根本差异。 Gradle基于任务依赖关系图-其中任务就是工作，而Maven是基于固定的过程和线性模型。使用Maven构建项目时，目标将附加到项目阶段，目标的作用类似于Gradle的任务，即“完成任务的事物”。  </p>\n<p>1.1 在性能方面，两者都允许多模块构建并行运行。但是，Gradle允许增量构建，因为它检查是否更新了哪些任务。如果是这样，则不执行任务，从而使构建时间大大缩短。Gradle上其他出色的性能功能包括：  </p>\n<ul>\n<li>Java类的增量编译</li>\n<li>防止反编译</li>\n<li>对增量子任务使用API</li>\n<li>编译器守护程序加快编译速度</li>\n</ul>\n<p>1.2 在管理依赖项时，Gradle和Maven都可以处理动态和传递性依赖项，以使用第三方依赖项缓存，并读取POM元数据格式。还可以通过中央版本控制定义声明库版本并强制执行中央版本控制。两者都从其artifact 仓库下载可传递依赖项。Maven具有Maven Central，而Gradle具有JCenter，也可以定义自己的私人公司存储库。如果需要多个依赖项，Maven可以同时下载它们。</p>\n</blockquote>\n<h1 id=\"2-安装与配置\"><a href=\"#2-安装与配置\" class=\"headerlink\" title=\"2. 安装与配置\"></a>2. 安装与配置</h1><h2 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h2><p>从<a href=\"https://services.gradle.org/distributions/\">安装目录</a>找一个不那么早的下载，然后配置环境变量：<br><code>GRADLE_HOME</code>,然后<code>%GRADLE_HOME%\\bin</code>目录加入到path<br><code>gradle -v</code> 验证  </p>\n<h2 id=\"2-2-配置镜像\"><a href=\"#2-2-配置镜像\" class=\"headerlink\" title=\"2.2 配置镜像\"></a>2.2 配置镜像</h2><p>init.d文件夹下新增 <strong>init.gradle</strong> 设置国内代理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">&#x27;file://D:/maven_repo&#x27;</span>&#125;</span><br><span class=\"line\">        mavenLocal()</span><br><span class=\"line\">        maven &#123; name <span class=\"string\">&quot;Alibaba&quot;</span> ; url <span class=\"string\">&quot;https://maven.aliyun.com/repository/public&quot;</span> &#125;</span><br><span class=\"line\">        maven &#123; name <span class=\"string\">&quot;Bstek&quot;</span> ; url <span class=\"string\">&quot;http://nexus.bsdn.org/content/groups/public/&quot;</span>&#125;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildscript &#123; </span><br><span class=\"line\">        repositories &#123; </span><br><span class=\"line\">            maven &#123; name <span class=\"string\">&quot;Alibaba&quot;</span> ; url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/public&#x27;</span>&#125;</span><br><span class=\"line\">            maven &#123; name <span class=\"string\">&quot;Bstek&quot;</span> ; url <span class=\"string\">&#x27;http://nexus.bsdn.org/content/groups/public/&#x27;</span> &#125;</span><br><span class=\"line\">            maven &#123; name <span class=\"string\">&quot;M2&quot;</span> ; url <span class=\"string\">&#x27;https://plugins.gradle.org/m2/&#x27;</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 这里有个指向本地目录是gradle本地仓库，其实也可以是maven本地仓库  </p>\n<h2 id=\"2-3-IDEA配置与wrapper\"><a href=\"#2-3-IDEA配置与wrapper\" class=\"headerlink\" title=\"2.3 IDEA配置与wrapper\"></a>2.3 IDEA配置与wrapper</h2><p>如果我们直接使用IDEA新建一个用gradle构建的项目，会发现它的结构有点不一样：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-src</span><br><span class=\"line\">-gradle</span><br><span class=\"line\">\t-warpper</span><br><span class=\"line\">\t\t-gradle-wrapper.jar</span><br><span class=\"line\">\t\t-gradle-wrapper.properties</span><br><span class=\"line\">-build.gradle #构建脚本，类似pom.xml</span><br><span class=\"line\">-gradlew #Linux系统的包装启动脚本</span><br><span class=\"line\">-gradlew.bat #windows系统的包装启动脚本</span><br><span class=\"line\">-settings.gradle #定义项目信息</span><br></pre></td></tr></table></figure>\n<p>warpper文件夹其实是对gradle的一层包装，为了：  </p>\n<ol>\n<li>在未安装gradle的环境运行  </li>\n<li>gradle的发展太快了，有时候需要切换版本，也可以使用gradlew代替。这样就使用的是附带jar的版本了。<br>gradle-wrapper.properties<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Gradle解包后存储的父目录</span></span><br><span class=\"line\"><span class=\"attr\">distributionBase</span>=GRADLE_USER_HOME</span><br><span class=\"line\"><span class=\"comment\"># 指定目录的子目录</span></span><br><span class=\"line\"><span class=\"attr\">distributionPath</span>=wrapper/dists</span><br><span class=\"line\"><span class=\"comment\"># Gradle指定版本的压缩包下载地址</span></span><br><span class=\"line\"><span class=\"attr\">distributionUrl</span>=https\\://services.gradle.org/distributions/gradle-<span class=\"number\">7.6</span>.<span class=\"number\">1</span>-bin.zip</span><br><span class=\"line\"><span class=\"comment\"># Gradle压缩包下载后存储父目录</span></span><br><span class=\"line\"><span class=\"attr\">zipStoreBase</span>=GRADLE_USER_HOME</span><br><span class=\"line\"><span class=\"comment\"># Gradle压缩包下载后存储子目录</span></span><br><span class=\"line\"><span class=\"attr\">zipStorePath</span>=wrapper/dists</span><br></pre></td></tr></table></figure>\n<code>GRADLE_USER_HOME</code>类似maven的本地仓库，如果不指定一般会放到用户.gradle目录，C盘估计又要爆炸了。这里可以指定为maven的本地仓库目录，然后设置到环境变量。虽然它并不会使用maven的缓存（两者缓存格式不一致）。</li>\n</ol>\n<p>以下是gradlew工作流程：<br><img src=\"https://docs.gradle.org/current/userguide/img/wrapper-workflow.png\" alt=\"gradlew工作流程\">  </p>\n<p>以下是IDEA的配置截图<br><img src=\"/images/gradle-idea-config.png\">  </p>\n<h1 id=\"3-Gradle使用\"><a href=\"#3-Gradle使用\" class=\"headerlink\" title=\"3. Gradle使用\"></a>3. Gradle使用</h1><p>常用gradle指令,与maven类似  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 构建项目</span><br><span class=\"line\">gradle build</span><br><span class=\"line\"># 清空build目录</span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"># 编译测试代码，生成测试报告</span><br><span class=\"line\">gradle test</span><br><span class=\"line\"># 跳过测试构建</span><br><span class=\"line\">gradle build-x test</span><br></pre></td></tr></table></figure>\n<p>IDEA自带的Gradle集成了这些常见命令，另外还对应用也做了支持：<br>比如这里可以直接Run应用的Main：<br><img src=\"/images/gradle-command.png\"></p>\n<hr>\n<hr>\n<p>关于gradle自定义任务及groovy语言，以后需要再深入研究吧。。</p>\n<p>Groovy语法参考：<br><a href=\"http://www.groovy-lang.org/testing.html#_introduction\">http://www.groovy-lang.org/testing.html#_introduction</a></p>\n<p>gradle_wrapper更多：<br><a href=\"https://docs.gradle.org/current/userguide/gradle_wrapper.html#gradle_wrapper\">https://docs.gradle.org/current/userguide/gradle_wrapper.html#gradle_wrapper</a></p>\n","site":{"data":{}},"excerpt":"<p>现在越来越多的开源项目都使用gradle来构建，而且基于gradle灵活的语法和增量构建等特性，在大型项目构建的时候大大节约了时间，实乃高效干活的利器，不得不学起来~</p>","more":"<h1 id=\"1-Gradle与-Maven的比较\"><a href=\"#1-Gradle与-Maven的比较\" class=\"headerlink\" title=\"1. Gradle与 Maven的比较\"></a>1. Gradle与 Maven的比较</h1><blockquote>\n<p>Gradle和Maven两种构建方式存在一些根本差异。 Gradle基于任务依赖关系图-其中任务就是工作，而Maven是基于固定的过程和线性模型。使用Maven构建项目时，目标将附加到项目阶段，目标的作用类似于Gradle的任务，即“完成任务的事物”。  </p>\n<p>1.1 在性能方面，两者都允许多模块构建并行运行。但是，Gradle允许增量构建，因为它检查是否更新了哪些任务。如果是这样，则不执行任务，从而使构建时间大大缩短。Gradle上其他出色的性能功能包括：  </p>\n<ul>\n<li>Java类的增量编译</li>\n<li>防止反编译</li>\n<li>对增量子任务使用API</li>\n<li>编译器守护程序加快编译速度</li>\n</ul>\n<p>1.2 在管理依赖项时，Gradle和Maven都可以处理动态和传递性依赖项，以使用第三方依赖项缓存，并读取POM元数据格式。还可以通过中央版本控制定义声明库版本并强制执行中央版本控制。两者都从其artifact 仓库下载可传递依赖项。Maven具有Maven Central，而Gradle具有JCenter，也可以定义自己的私人公司存储库。如果需要多个依赖项，Maven可以同时下载它们。</p>\n</blockquote>\n<h1 id=\"2-安装与配置\"><a href=\"#2-安装与配置\" class=\"headerlink\" title=\"2. 安装与配置\"></a>2. 安装与配置</h1><h2 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h2><p>从<a href=\"https://services.gradle.org/distributions/\">安装目录</a>找一个不那么早的下载，然后配置环境变量：<br><code>GRADLE_HOME</code>,然后<code>%GRADLE_HOME%\\bin</code>目录加入到path<br><code>gradle -v</code> 验证  </p>\n<h2 id=\"2-2-配置镜像\"><a href=\"#2-2-配置镜像\" class=\"headerlink\" title=\"2.2 配置镜像\"></a>2.2 配置镜像</h2><p>init.d文件夹下新增 <strong>init.gradle</strong> 设置国内代理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url <span class=\"string\">&#x27;file://D:/maven_repo&#x27;</span>&#125;</span><br><span class=\"line\">        mavenLocal()</span><br><span class=\"line\">        maven &#123; name <span class=\"string\">&quot;Alibaba&quot;</span> ; url <span class=\"string\">&quot;https://maven.aliyun.com/repository/public&quot;</span> &#125;</span><br><span class=\"line\">        maven &#123; name <span class=\"string\">&quot;Bstek&quot;</span> ; url <span class=\"string\">&quot;http://nexus.bsdn.org/content/groups/public/&quot;</span>&#125;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildscript &#123; </span><br><span class=\"line\">        repositories &#123; </span><br><span class=\"line\">            maven &#123; name <span class=\"string\">&quot;Alibaba&quot;</span> ; url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/public&#x27;</span>&#125;</span><br><span class=\"line\">            maven &#123; name <span class=\"string\">&quot;Bstek&quot;</span> ; url <span class=\"string\">&#x27;http://nexus.bsdn.org/content/groups/public/&#x27;</span> &#125;</span><br><span class=\"line\">            maven &#123; name <span class=\"string\">&quot;M2&quot;</span> ; url <span class=\"string\">&#x27;https://plugins.gradle.org/m2/&#x27;</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 这里有个指向本地目录是gradle本地仓库，其实也可以是maven本地仓库  </p>\n<h2 id=\"2-3-IDEA配置与wrapper\"><a href=\"#2-3-IDEA配置与wrapper\" class=\"headerlink\" title=\"2.3 IDEA配置与wrapper\"></a>2.3 IDEA配置与wrapper</h2><p>如果我们直接使用IDEA新建一个用gradle构建的项目，会发现它的结构有点不一样：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-src</span><br><span class=\"line\">-gradle</span><br><span class=\"line\">\t-warpper</span><br><span class=\"line\">\t\t-gradle-wrapper.jar</span><br><span class=\"line\">\t\t-gradle-wrapper.properties</span><br><span class=\"line\">-build.gradle #构建脚本，类似pom.xml</span><br><span class=\"line\">-gradlew #Linux系统的包装启动脚本</span><br><span class=\"line\">-gradlew.bat #windows系统的包装启动脚本</span><br><span class=\"line\">-settings.gradle #定义项目信息</span><br></pre></td></tr></table></figure>\n<p>warpper文件夹其实是对gradle的一层包装，为了：  </p>\n<ol>\n<li>在未安装gradle的环境运行  </li>\n<li>gradle的发展太快了，有时候需要切换版本，也可以使用gradlew代替。这样就使用的是附带jar的版本了。<br>gradle-wrapper.properties<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Gradle解包后存储的父目录</span></span><br><span class=\"line\"><span class=\"attr\">distributionBase</span>=GRADLE_USER_HOME</span><br><span class=\"line\"><span class=\"comment\"># 指定目录的子目录</span></span><br><span class=\"line\"><span class=\"attr\">distributionPath</span>=wrapper/dists</span><br><span class=\"line\"><span class=\"comment\"># Gradle指定版本的压缩包下载地址</span></span><br><span class=\"line\"><span class=\"attr\">distributionUrl</span>=https\\://services.gradle.org/distributions/gradle-<span class=\"number\">7.6</span>.<span class=\"number\">1</span>-bin.zip</span><br><span class=\"line\"><span class=\"comment\"># Gradle压缩包下载后存储父目录</span></span><br><span class=\"line\"><span class=\"attr\">zipStoreBase</span>=GRADLE_USER_HOME</span><br><span class=\"line\"><span class=\"comment\"># Gradle压缩包下载后存储子目录</span></span><br><span class=\"line\"><span class=\"attr\">zipStorePath</span>=wrapper/dists</span><br></pre></td></tr></table></figure>\n<code>GRADLE_USER_HOME</code>类似maven的本地仓库，如果不指定一般会放到用户.gradle目录，C盘估计又要爆炸了。这里可以指定为maven的本地仓库目录，然后设置到环境变量。虽然它并不会使用maven的缓存（两者缓存格式不一致）。</li>\n</ol>\n<p>以下是gradlew工作流程：<br><img src=\"https://docs.gradle.org/current/userguide/img/wrapper-workflow.png\" alt=\"gradlew工作流程\">  </p>\n<p>以下是IDEA的配置截图<br><img src=\"/images/gradle-idea-config.png\">  </p>\n<h1 id=\"3-Gradle使用\"><a href=\"#3-Gradle使用\" class=\"headerlink\" title=\"3. Gradle使用\"></a>3. Gradle使用</h1><p>常用gradle指令,与maven类似  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 构建项目</span><br><span class=\"line\">gradle build</span><br><span class=\"line\"># 清空build目录</span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"># 编译测试代码，生成测试报告</span><br><span class=\"line\">gradle test</span><br><span class=\"line\"># 跳过测试构建</span><br><span class=\"line\">gradle build-x test</span><br></pre></td></tr></table></figure>\n<p>IDEA自带的Gradle集成了这些常见命令，另外还对应用也做了支持：<br>比如这里可以直接Run应用的Main：<br><img src=\"/images/gradle-command.png\"></p>\n<hr>\n<hr>\n<p>关于gradle自定义任务及groovy语言，以后需要再深入研究吧。。</p>\n<p>Groovy语法参考：<br><a href=\"http://www.groovy-lang.org/testing.html#_introduction\">http://www.groovy-lang.org/testing.html#_introduction</a></p>\n<p>gradle_wrapper更多：<br><a href=\"https://docs.gradle.org/current/userguide/gradle_wrapper.html#gradle_wrapper\">https://docs.gradle.org/current/userguide/gradle_wrapper.html#gradle_wrapper</a></p>"},{"title":"Hexo Guide","date":"2023-03-23T03:45:58.000Z","description":"hexo使用概述","_content":"\n### 1、安装\nnodeJs安装，hexo安装，设置环境变量  \n阅读[官网文档](https://hexo.io/zh-cn/docs/commands)  \n注意设置下npm的源  \n``` bash\nnpm config set registry https://registry.npm.taobao.org --location=global\nnpm config set disturl https://npm.taobao.org/dist --location=global\n```\n\n\n### 2、初始化  \n`hexo init blog`  \n> 注意: \n> 本命令相当于执行了以下几步：\n> Git clone hexo-starter 和 hexo-theme-landscape 主题到当前>目录或指定目录。\n 使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。\n\n### 3、编译运行  \n此时，已经有一篇hello文章了，可以直接生成静态资源（将md编译为html）和运行（启动一个webServer），然后看效果。  \n两个命令可以一起运行   \n``` bash\n# hexo generate 和 hexo server\nhexo g && hexo s\n```\n\n\n### 4、设置主题  \n以经典nexT主题为例，只需将nexT放到theme目录下：  \n```\ngit clone https://github.com/next-theme/hexo-theme-next themes/next \n``` \n然后，改下配置\n```bash\n# vim ./_config.yml\ntheme: next\n```\n>[其他主题](https://hexo.io/themes/index.html)  \n\n### 5、新建文章  \n```\nhexo new protobuf\n```\n注意到source/_posts已经多了一篇文章 protobuf.md\n打开编辑Ta  \n> ---标记的是文章的信息，可以看做文章的header，在最下面添加md语法内容。\n``` md\n## 标题\nsay Hello\n## coding\n这里有一份代码\n`print(\"say Hello\")`\n```\n关于文章的基本信息设置，可以参考：  \nhttps://hexo.io/zh-cn/docs/front-matter  \n\n\n### 6、编译并运行  \n```bash\nhexo g &&  hexo s\n```\n\n### 7、图片资源问题 \n对于相对路径图片指向错误，无法显示的问题。  \n最后发现官网的资源文件 模块，其实早就给出了说明  \nhttps://hexo.io/zh-cn/docs/asset-folders \n- 安装插件 \n```\nnpm install hexo-renderer-marked --save\n```\n- 修改配置\n```\n_config.yml\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n其实也可以通过安装其他插件，修改部署时图片的路径：  \nhttps://leay.net/2019/12/25/hexo/  \n\n### 8、部署到github  \n安装 hexo-deployer-git  \n``` bash\n$ npm install hexo-deployer-git --save\n```\n参考[gitpage指南](https://hexo.io/zh-cn/docs/github-pages)  \n> 时间一久就忘记了怎么部署，还是记录一下：\n> 项目根目录下会配置git的地址和提交的msg，这也是hexo的deploy的能力。  \n因此，直接 `hexo deploy`就可以部署最新的到Github.io 。同时为了避免本地内容的丢失，也需要将本地内容commit && push到远端\n\n### 9、设置菜单  \n通过主题hexT的能力，参考：\nhttps://theme-next.js.org/docs/theme-settings/custom-pages.html  \n修改theme/next/_config.yml  \n``` yml\n# vi theme/next/_config.yml\nsidebar:\n  position: left\n  display: always\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  #archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  commonweal: /404/ || fa fa-heartbeat\n```\n自定义页面命令\n``` bash\nhexo new page about\nhexo new page tags\nhexo new page categories\nhexo new page commonweal\n```\n### 10、添加评论功能  \n\n> nexT主题已经支持多种评论系统，有代表性的有两款：\n> - Valine 评论系统  \n> 无需登录，需要注册Valine \n> - Gitment评论系统\n> 基于Github的issure，需要注册注册 OAuth application  \n开始之前在`themes\\next\\package.json` 看看本地安装next版本。  \n- 如果是Next8.1.0以下，建议直接使用[配置Valine](#12配置valine)  \n- 如果是最新8.1以上版本，next已经取消内置Valine，也不建议降级，毕竟后续有新的特性想升级呢？  \n配置waline的配置请参考[配置waline](#11配置waline)  \n---\n配置之后发现一个问题，手机端无法访问到评论。显然被墙了，后续考虑私有部署。  \n\n\n\n### 11、配置waline\n1. 官网的教程已经很清楚了。参照着截图的步骤来， 注意选择国际版\nhttps://waline.js.org/guide/get-started/  \n2. 最后`Visit`跳转后地址既是博客留言板的地址，复制Ta直接配置到next的配置文件\n``` yml\n# Waline\n# For more information: https://waline.js.org, https://github.com/walinejs/waline\nwaline:\n  enable: true #是否开启\n  serverURL: xxxxxxxx.vercel.app # Waline #服务端地址，我们这里就是上面部署的 Vercel 地址\n  locale:\n    placeholder: 疑义相与析，畅所欲言，不登录也没关系哒 # #评论框的默认文字\n  avatar: mm # 头像风格\n  meta: [nick,mail] # 自定义评论框上面的三个输入框的内容\n  pageSize: 10 # 评论数量多少时显示分页\n  lang: zh-cn # 语言, 可选值: en, zh-cn\n  visitor: true # 文章阅读统计\n  comment_count: true # 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示\n  requiredFields: [nick] # 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]\n  libUrl: https://unpkg.com/@waline/client@v2/dist/waline.js # Set custom library cdn url\n  login: enable\n```\n### 12、配置Valine\n以下介绍Valine的使用方式：\n1. 注册账号  \nhttps://console.leancloud.cn/  \n2. 配置  \n``` yml\nvaline:\n  enable: true \n  appid:  # 将应用key的App ID设置在这里\n  appkey: # 将应用key的App Key设置在这里\n  notify: false\n  verify: false\n  placeholder: 留下小脚印~\n  avatar: monsterid \n  guest_info: nick,mail,link # 自定义评论标题\n  pageSize: 10 # 分页大小，10页就自动分页\n  visitor: true # 是否允许游客评论\n```  \n> 更多valine的配置可以参考：  \n> https://blog.csdn.net/wugenqiang/article/details/105744843\n\n3. 管理评论  \n进入 LeanCloud 官网，找到 控制台->存储->commet 中进行管理  \n\n\n\n### 配置统计\n网站时常需要了解本地的请求来源以及次数或用户点击数之类的统计。\n1. 使用[umami](https://umami.is/)  \n最新被安利到这个玩意儿（开源），结果hexo又又又意外的兼容了。没办法，直接上手吧。在next主题下的_config.yml中找到umami启用，并配置好网站和注册(可以使用它自带的cloud账号，免费的每月可以有10k事件和3个网址)的ID即可。  \n\n    > 缺点很明显，这云js(https://analytics.umami.is/script.js)被墙了  \n    连统计结果view(https://analytics.umami.is/{ID})也无法直接看  \n\n2. 百度统计  \n百度统计(https://tongji.baidu.com/)个人也可以注册，也可以添加Github的个人网页。最主要是国内不被墙，统计维度成熟丰富，也被next插件集成，墙裂推荐！不然就得自己折腾服务器域名，还得搭建统计服务了。  \n\n","source":"_posts/Hexo-Guide.md","raw":"---\ntitle: Hexo Guide\ndate: 2023-03-23 11:45:58\ntags: \n- hexo\n- blog\ndescription: hexo使用概述\ncategories: 其他\n---\n\n### 1、安装\nnodeJs安装，hexo安装，设置环境变量  \n阅读[官网文档](https://hexo.io/zh-cn/docs/commands)  \n注意设置下npm的源  \n``` bash\nnpm config set registry https://registry.npm.taobao.org --location=global\nnpm config set disturl https://npm.taobao.org/dist --location=global\n```\n\n\n### 2、初始化  \n`hexo init blog`  \n> 注意: \n> 本命令相当于执行了以下几步：\n> Git clone hexo-starter 和 hexo-theme-landscape 主题到当前>目录或指定目录。\n 使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。\n\n### 3、编译运行  \n此时，已经有一篇hello文章了，可以直接生成静态资源（将md编译为html）和运行（启动一个webServer），然后看效果。  \n两个命令可以一起运行   \n``` bash\n# hexo generate 和 hexo server\nhexo g && hexo s\n```\n\n\n### 4、设置主题  \n以经典nexT主题为例，只需将nexT放到theme目录下：  \n```\ngit clone https://github.com/next-theme/hexo-theme-next themes/next \n``` \n然后，改下配置\n```bash\n# vim ./_config.yml\ntheme: next\n```\n>[其他主题](https://hexo.io/themes/index.html)  \n\n### 5、新建文章  \n```\nhexo new protobuf\n```\n注意到source/_posts已经多了一篇文章 protobuf.md\n打开编辑Ta  \n> ---标记的是文章的信息，可以看做文章的header，在最下面添加md语法内容。\n``` md\n## 标题\nsay Hello\n## coding\n这里有一份代码\n`print(\"say Hello\")`\n```\n关于文章的基本信息设置，可以参考：  \nhttps://hexo.io/zh-cn/docs/front-matter  \n\n\n### 6、编译并运行  \n```bash\nhexo g &&  hexo s\n```\n\n### 7、图片资源问题 \n对于相对路径图片指向错误，无法显示的问题。  \n最后发现官网的资源文件 模块，其实早就给出了说明  \nhttps://hexo.io/zh-cn/docs/asset-folders \n- 安装插件 \n```\nnpm install hexo-renderer-marked --save\n```\n- 修改配置\n```\n_config.yml\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n其实也可以通过安装其他插件，修改部署时图片的路径：  \nhttps://leay.net/2019/12/25/hexo/  \n\n### 8、部署到github  \n安装 hexo-deployer-git  \n``` bash\n$ npm install hexo-deployer-git --save\n```\n参考[gitpage指南](https://hexo.io/zh-cn/docs/github-pages)  \n> 时间一久就忘记了怎么部署，还是记录一下：\n> 项目根目录下会配置git的地址和提交的msg，这也是hexo的deploy的能力。  \n因此，直接 `hexo deploy`就可以部署最新的到Github.io 。同时为了避免本地内容的丢失，也需要将本地内容commit && push到远端\n\n### 9、设置菜单  \n通过主题hexT的能力，参考：\nhttps://theme-next.js.org/docs/theme-settings/custom-pages.html  \n修改theme/next/_config.yml  \n``` yml\n# vi theme/next/_config.yml\nsidebar:\n  position: left\n  display: always\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  #archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  commonweal: /404/ || fa fa-heartbeat\n```\n自定义页面命令\n``` bash\nhexo new page about\nhexo new page tags\nhexo new page categories\nhexo new page commonweal\n```\n### 10、添加评论功能  \n\n> nexT主题已经支持多种评论系统，有代表性的有两款：\n> - Valine 评论系统  \n> 无需登录，需要注册Valine \n> - Gitment评论系统\n> 基于Github的issure，需要注册注册 OAuth application  \n开始之前在`themes\\next\\package.json` 看看本地安装next版本。  \n- 如果是Next8.1.0以下，建议直接使用[配置Valine](#12配置valine)  \n- 如果是最新8.1以上版本，next已经取消内置Valine，也不建议降级，毕竟后续有新的特性想升级呢？  \n配置waline的配置请参考[配置waline](#11配置waline)  \n---\n配置之后发现一个问题，手机端无法访问到评论。显然被墙了，后续考虑私有部署。  \n\n\n\n### 11、配置waline\n1. 官网的教程已经很清楚了。参照着截图的步骤来， 注意选择国际版\nhttps://waline.js.org/guide/get-started/  \n2. 最后`Visit`跳转后地址既是博客留言板的地址，复制Ta直接配置到next的配置文件\n``` yml\n# Waline\n# For more information: https://waline.js.org, https://github.com/walinejs/waline\nwaline:\n  enable: true #是否开启\n  serverURL: xxxxxxxx.vercel.app # Waline #服务端地址，我们这里就是上面部署的 Vercel 地址\n  locale:\n    placeholder: 疑义相与析，畅所欲言，不登录也没关系哒 # #评论框的默认文字\n  avatar: mm # 头像风格\n  meta: [nick,mail] # 自定义评论框上面的三个输入框的内容\n  pageSize: 10 # 评论数量多少时显示分页\n  lang: zh-cn # 语言, 可选值: en, zh-cn\n  visitor: true # 文章阅读统计\n  comment_count: true # 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示\n  requiredFields: [nick] # 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]\n  libUrl: https://unpkg.com/@waline/client@v2/dist/waline.js # Set custom library cdn url\n  login: enable\n```\n### 12、配置Valine\n以下介绍Valine的使用方式：\n1. 注册账号  \nhttps://console.leancloud.cn/  \n2. 配置  \n``` yml\nvaline:\n  enable: true \n  appid:  # 将应用key的App ID设置在这里\n  appkey: # 将应用key的App Key设置在这里\n  notify: false\n  verify: false\n  placeholder: 留下小脚印~\n  avatar: monsterid \n  guest_info: nick,mail,link # 自定义评论标题\n  pageSize: 10 # 分页大小，10页就自动分页\n  visitor: true # 是否允许游客评论\n```  \n> 更多valine的配置可以参考：  \n> https://blog.csdn.net/wugenqiang/article/details/105744843\n\n3. 管理评论  \n进入 LeanCloud 官网，找到 控制台->存储->commet 中进行管理  \n\n\n\n### 配置统计\n网站时常需要了解本地的请求来源以及次数或用户点击数之类的统计。\n1. 使用[umami](https://umami.is/)  \n最新被安利到这个玩意儿（开源），结果hexo又又又意外的兼容了。没办法，直接上手吧。在next主题下的_config.yml中找到umami启用，并配置好网站和注册(可以使用它自带的cloud账号，免费的每月可以有10k事件和3个网址)的ID即可。  \n\n    > 缺点很明显，这云js(https://analytics.umami.is/script.js)被墙了  \n    连统计结果view(https://analytics.umami.is/{ID})也无法直接看  \n\n2. 百度统计  \n百度统计(https://tongji.baidu.com/)个人也可以注册，也可以添加Github的个人网页。最主要是国内不被墙，统计维度成熟丰富，也被next插件集成，墙裂推荐！不然就得自己折腾服务器域名，还得搭建统计服务了。  \n\n","slug":"Hexo-Guide","published":1,"updated":"2024-04-11T03:39:10.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyp000eqwvdg8796kmf","content":"<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>nodeJs安装，hexo安装，设置环境变量<br>阅读<a href=\"https://hexo.io/zh-cn/docs/commands\">官网文档</a><br>注意设置下npm的源  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org --location=global</span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> disturl https://npm.taobao.org/dist --location=global</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2、初始化\"><a href=\"#2、初始化\" class=\"headerlink\" title=\"2、初始化\"></a>2、初始化</h3><p><code>hexo init blog</code>  </p>\n<blockquote>\n<p>注意:<br>本命令相当于执行了以下几步：<br>Git clone hexo-starter 和 hexo-theme-landscape 主题到当前&gt;目录或指定目录。<br> 使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。</p>\n</blockquote>\n<h3 id=\"3、编译运行\"><a href=\"#3、编译运行\" class=\"headerlink\" title=\"3、编译运行\"></a>3、编译运行</h3><p>此时，已经有一篇hello文章了，可以直接生成静态资源（将md编译为html）和运行（启动一个webServer），然后看效果。<br>两个命令可以一起运行   </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># hexo generate 和 hexo server</span></span><br><span class=\"line\">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4、设置主题\"><a href=\"#4、设置主题\" class=\"headerlink\" title=\"4、设置主题\"></a>4、设置主题</h3><p>以经典nexT主题为例，只需将nexT放到theme目录下：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/next-theme/hexo-theme-next themes/next </span><br></pre></td></tr></table></figure>\n<p>然后，改下配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim ./_config.yml</span></span><br><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://hexo.io/themes/index.html\">其他主题</a>  </p>\n</blockquote>\n<h3 id=\"5、新建文章\"><a href=\"#5、新建文章\" class=\"headerlink\" title=\"5、新建文章\"></a>5、新建文章</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new protobuf</span><br></pre></td></tr></table></figure>\n<p>注意到source&#x2F;_posts已经多了一篇文章 protobuf.md<br>打开编辑Ta  </p>\n<blockquote>\n<p>—标记的是文章的信息，可以看做文章的header，在最下面添加md语法内容。</p>\n</blockquote>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">## 标题</span></span><br><span class=\"line\">say Hello</span><br><span class=\"line\"><span class=\"section\">## coding</span></span><br><span class=\"line\">这里有一份代码</span><br><span class=\"line\"><span class=\"code\">`print(&quot;say Hello&quot;)`</span></span><br></pre></td></tr></table></figure>\n<p>关于文章的基本信息设置，可以参考：<br><a href=\"https://hexo.io/zh-cn/docs/front-matter\">https://hexo.io/zh-cn/docs/front-matter</a>  </p>\n<h3 id=\"6、编译并运行\"><a href=\"#6、编译并运行\" class=\"headerlink\" title=\"6、编译并运行\"></a>6、编译并运行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g &amp;&amp;  hexo s</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、图片资源问题\"><a href=\"#7、图片资源问题\" class=\"headerlink\" title=\"7、图片资源问题\"></a>7、图片资源问题</h3><p>对于相对路径图片指向错误，无法显示的问题。<br>最后发现官网的资源文件 模块，其实早就给出了说明<br><a href=\"https://hexo.io/zh-cn/docs/asset-folders\">https://hexo.io/zh-cn/docs/asset-folders</a> </p>\n<ul>\n<li>安装插件 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></li>\n<li>修改配置<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\">post_asset_folder: true</span><br><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br></pre></td></tr></table></figure>\n其实也可以通过安装其他插件，修改部署时图片的路径：<br><a href=\"https://leay.net/2019/12/25/hexo/\">https://leay.net/2019/12/25/hexo/</a></li>\n</ul>\n<h3 id=\"8、部署到github\"><a href=\"#8、部署到github\" class=\"headerlink\" title=\"8、部署到github\"></a>8、部署到github</h3><p>安装 hexo-deployer-git  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>参考<a href=\"https://hexo.io/zh-cn/docs/github-pages\">gitpage指南</a>  </p>\n<blockquote>\n<p>时间一久就忘记了怎么部署，还是记录一下：<br>项目根目录下会配置git的地址和提交的msg，这也是hexo的deploy的能力。<br>因此，直接 <code>hexo deploy</code>就可以部署最新的到Github.io 。同时为了避免本地内容的丢失，也需要将本地内容commit &amp;&amp; push到远端</p>\n</blockquote>\n<h3 id=\"9、设置菜单\"><a href=\"#9、设置菜单\" class=\"headerlink\" title=\"9、设置菜单\"></a>9、设置菜单</h3><p>通过主题hexT的能力，参考：<br><a href=\"https://theme-next.js.org/docs/theme-settings/custom-pages.html\">https://theme-next.js.org/docs/theme-settings/custom-pages.html</a><br>修改theme&#x2F;next&#x2F;_config.yml  </p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vi theme/next/_config.yml</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span></span><br><span class=\"line\">  <span class=\"attr\">position:</span> <span class=\"string\">left</span></span><br><span class=\"line\">  <span class=\"attr\">display:</span> <span class=\"string\">always</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"attr\">about:</span> <span class=\"string\">/about/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-user</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-tags</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-th</span></span><br><span class=\"line\">  <span class=\"comment\">#archives: /archives/ || fa fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"attr\">commonweal:</span> <span class=\"string\">/404/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-heartbeat</span></span><br></pre></td></tr></table></figure>\n<p>自定义页面命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page about</span><br><span class=\"line\">hexo new page tags</span><br><span class=\"line\">hexo new page categories</span><br><span class=\"line\">hexo new page commonweal</span><br></pre></td></tr></table></figure>\n<h3 id=\"10、添加评论功能\"><a href=\"#10、添加评论功能\" class=\"headerlink\" title=\"10、添加评论功能\"></a>10、添加评论功能</h3><blockquote>\n<p>nexT主题已经支持多种评论系统，有代表性的有两款：</p>\n<ul>\n<li>Valine 评论系统<br>无需登录，需要注册Valine </li>\n<li>Gitment评论系统<br>基于Github的issure，需要注册注册 OAuth application<br>开始之前在<code>themes\\next\\package.json</code> 看看本地安装next版本。</li>\n</ul>\n</blockquote>\n<ul>\n<li>如果是Next8.1.0以下，建议直接使用<a href=\"#12%E9%85%8D%E7%BD%AEvaline\">配置Valine</a>  </li>\n<li>如果是最新8.1以上版本，next已经取消内置Valine，也不建议降级，毕竟后续有新的特性想升级呢？<br>配置waline的配置请参考<a href=\"#11%E9%85%8D%E7%BD%AEwaline\">配置waline</a></li>\n</ul>\n<hr>\n<p>配置之后发现一个问题，手机端无法访问到评论。显然被墙了，后续考虑私有部署。  </p>\n<h3 id=\"11、配置waline\"><a href=\"#11、配置waline\" class=\"headerlink\" title=\"11、配置waline\"></a>11、配置waline</h3><ol>\n<li>官网的教程已经很清楚了。参照着截图的步骤来， 注意选择国际版<br><a href=\"https://waline.js.org/guide/get-started/\">https://waline.js.org/guide/get-started/</a>  </li>\n<li>最后<code>Visit</code>跳转后地址既是博客留言板的地址，复制Ta直接配置到next的配置文件<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Waline</span></span><br><span class=\"line\"><span class=\"comment\"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class=\"line\"><span class=\"attr\">waline:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\">#是否开启</span></span><br><span class=\"line\">  <span class=\"attr\">serverURL:</span> <span class=\"string\">xxxxxxxx.vercel.app</span> <span class=\"comment\"># Waline #服务端地址，我们这里就是上面部署的 Vercel 地址</span></span><br><span class=\"line\">  <span class=\"attr\">locale:</span></span><br><span class=\"line\">    <span class=\"attr\">placeholder:</span> <span class=\"string\">疑义相与析，畅所欲言，不登录也没关系哒</span> <span class=\"comment\"># #评论框的默认文字</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">mm</span> <span class=\"comment\"># 头像风格</span></span><br><span class=\"line\">  <span class=\"attr\">meta:</span> [<span class=\"string\">nick</span>,<span class=\"string\">mail</span>] <span class=\"comment\"># 自定义评论框上面的三个输入框的内容</span></span><br><span class=\"line\">  <span class=\"attr\">pageSize:</span> <span class=\"number\">10</span> <span class=\"comment\"># 评论数量多少时显示分页</span></span><br><span class=\"line\">  <span class=\"attr\">lang:</span> <span class=\"string\">zh-cn</span> <span class=\"comment\"># 语言, 可选值: en, zh-cn</span></span><br><span class=\"line\">  <span class=\"attr\">visitor:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 文章阅读统计</span></span><br><span class=\"line\">  <span class=\"attr\">comment_count:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class=\"line\">  <span class=\"attr\">requiredFields:</span> [<span class=\"string\">nick</span>] <span class=\"comment\"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class=\"line\">  <span class=\"attr\">libUrl:</span> <span class=\"string\">https://unpkg.com/@waline/client@v2/dist/waline.js</span> <span class=\"comment\"># Set custom library cdn url</span></span><br><span class=\"line\">  <span class=\"attr\">login:</span> <span class=\"string\">enable</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"12、配置Valine\"><a href=\"#12、配置Valine\" class=\"headerlink\" title=\"12、配置Valine\"></a>12、配置Valine</h3><p>以下介绍Valine的使用方式：</p>\n<ol>\n<li>注册账号<br><a href=\"https://console.leancloud.cn/\">https://console.leancloud.cn/</a>  </li>\n<li>配置</li>\n</ol>\n<pre><code class=\"yml\">valine:\n  enable: true \n  appid:  # 将应用key的App ID设置在这里\n  appkey: # 将应用key的App Key设置在这里\n  notify: false\n  verify: false\n  placeholder: 留下小脚印~\n  avatar: monsterid \n  guest_info: nick,mail,link # 自定义评论标题\n  pageSize: 10 # 分页大小，10页就自动分页\n  visitor: true # 是否允许游客评论\n</code></pre>\n<blockquote>\n<p>更多valine的配置可以参考：<br><a href=\"https://blog.csdn.net/wugenqiang/article/details/105744843\">https://blog.csdn.net/wugenqiang/article/details/105744843</a></p>\n</blockquote>\n<ol start=\"3\">\n<li>管理评论<br>进入 LeanCloud 官网，找到 控制台-&gt;存储-&gt;commet 中进行管理</li>\n</ol>\n<h3 id=\"配置统计\"><a href=\"#配置统计\" class=\"headerlink\" title=\"配置统计\"></a>配置统计</h3><p>网站时常需要了解本地的请求来源以及次数或用户点击数之类的统计。</p>\n<ol>\n<li><p>使用<a href=\"https://umami.is/\">umami</a><br>最新被安利到这个玩意儿（开源），结果hexo又又又意外的兼容了。没办法，直接上手吧。在next主题下的_config.yml中找到umami启用，并配置好网站和注册(可以使用它自带的cloud账号，免费的每月可以有10k事件和3个网址)的ID即可。  </p>\n<blockquote>\n<p>缺点很明显，这云js(<a href=\"https://analytics.umami.is/script.js)%E8%A2%AB%E5%A2%99%E4%BA%86\">https://analytics.umami.is/script.js)被墙了</a><br> 连统计结果view(<a href=\"https://analytics.umami.is/%7BID%7D)%E4%B9%9F%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E7%9C%8B\">https://analytics.umami.is/{ID})也无法直接看</a>  </p>\n</blockquote>\n</li>\n<li><p>百度统计<br>百度统计(<a href=\"https://tongji.baidu.com/)%E4%B8%AA%E4%BA%BA%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%B3%A8%E5%86%8C%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0Github%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E3%80%82%E6%9C%80%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9B%BD%E5%86%85%E4%B8%8D%E8%A2%AB%E5%A2%99%EF%BC%8C%E7%BB%9F%E8%AE%A1%E7%BB%B4%E5%BA%A6%E6%88%90%E7%86%9F%E4%B8%B0%E5%AF%8C%EF%BC%8C%E4%B9%9F%E8%A2%ABnext%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90%EF%BC%8C%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90%EF%BC%81%E4%B8%8D%E7%84%B6%E5%B0%B1%E5%BE%97%E8%87%AA%E5%B7%B1%E6%8A%98%E8%85%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%9F%E5%90%8D%EF%BC%8C%E8%BF%98%E5%BE%97%E6%90%AD%E5%BB%BA%E7%BB%9F%E8%AE%A1%E6%9C%8D%E5%8A%A1%E4%BA%86%E3%80%82\">https://tongji.baidu.com/)个人也可以注册，也可以添加Github的个人网页。最主要是国内不被墙，统计维度成熟丰富，也被next插件集成，墙裂推荐！不然就得自己折腾服务器域名，还得搭建统计服务了。</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>nodeJs安装，hexo安装，设置环境变量<br>阅读<a href=\"https://hexo.io/zh-cn/docs/commands\">官网文档</a><br>注意设置下npm的源  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org --location=global</span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> disturl https://npm.taobao.org/dist --location=global</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2、初始化\"><a href=\"#2、初始化\" class=\"headerlink\" title=\"2、初始化\"></a>2、初始化</h3><p><code>hexo init blog</code>  </p>\n<blockquote>\n<p>注意:<br>本命令相当于执行了以下几步：<br>Git clone hexo-starter 和 hexo-theme-landscape 主题到当前&gt;目录或指定目录。<br> 使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。</p>\n</blockquote>\n<h3 id=\"3、编译运行\"><a href=\"#3、编译运行\" class=\"headerlink\" title=\"3、编译运行\"></a>3、编译运行</h3><p>此时，已经有一篇hello文章了，可以直接生成静态资源（将md编译为html）和运行（启动一个webServer），然后看效果。<br>两个命令可以一起运行   </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># hexo generate 和 hexo server</span></span><br><span class=\"line\">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4、设置主题\"><a href=\"#4、设置主题\" class=\"headerlink\" title=\"4、设置主题\"></a>4、设置主题</h3><p>以经典nexT主题为例，只需将nexT放到theme目录下：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/next-theme/hexo-theme-next themes/next </span><br></pre></td></tr></table></figure>\n<p>然后，改下配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim ./_config.yml</span></span><br><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://hexo.io/themes/index.html\">其他主题</a>  </p>\n</blockquote>\n<h3 id=\"5、新建文章\"><a href=\"#5、新建文章\" class=\"headerlink\" title=\"5、新建文章\"></a>5、新建文章</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new protobuf</span><br></pre></td></tr></table></figure>\n<p>注意到source&#x2F;_posts已经多了一篇文章 protobuf.md<br>打开编辑Ta  </p>\n<blockquote>\n<p>—标记的是文章的信息，可以看做文章的header，在最下面添加md语法内容。</p>\n</blockquote>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">## 标题</span></span><br><span class=\"line\">say Hello</span><br><span class=\"line\"><span class=\"section\">## coding</span></span><br><span class=\"line\">这里有一份代码</span><br><span class=\"line\"><span class=\"code\">`print(&quot;say Hello&quot;)`</span></span><br></pre></td></tr></table></figure>\n<p>关于文章的基本信息设置，可以参考：<br><a href=\"https://hexo.io/zh-cn/docs/front-matter\">https://hexo.io/zh-cn/docs/front-matter</a>  </p>\n<h3 id=\"6、编译并运行\"><a href=\"#6、编译并运行\" class=\"headerlink\" title=\"6、编译并运行\"></a>6、编译并运行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g &amp;&amp;  hexo s</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、图片资源问题\"><a href=\"#7、图片资源问题\" class=\"headerlink\" title=\"7、图片资源问题\"></a>7、图片资源问题</h3><p>对于相对路径图片指向错误，无法显示的问题。<br>最后发现官网的资源文件 模块，其实早就给出了说明<br><a href=\"https://hexo.io/zh-cn/docs/asset-folders\">https://hexo.io/zh-cn/docs/asset-folders</a> </p>\n<ul>\n<li>安装插件 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></li>\n<li>修改配置<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\">post_asset_folder: true</span><br><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br></pre></td></tr></table></figure>\n其实也可以通过安装其他插件，修改部署时图片的路径：<br><a href=\"https://leay.net/2019/12/25/hexo/\">https://leay.net/2019/12/25/hexo/</a></li>\n</ul>\n<h3 id=\"8、部署到github\"><a href=\"#8、部署到github\" class=\"headerlink\" title=\"8、部署到github\"></a>8、部署到github</h3><p>安装 hexo-deployer-git  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>参考<a href=\"https://hexo.io/zh-cn/docs/github-pages\">gitpage指南</a>  </p>\n<blockquote>\n<p>时间一久就忘记了怎么部署，还是记录一下：<br>项目根目录下会配置git的地址和提交的msg，这也是hexo的deploy的能力。<br>因此，直接 <code>hexo deploy</code>就可以部署最新的到Github.io 。同时为了避免本地内容的丢失，也需要将本地内容commit &amp;&amp; push到远端</p>\n</blockquote>\n<h3 id=\"9、设置菜单\"><a href=\"#9、设置菜单\" class=\"headerlink\" title=\"9、设置菜单\"></a>9、设置菜单</h3><p>通过主题hexT的能力，参考：<br><a href=\"https://theme-next.js.org/docs/theme-settings/custom-pages.html\">https://theme-next.js.org/docs/theme-settings/custom-pages.html</a><br>修改theme&#x2F;next&#x2F;_config.yml  </p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vi theme/next/_config.yml</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span></span><br><span class=\"line\">  <span class=\"attr\">position:</span> <span class=\"string\">left</span></span><br><span class=\"line\">  <span class=\"attr\">display:</span> <span class=\"string\">always</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"attr\">about:</span> <span class=\"string\">/about/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-user</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-tags</span></span><br><span class=\"line\">  <span class=\"attr\">categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-th</span></span><br><span class=\"line\">  <span class=\"comment\">#archives: /archives/ || fa fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"attr\">commonweal:</span> <span class=\"string\">/404/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-heartbeat</span></span><br></pre></td></tr></table></figure>\n<p>自定义页面命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page about</span><br><span class=\"line\">hexo new page tags</span><br><span class=\"line\">hexo new page categories</span><br><span class=\"line\">hexo new page commonweal</span><br></pre></td></tr></table></figure>\n<h3 id=\"10、添加评论功能\"><a href=\"#10、添加评论功能\" class=\"headerlink\" title=\"10、添加评论功能\"></a>10、添加评论功能</h3><blockquote>\n<p>nexT主题已经支持多种评论系统，有代表性的有两款：</p>\n<ul>\n<li>Valine 评论系统<br>无需登录，需要注册Valine </li>\n<li>Gitment评论系统<br>基于Github的issure，需要注册注册 OAuth application<br>开始之前在<code>themes\\next\\package.json</code> 看看本地安装next版本。</li>\n</ul>\n</blockquote>\n<ul>\n<li>如果是Next8.1.0以下，建议直接使用<a href=\"#12%E9%85%8D%E7%BD%AEvaline\">配置Valine</a>  </li>\n<li>如果是最新8.1以上版本，next已经取消内置Valine，也不建议降级，毕竟后续有新的特性想升级呢？<br>配置waline的配置请参考<a href=\"#11%E9%85%8D%E7%BD%AEwaline\">配置waline</a></li>\n</ul>\n<hr>\n<p>配置之后发现一个问题，手机端无法访问到评论。显然被墙了，后续考虑私有部署。  </p>\n<h3 id=\"11、配置waline\"><a href=\"#11、配置waline\" class=\"headerlink\" title=\"11、配置waline\"></a>11、配置waline</h3><ol>\n<li>官网的教程已经很清楚了。参照着截图的步骤来， 注意选择国际版<br><a href=\"https://waline.js.org/guide/get-started/\">https://waline.js.org/guide/get-started/</a>  </li>\n<li>最后<code>Visit</code>跳转后地址既是博客留言板的地址，复制Ta直接配置到next的配置文件<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Waline</span></span><br><span class=\"line\"><span class=\"comment\"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class=\"line\"><span class=\"attr\">waline:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\">#是否开启</span></span><br><span class=\"line\">  <span class=\"attr\">serverURL:</span> <span class=\"string\">xxxxxxxx.vercel.app</span> <span class=\"comment\"># Waline #服务端地址，我们这里就是上面部署的 Vercel 地址</span></span><br><span class=\"line\">  <span class=\"attr\">locale:</span></span><br><span class=\"line\">    <span class=\"attr\">placeholder:</span> <span class=\"string\">疑义相与析，畅所欲言，不登录也没关系哒</span> <span class=\"comment\"># #评论框的默认文字</span></span><br><span class=\"line\">  <span class=\"attr\">avatar:</span> <span class=\"string\">mm</span> <span class=\"comment\"># 头像风格</span></span><br><span class=\"line\">  <span class=\"attr\">meta:</span> [<span class=\"string\">nick</span>,<span class=\"string\">mail</span>] <span class=\"comment\"># 自定义评论框上面的三个输入框的内容</span></span><br><span class=\"line\">  <span class=\"attr\">pageSize:</span> <span class=\"number\">10</span> <span class=\"comment\"># 评论数量多少时显示分页</span></span><br><span class=\"line\">  <span class=\"attr\">lang:</span> <span class=\"string\">zh-cn</span> <span class=\"comment\"># 语言, 可选值: en, zh-cn</span></span><br><span class=\"line\">  <span class=\"attr\">visitor:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 文章阅读统计</span></span><br><span class=\"line\">  <span class=\"attr\">comment_count:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class=\"line\">  <span class=\"attr\">requiredFields:</span> [<span class=\"string\">nick</span>] <span class=\"comment\"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class=\"line\">  <span class=\"attr\">libUrl:</span> <span class=\"string\">https://unpkg.com/@waline/client@v2/dist/waline.js</span> <span class=\"comment\"># Set custom library cdn url</span></span><br><span class=\"line\">  <span class=\"attr\">login:</span> <span class=\"string\">enable</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"12、配置Valine\"><a href=\"#12、配置Valine\" class=\"headerlink\" title=\"12、配置Valine\"></a>12、配置Valine</h3><p>以下介绍Valine的使用方式：</p>\n<ol>\n<li>注册账号<br><a href=\"https://console.leancloud.cn/\">https://console.leancloud.cn/</a>  </li>\n<li>配置</li>\n</ol>\n<pre><code class=\"yml\">valine:\n  enable: true \n  appid:  # 将应用key的App ID设置在这里\n  appkey: # 将应用key的App Key设置在这里\n  notify: false\n  verify: false\n  placeholder: 留下小脚印~\n  avatar: monsterid \n  guest_info: nick,mail,link # 自定义评论标题\n  pageSize: 10 # 分页大小，10页就自动分页\n  visitor: true # 是否允许游客评论\n</code></pre>\n<blockquote>\n<p>更多valine的配置可以参考：<br><a href=\"https://blog.csdn.net/wugenqiang/article/details/105744843\">https://blog.csdn.net/wugenqiang/article/details/105744843</a></p>\n</blockquote>\n<ol start=\"3\">\n<li>管理评论<br>进入 LeanCloud 官网，找到 控制台-&gt;存储-&gt;commet 中进行管理</li>\n</ol>\n<h3 id=\"配置统计\"><a href=\"#配置统计\" class=\"headerlink\" title=\"配置统计\"></a>配置统计</h3><p>网站时常需要了解本地的请求来源以及次数或用户点击数之类的统计。</p>\n<ol>\n<li><p>使用<a href=\"https://umami.is/\">umami</a><br>最新被安利到这个玩意儿（开源），结果hexo又又又意外的兼容了。没办法，直接上手吧。在next主题下的_config.yml中找到umami启用，并配置好网站和注册(可以使用它自带的cloud账号，免费的每月可以有10k事件和3个网址)的ID即可。  </p>\n<blockquote>\n<p>缺点很明显，这云js(<a href=\"https://analytics.umami.is/script.js)%E8%A2%AB%E5%A2%99%E4%BA%86\">https://analytics.umami.is/script.js)被墙了</a><br> 连统计结果view(<a href=\"https://analytics.umami.is/%7BID%7D)%E4%B9%9F%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E7%9C%8B\">https://analytics.umami.is/{ID})也无法直接看</a>  </p>\n</blockquote>\n</li>\n<li><p>百度统计<br>百度统计(<a href=\"https://tongji.baidu.com/)%E4%B8%AA%E4%BA%BA%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%B3%A8%E5%86%8C%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0Github%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E3%80%82%E6%9C%80%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9B%BD%E5%86%85%E4%B8%8D%E8%A2%AB%E5%A2%99%EF%BC%8C%E7%BB%9F%E8%AE%A1%E7%BB%B4%E5%BA%A6%E6%88%90%E7%86%9F%E4%B8%B0%E5%AF%8C%EF%BC%8C%E4%B9%9F%E8%A2%ABnext%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90%EF%BC%8C%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90%EF%BC%81%E4%B8%8D%E7%84%B6%E5%B0%B1%E5%BE%97%E8%87%AA%E5%B7%B1%E6%8A%98%E8%85%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%9F%E5%90%8D%EF%BC%8C%E8%BF%98%E5%BE%97%E6%90%AD%E5%BB%BA%E7%BB%9F%E8%AE%A1%E6%9C%8D%E5%8A%A1%E4%BA%86%E3%80%82\">https://tongji.baidu.com/)个人也可以注册，也可以添加Github的个人网页。最主要是国内不被墙，统计维度成熟丰富，也被next插件集成，墙裂推荐！不然就得自己折腾服务器域名，还得搭建统计服务了。</a></p>\n</li>\n</ol>\n"},{"title":"Mybatis源码","date":"2024-02-18T08:48:31.000Z","_content":"Mybatis是一款优秀的持久层框架，从事java的web方向的同学没有不熟悉的。同时，它的源码也非常适合阅读。 温故而知新~\n<!--more-->\n\n#阅读源码的最好的方式：\n\n1. 理解主流程\n2. debug，找主流程的主要类和方法\n3. 带着问题（譬如一些常见面试题）debug\n\n> 这里有一份阅读Mybatis源码的意见，可以作为参考\n> https://zhuanlan.zhihu.com/p/269761503\n\n‍\n\n## Mybatis主要执行流程：\n\n​![image](/images/assets/image-20231130162207-amricr9.png)​\n\n1. 解析主配置文件，初始化`SqlSessionFactory`​​​\n\n    ```java\n    org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream, java.lang.String, java.util.Properties) {\n    \tXMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n        return build(parser.parse());\n    }\n\n    org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration(XNode root) { \n    \t...\n    \t// 读取environments配置，初始化TransactionFactory 和 DataSourceFactory \n    \tenvironmentsElement(root.evalNode(\"environments\"));\n    \t+--  TransactionFactory txFactory = transactionManagerElement(child.evalNode(\"transactionManager\"));\n        +--   DataSourceFactory dsFactory = dataSourceElement(child.evalNode(\"dataSource\"));\n    \t...\n    \t// 读取mappers配置，并关联读取mapper.xml\n    \tmapperElement(root.evalNode(\"mappers\"));\n    }\n    ```\n\n    * 解析mapper.xml (org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement)\n\n      ​![image](/images/assets/image-20231130153853-ui2udcs.png)​\n\n    ‍\n2. 获取`session`​​​ ，开启事务\n\n    ​![image](/images/assets/image-20231130154646-n3tfgm6.png)​\n\n3. 获取mapper\n\n\t​![image](/images/assets/image-20231130160711-ora87uk.png)​\n\n\t这里其实并没有生成Mapper的实例，因为本身就没有实现类。而是通过`MapperProxyFactory`​创建了一个代理对象。\n\n\t​![image](/images/assets/image-20231130161537-k6jp4kq.png)​\n\n4. 预编译\n\n    * 代理方法根据Sql类型调用相应的方法\n\n\t![image](/images/assets/image-20231130161950-nthyx0q.png)\t​\n\n* 通过执行器调用查询\t ![image](/images/assets/image-20231130162334-wq8knl7.png)​\n\n* ​`StatementHandler`​预编译\n\n  ​![image](/images/assets/image-20231130163419-dlucov7.png)​\n\n5. 执行并解析结果集\t​![image](/images/assets/image-20231130163626-b3ijn8u.png)​\n\n    * 调用ObjectFactory创建需要的类型\n\n    ​![image](/images/assets/image-20231130165000-f9u4xav.png)​\n\n    * 绑定数据库字段和目标resultType属性的对应关系![image](/images/assets/image-20231130165557-5lors2o.png)​\n\n      * 从rs中取值并对应到metadata​![image](/images/assets/image-20231130170131-pfyz6vu.png)​\n\n      ‍\n\n‍\n\n‍\n\n## Mybatis的插件机制\n\n‍\n\n> 看了下mybatis的一些面试题，没啥新鲜的。都是一些应用常识，在跟进几次源码的执行后，心里就大致有个印象了。\n>\n> 下面看看Mybatis的插件机制是如何实现的，这里还是以最常见的分页插件为例。\n\n‍\n\n如何使用参考[[官网]](https://pagehelper.github.io/docs/howtouse/)\n\n‍\n\n### 1 插件都会被注册成为拦截器\n\n​![image](/images/assets/image-20231204111109-ayhkc67.png)​\n\n‍\n\n### 2 `Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法`​\n\n  拦截器中，对doBoundSql本身的处理；\n\n>  需要注意的是：\n>\n> ​`ExecutorUtil.executeAutoCount`​ 方法会把参数拦截、以及Mybatis的相关查询都会执行一次，用户获取count\n\n​![image](/images/assets/image-20231204162214-4g1bw2e.png)​\n\nExecutorUtil.pageQuery 设置完成boundSql后，在预处理的时候，会遍历参数Mappings根据index真正设置参数\n\n​![image](/images/assets/image-20231204174826-1q081wx.png)​\n\n​​\n\n### 分页插件总结\n\n* PageInterceptor\n\n  分页插件的入口，通过实现Mybatis的拦截器进入；如果要分页，先获取count，再添加分页参数查询，并封装Page返回\n* Dialect\n\n  方言：也实现了pageHelper的扩展，包含是否分页判定、前置后置等\n* BoundSqlInterceptor\n\n  一个链式BoundSql 处理器，在分页前中后可对原sql变更\n* PageHelper\n\n  分页插件的主类（implements Dialect, BoundSqlInterceptor.Chain），分页逻辑的主题逻辑入口类\n\n  ‍\n\n‍\n\n---\n\n## Q: JDBC如何通过问号表达式防止SQL注入？\n\n>  预编译会标识该位置为参数类型，而不是原生SQL， 这个设定是MYSQL协议支持的。\n\n‍\n\n>  创建一个PreparedStatement对象，用于向数据库发送参数化的SQL语句。 可以预编译带有或不带有IN参数的SQL语句，并将其存储在PreparedStatement对象中。然后可以使用该对象多次有效地执行该语句。\n\njava.sql.Connection#prepareStatement(java.lang.String)\n\njava.sql.PreparedStatement#setString\n\n‍\n\n预处理协议：\n\nhttps://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html\n\n‍\n","source":"_posts/Mybatis源码.md","raw":"---\ntitle: Mybatis源码\ndate: 2024-02-18 16:48:31\ntags:\n- mybatis\ncategories: Spring+\n---\nMybatis是一款优秀的持久层框架，从事java的web方向的同学没有不熟悉的。同时，它的源码也非常适合阅读。 温故而知新~\n<!--more-->\n\n#阅读源码的最好的方式：\n\n1. 理解主流程\n2. debug，找主流程的主要类和方法\n3. 带着问题（譬如一些常见面试题）debug\n\n> 这里有一份阅读Mybatis源码的意见，可以作为参考\n> https://zhuanlan.zhihu.com/p/269761503\n\n‍\n\n## Mybatis主要执行流程：\n\n​![image](/images/assets/image-20231130162207-amricr9.png)​\n\n1. 解析主配置文件，初始化`SqlSessionFactory`​​​\n\n    ```java\n    org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream, java.lang.String, java.util.Properties) {\n    \tXMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n        return build(parser.parse());\n    }\n\n    org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration(XNode root) { \n    \t...\n    \t// 读取environments配置，初始化TransactionFactory 和 DataSourceFactory \n    \tenvironmentsElement(root.evalNode(\"environments\"));\n    \t+--  TransactionFactory txFactory = transactionManagerElement(child.evalNode(\"transactionManager\"));\n        +--   DataSourceFactory dsFactory = dataSourceElement(child.evalNode(\"dataSource\"));\n    \t...\n    \t// 读取mappers配置，并关联读取mapper.xml\n    \tmapperElement(root.evalNode(\"mappers\"));\n    }\n    ```\n\n    * 解析mapper.xml (org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement)\n\n      ​![image](/images/assets/image-20231130153853-ui2udcs.png)​\n\n    ‍\n2. 获取`session`​​​ ，开启事务\n\n    ​![image](/images/assets/image-20231130154646-n3tfgm6.png)​\n\n3. 获取mapper\n\n\t​![image](/images/assets/image-20231130160711-ora87uk.png)​\n\n\t这里其实并没有生成Mapper的实例，因为本身就没有实现类。而是通过`MapperProxyFactory`​创建了一个代理对象。\n\n\t​![image](/images/assets/image-20231130161537-k6jp4kq.png)​\n\n4. 预编译\n\n    * 代理方法根据Sql类型调用相应的方法\n\n\t![image](/images/assets/image-20231130161950-nthyx0q.png)\t​\n\n* 通过执行器调用查询\t ![image](/images/assets/image-20231130162334-wq8knl7.png)​\n\n* ​`StatementHandler`​预编译\n\n  ​![image](/images/assets/image-20231130163419-dlucov7.png)​\n\n5. 执行并解析结果集\t​![image](/images/assets/image-20231130163626-b3ijn8u.png)​\n\n    * 调用ObjectFactory创建需要的类型\n\n    ​![image](/images/assets/image-20231130165000-f9u4xav.png)​\n\n    * 绑定数据库字段和目标resultType属性的对应关系![image](/images/assets/image-20231130165557-5lors2o.png)​\n\n      * 从rs中取值并对应到metadata​![image](/images/assets/image-20231130170131-pfyz6vu.png)​\n\n      ‍\n\n‍\n\n‍\n\n## Mybatis的插件机制\n\n‍\n\n> 看了下mybatis的一些面试题，没啥新鲜的。都是一些应用常识，在跟进几次源码的执行后，心里就大致有个印象了。\n>\n> 下面看看Mybatis的插件机制是如何实现的，这里还是以最常见的分页插件为例。\n\n‍\n\n如何使用参考[[官网]](https://pagehelper.github.io/docs/howtouse/)\n\n‍\n\n### 1 插件都会被注册成为拦截器\n\n​![image](/images/assets/image-20231204111109-ayhkc67.png)​\n\n‍\n\n### 2 `Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法`​\n\n  拦截器中，对doBoundSql本身的处理；\n\n>  需要注意的是：\n>\n> ​`ExecutorUtil.executeAutoCount`​ 方法会把参数拦截、以及Mybatis的相关查询都会执行一次，用户获取count\n\n​![image](/images/assets/image-20231204162214-4g1bw2e.png)​\n\nExecutorUtil.pageQuery 设置完成boundSql后，在预处理的时候，会遍历参数Mappings根据index真正设置参数\n\n​![image](/images/assets/image-20231204174826-1q081wx.png)​\n\n​​\n\n### 分页插件总结\n\n* PageInterceptor\n\n  分页插件的入口，通过实现Mybatis的拦截器进入；如果要分页，先获取count，再添加分页参数查询，并封装Page返回\n* Dialect\n\n  方言：也实现了pageHelper的扩展，包含是否分页判定、前置后置等\n* BoundSqlInterceptor\n\n  一个链式BoundSql 处理器，在分页前中后可对原sql变更\n* PageHelper\n\n  分页插件的主类（implements Dialect, BoundSqlInterceptor.Chain），分页逻辑的主题逻辑入口类\n\n  ‍\n\n‍\n\n---\n\n## Q: JDBC如何通过问号表达式防止SQL注入？\n\n>  预编译会标识该位置为参数类型，而不是原生SQL， 这个设定是MYSQL协议支持的。\n\n‍\n\n>  创建一个PreparedStatement对象，用于向数据库发送参数化的SQL语句。 可以预编译带有或不带有IN参数的SQL语句，并将其存储在PreparedStatement对象中。然后可以使用该对象多次有效地执行该语句。\n\njava.sql.Connection#prepareStatement(java.lang.String)\n\njava.sql.PreparedStatement#setString\n\n‍\n\n预处理协议：\n\nhttps://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html\n\n‍\n","slug":"Mybatis源码","published":1,"updated":"2024-02-18T08:57:05.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyq000fqwvd0v3eh49p","content":"<p>Mybatis是一款优秀的持久层框架，从事java的web方向的同学没有不熟悉的。同时，它的源码也非常适合阅读。 温故而知新~</p>\n<span id=\"more\"></span>\n\n<p>#阅读源码的最好的方式：</p>\n<ol>\n<li>理解主流程</li>\n<li>debug，找主流程的主要类和方法</li>\n<li>带着问题（譬如一些常见面试题）debug</li>\n</ol>\n<blockquote>\n<p>这里有一份阅读Mybatis源码的意见，可以作为参考<br><a href=\"https://zhuanlan.zhihu.com/p/269761503\">https://zhuanlan.zhihu.com/p/269761503</a></p>\n</blockquote>\n<p>‍</p>\n<h2 id=\"Mybatis主要执行流程：\"><a href=\"#Mybatis主要执行流程：\" class=\"headerlink\" title=\"Mybatis主要执行流程：\"></a>Mybatis主要执行流程：</h2><p>​<img src=\"/images/assets/image-20231130162207-amricr9.png\" alt=\"image\">​</p>\n<ol>\n<li><p>解析主配置文件，初始化<code>SqlSessionFactory</code>​​​</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream, java.lang.String, java.util.Properties) &#123;</span><br><span class=\"line\">\tXMLConfigBuilder parser = <span class=\"keyword\">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(parser.parse());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration(XNode root) &#123; </span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 读取environments配置，初始化TransactionFactory 和 DataSourceFactory </span></span><br><span class=\"line\">\tenvironmentsElement(root.evalNode(<span class=\"string\">&quot;environments&quot;</span>));</span><br><span class=\"line\">\t+--  TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class=\"string\">&quot;transactionManager&quot;</span>));</span><br><span class=\"line\">    +--   DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class=\"string\">&quot;dataSource&quot;</span>));</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 读取mappers配置，并关联读取mapper.xml</span></span><br><span class=\"line\">\tmapperElement(root.evalNode(<span class=\"string\">&quot;mappers&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>解析mapper.xml (org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement)</p>\n<p>​<img src=\"/images/assets/image-20231130153853-ui2udcs.png\" alt=\"image\">​</p>\n</li>\n</ul>\n<p> ‍</p>\n</li>\n<li><p>获取<code>session</code>​​​ ，开启事务</p>\n<p> ​<img src=\"/images/assets/image-20231130154646-n3tfgm6.png\" alt=\"image\">​</p>\n</li>\n<li><p>获取mapper</p>\n<p> ​<img src=\"/images/assets/image-20231130160711-ora87uk.png\" alt=\"image\">​</p>\n<p> 这里其实并没有生成Mapper的实例，因为本身就没有实现类。而是通过<code>MapperProxyFactory</code>​创建了一个代理对象。</p>\n<p> ​<img src=\"/images/assets/image-20231130161537-k6jp4kq.png\" alt=\"image\">​</p>\n</li>\n<li><p>预编译</p>\n<ul>\n<li>代理方法根据Sql类型调用相应的方法</li>\n</ul>\n<p> <img src=\"/images/assets/image-20231130161950-nthyx0q.png\" alt=\"image\">\t​</p>\n</li>\n</ol>\n<ul>\n<li><p>通过执行器调用查询\t <img src=\"/images/assets/image-20231130162334-wq8knl7.png\" alt=\"image\">​</p>\n</li>\n<li><p>​<code>StatementHandler</code>​预编译</p>\n<p>​<img src=\"/images/assets/image-20231130163419-dlucov7.png\" alt=\"image\">​</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>执行并解析结果集\t​<img src=\"/images/assets/image-20231130163626-b3ijn8u.png\" alt=\"image\">​</p>\n<ul>\n<li>调用ObjectFactory创建需要的类型</li>\n</ul>\n<p> ​<img src=\"/images/assets/image-20231130165000-f9u4xav.png\" alt=\"image\">​</p>\n<ul>\n<li><p>绑定数据库字段和目标resultType属性的对应关系<img src=\"/images/assets/image-20231130165557-5lors2o.png\" alt=\"image\">​</p>\n<ul>\n<li>从rs中取值并对应到metadata​<img src=\"/images/assets/image-20231130170131-pfyz6vu.png\" alt=\"image\">​</li>\n</ul>\n<p>‍</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"Mybatis的插件机制\"><a href=\"#Mybatis的插件机制\" class=\"headerlink\" title=\"Mybatis的插件机制\"></a>Mybatis的插件机制</h2><p>‍</p>\n<blockquote>\n<p>看了下mybatis的一些面试题，没啥新鲜的。都是一些应用常识，在跟进几次源码的执行后，心里就大致有个印象了。</p>\n<p>下面看看Mybatis的插件机制是如何实现的，这里还是以最常见的分页插件为例。</p>\n</blockquote>\n<p>‍</p>\n<p>如何使用参考<a href=\"https://pagehelper.github.io/docs/howtouse/\">[官网]</a></p>\n<p>‍</p>\n<h3 id=\"1-插件都会被注册成为拦截器\"><a href=\"#1-插件都会被注册成为拦截器\" class=\"headerlink\" title=\"1 插件都会被注册成为拦截器\"></a>1 插件都会被注册成为拦截器</h3><p>​<img src=\"/images/assets/image-20231204111109-ayhkc67.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h3 id=\"2-Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法​\"><a href=\"#2-Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法​\" class=\"headerlink\" title=\"2 Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法​\"></a>2 <code>Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法</code>​</h3><p>  拦截器中，对doBoundSql本身的处理；</p>\n<blockquote>\n<p> 需要注意的是：</p>\n<p>​<code>ExecutorUtil.executeAutoCount</code>​ 方法会把参数拦截、以及Mybatis的相关查询都会执行一次，用户获取count</p>\n</blockquote>\n<p>​<img src=\"/images/assets/image-20231204162214-4g1bw2e.png\" alt=\"image\">​</p>\n<p>ExecutorUtil.pageQuery 设置完成boundSql后，在预处理的时候，会遍历参数Mappings根据index真正设置参数</p>\n<p>​<img src=\"/images/assets/image-20231204174826-1q081wx.png\" alt=\"image\">​</p>\n<p>​​</p>\n<h3 id=\"分页插件总结\"><a href=\"#分页插件总结\" class=\"headerlink\" title=\"分页插件总结\"></a>分页插件总结</h3><ul>\n<li><p>PageInterceptor</p>\n<p>分页插件的入口，通过实现Mybatis的拦截器进入；如果要分页，先获取count，再添加分页参数查询，并封装Page返回</p>\n</li>\n<li><p>Dialect</p>\n<p>方言：也实现了pageHelper的扩展，包含是否分页判定、前置后置等</p>\n</li>\n<li><p>BoundSqlInterceptor</p>\n<p>一个链式BoundSql 处理器，在分页前中后可对原sql变更</p>\n</li>\n<li><p>PageHelper</p>\n<p>分页插件的主类（implements Dialect, BoundSqlInterceptor.Chain），分页逻辑的主题逻辑入口类</p>\n<p>‍</p>\n</li>\n</ul>\n<p>‍</p>\n<hr>\n<h2 id=\"Q-JDBC如何通过问号表达式防止SQL注入？\"><a href=\"#Q-JDBC如何通过问号表达式防止SQL注入？\" class=\"headerlink\" title=\"Q: JDBC如何通过问号表达式防止SQL注入？\"></a>Q: JDBC如何通过问号表达式防止SQL注入？</h2><blockquote>\n<p> 预编译会标识该位置为参数类型，而不是原生SQL， 这个设定是MYSQL协议支持的。</p>\n</blockquote>\n<p>‍</p>\n<blockquote>\n<p> 创建一个PreparedStatement对象，用于向数据库发送参数化的SQL语句。 可以预编译带有或不带有IN参数的SQL语句，并将其存储在PreparedStatement对象中。然后可以使用该对象多次有效地执行该语句。</p>\n</blockquote>\n<p>java.sql.Connection#prepareStatement(java.lang.String)</p>\n<p>java.sql.PreparedStatement#setString</p>\n<p>‍</p>\n<p>预处理协议：</p>\n<p><a href=\"https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html\">https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html</a></p>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>Mybatis是一款优秀的持久层框架，从事java的web方向的同学没有不熟悉的。同时，它的源码也非常适合阅读。 温故而知新~</p>","more":"<p>#阅读源码的最好的方式：</p>\n<ol>\n<li>理解主流程</li>\n<li>debug，找主流程的主要类和方法</li>\n<li>带着问题（譬如一些常见面试题）debug</li>\n</ol>\n<blockquote>\n<p>这里有一份阅读Mybatis源码的意见，可以作为参考<br><a href=\"https://zhuanlan.zhihu.com/p/269761503\">https://zhuanlan.zhihu.com/p/269761503</a></p>\n</blockquote>\n<p>‍</p>\n<h2 id=\"Mybatis主要执行流程：\"><a href=\"#Mybatis主要执行流程：\" class=\"headerlink\" title=\"Mybatis主要执行流程：\"></a>Mybatis主要执行流程：</h2><p>​<img src=\"/images/assets/image-20231130162207-amricr9.png\" alt=\"image\">​</p>\n<ol>\n<li><p>解析主配置文件，初始化<code>SqlSessionFactory</code>​​​</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream, java.lang.String, java.util.Properties) &#123;</span><br><span class=\"line\">\tXMLConfigBuilder parser = <span class=\"keyword\">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(parser.parse());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration(XNode root) &#123; </span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 读取environments配置，初始化TransactionFactory 和 DataSourceFactory </span></span><br><span class=\"line\">\tenvironmentsElement(root.evalNode(<span class=\"string\">&quot;environments&quot;</span>));</span><br><span class=\"line\">\t+--  TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class=\"string\">&quot;transactionManager&quot;</span>));</span><br><span class=\"line\">    +--   DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class=\"string\">&quot;dataSource&quot;</span>));</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 读取mappers配置，并关联读取mapper.xml</span></span><br><span class=\"line\">\tmapperElement(root.evalNode(<span class=\"string\">&quot;mappers&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>解析mapper.xml (org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement)</p>\n<p>​<img src=\"/images/assets/image-20231130153853-ui2udcs.png\" alt=\"image\">​</p>\n</li>\n</ul>\n<p> ‍</p>\n</li>\n<li><p>获取<code>session</code>​​​ ，开启事务</p>\n<p> ​<img src=\"/images/assets/image-20231130154646-n3tfgm6.png\" alt=\"image\">​</p>\n</li>\n<li><p>获取mapper</p>\n<p> ​<img src=\"/images/assets/image-20231130160711-ora87uk.png\" alt=\"image\">​</p>\n<p> 这里其实并没有生成Mapper的实例，因为本身就没有实现类。而是通过<code>MapperProxyFactory</code>​创建了一个代理对象。</p>\n<p> ​<img src=\"/images/assets/image-20231130161537-k6jp4kq.png\" alt=\"image\">​</p>\n</li>\n<li><p>预编译</p>\n<ul>\n<li>代理方法根据Sql类型调用相应的方法</li>\n</ul>\n<p> <img src=\"/images/assets/image-20231130161950-nthyx0q.png\" alt=\"image\">\t​</p>\n</li>\n</ol>\n<ul>\n<li><p>通过执行器调用查询\t <img src=\"/images/assets/image-20231130162334-wq8knl7.png\" alt=\"image\">​</p>\n</li>\n<li><p>​<code>StatementHandler</code>​预编译</p>\n<p>​<img src=\"/images/assets/image-20231130163419-dlucov7.png\" alt=\"image\">​</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>执行并解析结果集\t​<img src=\"/images/assets/image-20231130163626-b3ijn8u.png\" alt=\"image\">​</p>\n<ul>\n<li>调用ObjectFactory创建需要的类型</li>\n</ul>\n<p> ​<img src=\"/images/assets/image-20231130165000-f9u4xav.png\" alt=\"image\">​</p>\n<ul>\n<li><p>绑定数据库字段和目标resultType属性的对应关系<img src=\"/images/assets/image-20231130165557-5lors2o.png\" alt=\"image\">​</p>\n<ul>\n<li>从rs中取值并对应到metadata​<img src=\"/images/assets/image-20231130170131-pfyz6vu.png\" alt=\"image\">​</li>\n</ul>\n<p>‍</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"Mybatis的插件机制\"><a href=\"#Mybatis的插件机制\" class=\"headerlink\" title=\"Mybatis的插件机制\"></a>Mybatis的插件机制</h2><p>‍</p>\n<blockquote>\n<p>看了下mybatis的一些面试题，没啥新鲜的。都是一些应用常识，在跟进几次源码的执行后，心里就大致有个印象了。</p>\n<p>下面看看Mybatis的插件机制是如何实现的，这里还是以最常见的分页插件为例。</p>\n</blockquote>\n<p>‍</p>\n<p>如何使用参考<a href=\"https://pagehelper.github.io/docs/howtouse/\">[官网]</a></p>\n<p>‍</p>\n<h3 id=\"1-插件都会被注册成为拦截器\"><a href=\"#1-插件都会被注册成为拦截器\" class=\"headerlink\" title=\"1 插件都会被注册成为拦截器\"></a>1 插件都会被注册成为拦截器</h3><p>​<img src=\"/images/assets/image-20231204111109-ayhkc67.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h3 id=\"2-Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法​\"><a href=\"#2-Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法​\" class=\"headerlink\" title=\"2 Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法​\"></a>2 <code>Plugin是拦截器的实现，执行SQL时候会通过动态代理调用PageHelper中的拦截方法</code>​</h3><p>  拦截器中，对doBoundSql本身的处理；</p>\n<blockquote>\n<p> 需要注意的是：</p>\n<p>​<code>ExecutorUtil.executeAutoCount</code>​ 方法会把参数拦截、以及Mybatis的相关查询都会执行一次，用户获取count</p>\n</blockquote>\n<p>​<img src=\"/images/assets/image-20231204162214-4g1bw2e.png\" alt=\"image\">​</p>\n<p>ExecutorUtil.pageQuery 设置完成boundSql后，在预处理的时候，会遍历参数Mappings根据index真正设置参数</p>\n<p>​<img src=\"/images/assets/image-20231204174826-1q081wx.png\" alt=\"image\">​</p>\n<p>​​</p>\n<h3 id=\"分页插件总结\"><a href=\"#分页插件总结\" class=\"headerlink\" title=\"分页插件总结\"></a>分页插件总结</h3><ul>\n<li><p>PageInterceptor</p>\n<p>分页插件的入口，通过实现Mybatis的拦截器进入；如果要分页，先获取count，再添加分页参数查询，并封装Page返回</p>\n</li>\n<li><p>Dialect</p>\n<p>方言：也实现了pageHelper的扩展，包含是否分页判定、前置后置等</p>\n</li>\n<li><p>BoundSqlInterceptor</p>\n<p>一个链式BoundSql 处理器，在分页前中后可对原sql变更</p>\n</li>\n<li><p>PageHelper</p>\n<p>分页插件的主类（implements Dialect, BoundSqlInterceptor.Chain），分页逻辑的主题逻辑入口类</p>\n<p>‍</p>\n</li>\n</ul>\n<p>‍</p>\n<hr>\n<h2 id=\"Q-JDBC如何通过问号表达式防止SQL注入？\"><a href=\"#Q-JDBC如何通过问号表达式防止SQL注入？\" class=\"headerlink\" title=\"Q: JDBC如何通过问号表达式防止SQL注入？\"></a>Q: JDBC如何通过问号表达式防止SQL注入？</h2><blockquote>\n<p> 预编译会标识该位置为参数类型，而不是原生SQL， 这个设定是MYSQL协议支持的。</p>\n</blockquote>\n<p>‍</p>\n<blockquote>\n<p> 创建一个PreparedStatement对象，用于向数据库发送参数化的SQL语句。 可以预编译带有或不带有IN参数的SQL语句，并将其存储在PreparedStatement对象中。然后可以使用该对象多次有效地执行该语句。</p>\n</blockquote>\n<p>java.sql.Connection#prepareStatement(java.lang.String)</p>\n<p>java.sql.PreparedStatement#setString</p>\n<p>‍</p>\n<p>预处理协议：</p>\n<p><a href=\"https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html\">https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html</a></p>\n<p>‍</p>"},{"title":"Nacos源码","date":"2024-04-29T02:35:48.000Z","_content":"","source":"_posts/Nacos源码.md","raw":"---\ntitle: Nacos源码\ndate: 2024-04-29 10:35:48\ntags:\n---\n","slug":"Nacos源码","published":1,"updated":"2024-04-29T02:35:48.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyr000jqwvddofq7bjf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"OLAP浅入","date":"2023-05-06T05:13:27.000Z","_content":"随着业务的发展，数据时常是指数级增长，数据提取/BI报表/数据挖掘总是被提及。那么如何支撑？如何建设数仓，如何支持实时分析?\n\n<!--more-->\n\n# 序\n传统行业随着业务深入，无可避免会涉及BI的需要。用传统的PGSQL有点跟不上时代，也跟不上BOSS门的'奇思妙想'了，大刀阔斧的追赶潮流又缺人缺资源。想选择最优实践方案，就必须'货比三家'，打开自己的脑壳。以下：  \n\n[Doris的应用，360数仓演进进程](https://mp.weixin.qq.com/s/2oeEcqgLEbbPZHnp0kAElQ)\n\n\n[OLAP介绍](https://zhuanlan.zhihu.com/p/448265353)\n\n  \n[开源OLAP引擎对比](https://segmentfault.com/a/1190000040428093)\n\n\n## ClickHouse\n\n- 官网安装体验  \n安装(https://clickhouse.com/docs/zh/getting-started/\ninstall)\n\n- 导入数据  \n支持外表引擎和第三方工具(https://cloud.tencent.com/developer/beta/article/1602662)\n\n\n## Doris\n[Doris简史](https://zhuanlan.zhihu.com/p/387050823)\n\n\n## Doris与ClickHouse对比\n[自己构建更复杂的用ClickHouse，省力用Doris](https://zhuanlan.zhihu.com/p/421469439)  \n实则Doris脱胎于百度广告业务，国内社区资源更丰富,可以看下[其他公司的实践](https://doris.apache.org/zh-CN/blog/)  \n\n![](https://cdn-tencent.selectdb.com/zh-CN/assets/images/page_3-zh-bb25c0ea2faa03912dea231b8b207d3e.png)\n","source":"_posts/OLAP浅入.md","raw":"---\ntitle: OLAP浅入\ndate: 2023-05-06 13:13:27\ntags:\n    - OLAP\n    - clickhouse\ncategories: 大数据\n---\n随着业务的发展，数据时常是指数级增长，数据提取/BI报表/数据挖掘总是被提及。那么如何支撑？如何建设数仓，如何支持实时分析?\n\n<!--more-->\n\n# 序\n传统行业随着业务深入，无可避免会涉及BI的需要。用传统的PGSQL有点跟不上时代，也跟不上BOSS门的'奇思妙想'了，大刀阔斧的追赶潮流又缺人缺资源。想选择最优实践方案，就必须'货比三家'，打开自己的脑壳。以下：  \n\n[Doris的应用，360数仓演进进程](https://mp.weixin.qq.com/s/2oeEcqgLEbbPZHnp0kAElQ)\n\n\n[OLAP介绍](https://zhuanlan.zhihu.com/p/448265353)\n\n  \n[开源OLAP引擎对比](https://segmentfault.com/a/1190000040428093)\n\n\n## ClickHouse\n\n- 官网安装体验  \n安装(https://clickhouse.com/docs/zh/getting-started/\ninstall)\n\n- 导入数据  \n支持外表引擎和第三方工具(https://cloud.tencent.com/developer/beta/article/1602662)\n\n\n## Doris\n[Doris简史](https://zhuanlan.zhihu.com/p/387050823)\n\n\n## Doris与ClickHouse对比\n[自己构建更复杂的用ClickHouse，省力用Doris](https://zhuanlan.zhihu.com/p/421469439)  \n实则Doris脱胎于百度广告业务，国内社区资源更丰富,可以看下[其他公司的实践](https://doris.apache.org/zh-CN/blog/)  \n\n![](https://cdn-tencent.selectdb.com/zh-CN/assets/images/page_3-zh-bb25c0ea2faa03912dea231b8b207d3e.png)\n","slug":"OLAP浅入","published":1,"updated":"2024-02-18T08:25:42.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyr000kqwvd17bke0pd","content":"<p>随着业务的发展，数据时常是指数级增长，数据提取&#x2F;BI报表&#x2F;数据挖掘总是被提及。那么如何支撑？如何建设数仓，如何支持实时分析?</p>\n<span id=\"more\"></span>\n\n<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>传统行业随着业务深入，无可避免会涉及BI的需要。用传统的PGSQL有点跟不上时代，也跟不上BOSS门的’奇思妙想’了，大刀阔斧的追赶潮流又缺人缺资源。想选择最优实践方案，就必须’货比三家’，打开自己的脑壳。以下：  </p>\n<p><a href=\"https://mp.weixin.qq.com/s/2oeEcqgLEbbPZHnp0kAElQ\">Doris的应用，360数仓演进进程</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/448265353\">OLAP介绍</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000040428093\">开源OLAP引擎对比</a></p>\n<h2 id=\"ClickHouse\"><a href=\"#ClickHouse\" class=\"headerlink\" title=\"ClickHouse\"></a>ClickHouse</h2><ul>\n<li><p>官网安装体验<br>安装(<a href=\"https://clickhouse.com/docs/zh/getting-started/\">https://clickhouse.com/docs/zh/getting-started/</a><br>install)</p>\n</li>\n<li><p>导入数据<br>支持外表引擎和第三方工具(<a href=\"https://cloud.tencent.com/developer/beta/article/1602662\">https://cloud.tencent.com/developer/beta/article/1602662</a>)</p>\n</li>\n</ul>\n<h2 id=\"Doris\"><a href=\"#Doris\" class=\"headerlink\" title=\"Doris\"></a>Doris</h2><p><a href=\"https://zhuanlan.zhihu.com/p/387050823\">Doris简史</a></p>\n<h2 id=\"Doris与ClickHouse对比\"><a href=\"#Doris与ClickHouse对比\" class=\"headerlink\" title=\"Doris与ClickHouse对比\"></a>Doris与ClickHouse对比</h2><p><a href=\"https://zhuanlan.zhihu.com/p/421469439\">自己构建更复杂的用ClickHouse，省力用Doris</a><br>实则Doris脱胎于百度广告业务，国内社区资源更丰富,可以看下<a href=\"https://doris.apache.org/zh-CN/blog/\">其他公司的实践</a>  </p>\n<p><img src=\"https://cdn-tencent.selectdb.com/zh-CN/assets/images/page_3-zh-bb25c0ea2faa03912dea231b8b207d3e.png\"></p>\n","site":{"data":{}},"excerpt":"<p>随着业务的发展，数据时常是指数级增长，数据提取&#x2F;BI报表&#x2F;数据挖掘总是被提及。那么如何支撑？如何建设数仓，如何支持实时分析?</p>","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>传统行业随着业务深入，无可避免会涉及BI的需要。用传统的PGSQL有点跟不上时代，也跟不上BOSS门的’奇思妙想’了，大刀阔斧的追赶潮流又缺人缺资源。想选择最优实践方案，就必须’货比三家’，打开自己的脑壳。以下：  </p>\n<p><a href=\"https://mp.weixin.qq.com/s/2oeEcqgLEbbPZHnp0kAElQ\">Doris的应用，360数仓演进进程</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/448265353\">OLAP介绍</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000040428093\">开源OLAP引擎对比</a></p>\n<h2 id=\"ClickHouse\"><a href=\"#ClickHouse\" class=\"headerlink\" title=\"ClickHouse\"></a>ClickHouse</h2><ul>\n<li><p>官网安装体验<br>安装(<a href=\"https://clickhouse.com/docs/zh/getting-started/\">https://clickhouse.com/docs/zh/getting-started/</a><br>install)</p>\n</li>\n<li><p>导入数据<br>支持外表引擎和第三方工具(<a href=\"https://cloud.tencent.com/developer/beta/article/1602662\">https://cloud.tencent.com/developer/beta/article/1602662</a>)</p>\n</li>\n</ul>\n<h2 id=\"Doris\"><a href=\"#Doris\" class=\"headerlink\" title=\"Doris\"></a>Doris</h2><p><a href=\"https://zhuanlan.zhihu.com/p/387050823\">Doris简史</a></p>\n<h2 id=\"Doris与ClickHouse对比\"><a href=\"#Doris与ClickHouse对比\" class=\"headerlink\" title=\"Doris与ClickHouse对比\"></a>Doris与ClickHouse对比</h2><p><a href=\"https://zhuanlan.zhihu.com/p/421469439\">自己构建更复杂的用ClickHouse，省力用Doris</a><br>实则Doris脱胎于百度广告业务，国内社区资源更丰富,可以看下<a href=\"https://doris.apache.org/zh-CN/blog/\">其他公司的实践</a>  </p>\n<p><img src=\"https://cdn-tencent.selectdb.com/zh-CN/assets/images/page_3-zh-bb25c0ea2faa03912dea231b8b207d3e.png\"></p>"},{"title":"RBAC权限模型","date":"2024-01-16T09:05:39.000Z","_content":"权限管理模型有很多，但是最为经典实用的还是RBAC。若想设计权限模型或对其进行扩展，了解RBAC是必不可少的功课\n<!--more-->\n# RBAC权限模型\n\n## Role-BasedAccess Control\n\n* 传统：直接对用户授权\n* RBAC: 基于角色的权限管理\n\n​![image](/images/assets/image-20240116165959-vy9w5gu.png)​\n\n‍\n\n## RBAC0 : 用户与权限分离\n\n​![image](/images/assets/image-20240116170020-sq3x22z.png)​\n\n‍\n\n## RBAC1 :角色存在层级，低级角色可以继承高级角色权限\n\n​![image](/images/assets/image-20240116170034-fs3xv9q.png)​\n\n‍\n\n‍\n\n## RBAC2 : 角色存在互斥关系，获取有限制条件\n\n​![image](/images/assets/image-20240116170050-p7vvxyi.png)​\n\n* 静态：互斥角色无法赋予同一用户\n* 动态：登录时切换角色\n\n‍\n\n## RBAC3 统一角色模型\n\nRBAC3=RBAC1+RBAC2\n\n---\n\n- 思考  \nRBAC基本能满足大部分的授权要求，但是在一些实际业务场景中，时常会遇到需要对部分数据、按钮的进行“隐藏”（或授权才可访问）的需求。  \n这时候，基于属性的访问控制模型(ABAC: Attribute-Based Access Control)或可满足需求。但是这种过于分散的模型本身并无实际意义，在实际业务中还是需要去落实到具体组件、行为。  \n\n比如：  \n1、RBAC模型中可以建立互斥抽象的高级角色来对应一些限制行为  \n2、对于访问类要求，可以参考JeecgBoot的PermissionData](http://doc.jeecg.com/2044046)，允许用户自定义访问规则\n\n","source":"_posts/RBAC权限模型.md","raw":"---\ntitle: RBAC权限模型\ndate: 2024-01-16 17:05:39\ntags: \n- RBAC\ncategories: 其他\n---\n权限管理模型有很多，但是最为经典实用的还是RBAC。若想设计权限模型或对其进行扩展，了解RBAC是必不可少的功课\n<!--more-->\n# RBAC权限模型\n\n## Role-BasedAccess Control\n\n* 传统：直接对用户授权\n* RBAC: 基于角色的权限管理\n\n​![image](/images/assets/image-20240116165959-vy9w5gu.png)​\n\n‍\n\n## RBAC0 : 用户与权限分离\n\n​![image](/images/assets/image-20240116170020-sq3x22z.png)​\n\n‍\n\n## RBAC1 :角色存在层级，低级角色可以继承高级角色权限\n\n​![image](/images/assets/image-20240116170034-fs3xv9q.png)​\n\n‍\n\n‍\n\n## RBAC2 : 角色存在互斥关系，获取有限制条件\n\n​![image](/images/assets/image-20240116170050-p7vvxyi.png)​\n\n* 静态：互斥角色无法赋予同一用户\n* 动态：登录时切换角色\n\n‍\n\n## RBAC3 统一角色模型\n\nRBAC3=RBAC1+RBAC2\n\n---\n\n- 思考  \nRBAC基本能满足大部分的授权要求，但是在一些实际业务场景中，时常会遇到需要对部分数据、按钮的进行“隐藏”（或授权才可访问）的需求。  \n这时候，基于属性的访问控制模型(ABAC: Attribute-Based Access Control)或可满足需求。但是这种过于分散的模型本身并无实际意义，在实际业务中还是需要去落实到具体组件、行为。  \n\n比如：  \n1、RBAC模型中可以建立互斥抽象的高级角色来对应一些限制行为  \n2、对于访问类要求，可以参考JeecgBoot的PermissionData](http://doc.jeecg.com/2044046)，允许用户自定义访问规则\n\n","slug":"RBAC权限模型","published":1,"updated":"2024-04-11T03:39:16.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyt000oqwvd75mt7p2v","content":"<p>权限管理模型有很多，但是最为经典实用的还是RBAC。若想设计权限模型或对其进行扩展，了解RBAC是必不可少的功课</p>\n<span id=\"more\"></span>\n<h1 id=\"RBAC权限模型\"><a href=\"#RBAC权限模型\" class=\"headerlink\" title=\"RBAC权限模型\"></a>RBAC权限模型</h1><h2 id=\"Role-BasedAccess-Control\"><a href=\"#Role-BasedAccess-Control\" class=\"headerlink\" title=\"Role-BasedAccess Control\"></a>Role-BasedAccess Control</h2><ul>\n<li>传统：直接对用户授权</li>\n<li>RBAC: 基于角色的权限管理</li>\n</ul>\n<p>​<img src=\"/images/assets/image-20240116165959-vy9w5gu.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"RBAC0-用户与权限分离\"><a href=\"#RBAC0-用户与权限分离\" class=\"headerlink\" title=\"RBAC0 : 用户与权限分离\"></a>RBAC0 : 用户与权限分离</h2><p>​<img src=\"/images/assets/image-20240116170020-sq3x22z.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"RBAC1-角色存在层级，低级角色可以继承高级角色权限\"><a href=\"#RBAC1-角色存在层级，低级角色可以继承高级角色权限\" class=\"headerlink\" title=\"RBAC1 :角色存在层级，低级角色可以继承高级角色权限\"></a>RBAC1 :角色存在层级，低级角色可以继承高级角色权限</h2><p>​<img src=\"/images/assets/image-20240116170034-fs3xv9q.png\" alt=\"image\">​</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"RBAC2-角色存在互斥关系，获取有限制条件\"><a href=\"#RBAC2-角色存在互斥关系，获取有限制条件\" class=\"headerlink\" title=\"RBAC2 : 角色存在互斥关系，获取有限制条件\"></a>RBAC2 : 角色存在互斥关系，获取有限制条件</h2><p>​<img src=\"/images/assets/image-20240116170050-p7vvxyi.png\" alt=\"image\">​</p>\n<ul>\n<li>静态：互斥角色无法赋予同一用户</li>\n<li>动态：登录时切换角色</li>\n</ul>\n<p>‍</p>\n<h2 id=\"RBAC3-统一角色模型\"><a href=\"#RBAC3-统一角色模型\" class=\"headerlink\" title=\"RBAC3 统一角色模型\"></a>RBAC3 统一角色模型</h2><p>RBAC3&#x3D;RBAC1+RBAC2</p>\n<hr>\n<ul>\n<li>思考<br>RBAC基本能满足大部分的授权要求，但是在一些实际业务场景中，时常会遇到需要对部分数据、按钮的进行“隐藏”（或授权才可访问）的需求。<br>这时候，基于属性的访问控制模型(ABAC: Attribute-Based Access Control)或可满足需求。但是这种过于分散的模型本身并无实际意义，在实际业务中还是需要去落实到具体组件、行为。</li>\n</ul>\n<p>比如：<br>1、RBAC模型中可以建立互斥抽象的高级角色来对应一些限制行为<br>2、对于访问类要求，可以参考JeecgBoot的PermissionData](<a href=\"http://doc.jeecg.com/2044046)%EF%BC%8C%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99\">http://doc.jeecg.com/2044046)，允许用户自定义访问规则</a></p>\n","site":{"data":{}},"excerpt":"<p>权限管理模型有很多，但是最为经典实用的还是RBAC。若想设计权限模型或对其进行扩展，了解RBAC是必不可少的功课</p>","more":"<h1 id=\"RBAC权限模型\"><a href=\"#RBAC权限模型\" class=\"headerlink\" title=\"RBAC权限模型\"></a>RBAC权限模型</h1><h2 id=\"Role-BasedAccess-Control\"><a href=\"#Role-BasedAccess-Control\" class=\"headerlink\" title=\"Role-BasedAccess Control\"></a>Role-BasedAccess Control</h2><ul>\n<li>传统：直接对用户授权</li>\n<li>RBAC: 基于角色的权限管理</li>\n</ul>\n<p>​<img src=\"/images/assets/image-20240116165959-vy9w5gu.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"RBAC0-用户与权限分离\"><a href=\"#RBAC0-用户与权限分离\" class=\"headerlink\" title=\"RBAC0 : 用户与权限分离\"></a>RBAC0 : 用户与权限分离</h2><p>​<img src=\"/images/assets/image-20240116170020-sq3x22z.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"RBAC1-角色存在层级，低级角色可以继承高级角色权限\"><a href=\"#RBAC1-角色存在层级，低级角色可以继承高级角色权限\" class=\"headerlink\" title=\"RBAC1 :角色存在层级，低级角色可以继承高级角色权限\"></a>RBAC1 :角色存在层级，低级角色可以继承高级角色权限</h2><p>​<img src=\"/images/assets/image-20240116170034-fs3xv9q.png\" alt=\"image\">​</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"RBAC2-角色存在互斥关系，获取有限制条件\"><a href=\"#RBAC2-角色存在互斥关系，获取有限制条件\" class=\"headerlink\" title=\"RBAC2 : 角色存在互斥关系，获取有限制条件\"></a>RBAC2 : 角色存在互斥关系，获取有限制条件</h2><p>​<img src=\"/images/assets/image-20240116170050-p7vvxyi.png\" alt=\"image\">​</p>\n<ul>\n<li>静态：互斥角色无法赋予同一用户</li>\n<li>动态：登录时切换角色</li>\n</ul>\n<p>‍</p>\n<h2 id=\"RBAC3-统一角色模型\"><a href=\"#RBAC3-统一角色模型\" class=\"headerlink\" title=\"RBAC3 统一角色模型\"></a>RBAC3 统一角色模型</h2><p>RBAC3&#x3D;RBAC1+RBAC2</p>\n<hr>\n<ul>\n<li>思考<br>RBAC基本能满足大部分的授权要求，但是在一些实际业务场景中，时常会遇到需要对部分数据、按钮的进行“隐藏”（或授权才可访问）的需求。<br>这时候，基于属性的访问控制模型(ABAC: Attribute-Based Access Control)或可满足需求。但是这种过于分散的模型本身并无实际意义，在实际业务中还是需要去落实到具体组件、行为。</li>\n</ul>\n<p>比如：<br>1、RBAC模型中可以建立互斥抽象的高级角色来对应一些限制行为<br>2、对于访问类要求，可以参考JeecgBoot的PermissionData](<a href=\"http://doc.jeecg.com/2044046)%EF%BC%8C%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99\">http://doc.jeecg.com/2044046)，允许用户自定义访问规则</a></p>"},{"title":"RedLock","date":"2023-08-01T07:26:24.000Z","_content":"RedLock是一种分布式锁的实现方式，算法思想很好理解：假设有N个相互独立无任何协作的Redis master，在每个master上使用单机Redis的加锁方式加锁。当有N/2+1个节点加锁成功，即获取分布式锁成功；否则在所有实例上解锁。\n<!--more-->\n\n# 客户端行为\n1. 获取当前Unix时间，以毫秒为单位。\n2. 依次尝试从N个Master实例使用相同的key和随机值获取锁（假设这个key是LOCK_KEY）。当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。\n3. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。\n4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。\n5. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。  \n> 参考:    \n    [RedLock算法理解](https://zhuanlan.zhihu.com/p/374732293)\n\n# 使用场景\n- 存在网络分区\n- 集群存在故障转移，需要容错  \n  \n## 分布式锁说明\n一般说的redis分布式锁，其实是针对多个客户端获取锁和释放锁，redis分布式锁需要保证操作的原子性。这种情况下的，一般一个redis集群中就只有1个master，分布式锁的获取只是单机操作（包括redisson的getLock）。  \n而如果是cluster集群模式，不同key分布在不同的master上；或者在哨兵模式集群之上加一次负载均衡，串联多个哨兵集群作为一个大集群。针对这种相互独立的多个Master，需要加上一个分布式锁的话，Redis官方推出了一个规范的算法：RedLock。\n> 参考：  \n    [Redis的三种集群模式](https://zhuanlan.zhihu.com/p/145186839)  \n\n## 通过jedis获取分布式锁\n``` java \nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.params.SetParams;\nimport java.util.Collections;\n\npublic class RedisLock {\n\n    private static final Long RELEASE_SUCCESS = 1L;\n    private static final String LOCK_SUCCESS = \"OK\";\n    private static final String KEY_PREFIX=\"DE_BATCH_LOCK_\";\n\n    /**\n     * 释放分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @return 是否释放成功\n     */\n    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n\n        String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n        Object result = jedis.eval(script, Collections.singletonList(KEY_PREFIX+lockKey), Collections.singletonList(requestId));\n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n    }\n\n\n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间 s\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, Integer expireTime) {\n        SetParams params = SetParams.setParams().nx();\n        if (expireTime != null) {\n            params.ex(expireTime);\n        }\n        String result = jedis.set(KEY_PREFIX+lockKey, requestId, params);\n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        String value=jedis.get(KEY_PREFIX+lockKey);\n        logger.error(\"try get lock failed，current value = \" + value);\n        return false;\n    }\n}    \n```\n\n\n## 通过Redisson获取分布式锁\n``` java\nRedissonClient client = Redisson.create(config);\nRLock lock = getClient().getLock(lockKey);\nlock.tryLock(waitTime, leaseTime, unit);\n// lock.lock()是阻塞方法 \n```\n\n# 基于Redisson的RedLock实现\n\n``` java\nRLock lock1 = redissonClient1.getLock(lockKey);\nRLock lock2 = redissonClient2.getLock(lockKey);\nRLock lock3 = redissonClient3.getLock(lockKey);\n// 向3个master加锁\nRedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);\nboolean isLock;\ntry {\n    isLock = redLock.tryLock(1, 10, TimeUnit.SECONDS);\n    if (isLock) {\n        // do something;\n    }\n} catch (Exception e) {\n    e.printStackTrace();\n} finally {\n    redLock.unlock();\n}\n```\n\n\n\n\n\n","source":"_posts/RedLock.md","raw":"---\ntitle: RedLock\ndate: 2023-08-01 15:26:24\ntags: redis\ncategories: 中间件\n---\nRedLock是一种分布式锁的实现方式，算法思想很好理解：假设有N个相互独立无任何协作的Redis master，在每个master上使用单机Redis的加锁方式加锁。当有N/2+1个节点加锁成功，即获取分布式锁成功；否则在所有实例上解锁。\n<!--more-->\n\n# 客户端行为\n1. 获取当前Unix时间，以毫秒为单位。\n2. 依次尝试从N个Master实例使用相同的key和随机值获取锁（假设这个key是LOCK_KEY）。当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。\n3. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。\n4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。\n5. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。  \n> 参考:    \n    [RedLock算法理解](https://zhuanlan.zhihu.com/p/374732293)\n\n# 使用场景\n- 存在网络分区\n- 集群存在故障转移，需要容错  \n  \n## 分布式锁说明\n一般说的redis分布式锁，其实是针对多个客户端获取锁和释放锁，redis分布式锁需要保证操作的原子性。这种情况下的，一般一个redis集群中就只有1个master，分布式锁的获取只是单机操作（包括redisson的getLock）。  \n而如果是cluster集群模式，不同key分布在不同的master上；或者在哨兵模式集群之上加一次负载均衡，串联多个哨兵集群作为一个大集群。针对这种相互独立的多个Master，需要加上一个分布式锁的话，Redis官方推出了一个规范的算法：RedLock。\n> 参考：  \n    [Redis的三种集群模式](https://zhuanlan.zhihu.com/p/145186839)  \n\n## 通过jedis获取分布式锁\n``` java \nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.params.SetParams;\nimport java.util.Collections;\n\npublic class RedisLock {\n\n    private static final Long RELEASE_SUCCESS = 1L;\n    private static final String LOCK_SUCCESS = \"OK\";\n    private static final String KEY_PREFIX=\"DE_BATCH_LOCK_\";\n\n    /**\n     * 释放分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @return 是否释放成功\n     */\n    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n\n        String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n        Object result = jedis.eval(script, Collections.singletonList(KEY_PREFIX+lockKey), Collections.singletonList(requestId));\n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n    }\n\n\n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间 s\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, Integer expireTime) {\n        SetParams params = SetParams.setParams().nx();\n        if (expireTime != null) {\n            params.ex(expireTime);\n        }\n        String result = jedis.set(KEY_PREFIX+lockKey, requestId, params);\n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        String value=jedis.get(KEY_PREFIX+lockKey);\n        logger.error(\"try get lock failed，current value = \" + value);\n        return false;\n    }\n}    \n```\n\n\n## 通过Redisson获取分布式锁\n``` java\nRedissonClient client = Redisson.create(config);\nRLock lock = getClient().getLock(lockKey);\nlock.tryLock(waitTime, leaseTime, unit);\n// lock.lock()是阻塞方法 \n```\n\n# 基于Redisson的RedLock实现\n\n``` java\nRLock lock1 = redissonClient1.getLock(lockKey);\nRLock lock2 = redissonClient2.getLock(lockKey);\nRLock lock3 = redissonClient3.getLock(lockKey);\n// 向3个master加锁\nRedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);\nboolean isLock;\ntry {\n    isLock = redLock.tryLock(1, 10, TimeUnit.SECONDS);\n    if (isLock) {\n        // do something;\n    }\n} catch (Exception e) {\n    e.printStackTrace();\n} finally {\n    redLock.unlock();\n}\n```\n\n\n\n\n\n","slug":"RedLock","published":1,"updated":"2024-02-18T08:29:17.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyv000wqwvdad6ver4m","content":"<p>RedLock是一种分布式锁的实现方式，算法思想很好理解：假设有N个相互独立无任何协作的Redis master，在每个master上使用单机Redis的加锁方式加锁。当有N&#x2F;2+1个节点加锁成功，即获取分布式锁成功；否则在所有实例上解锁。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"客户端行为\"><a href=\"#客户端行为\" class=\"headerlink\" title=\"客户端行为\"></a>客户端行为</h1><ol>\n<li>获取当前Unix时间，以毫秒为单位。</li>\n<li>依次尝试从N个Master实例使用相同的key和随机值获取锁（假设这个key是LOCK_KEY）。当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>\n<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>\n<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>\n<li>如果因为某些原因，获取锁失败（没有在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。  <blockquote>\n<p>参考:<br> <a href=\"https://zhuanlan.zhihu.com/p/374732293\">RedLock算法理解</a></p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><ul>\n<li>存在网络分区</li>\n<li>集群存在故障转移，需要容错</li>\n</ul>\n<h2 id=\"分布式锁说明\"><a href=\"#分布式锁说明\" class=\"headerlink\" title=\"分布式锁说明\"></a>分布式锁说明</h2><p>一般说的redis分布式锁，其实是针对多个客户端获取锁和释放锁，redis分布式锁需要保证操作的原子性。这种情况下的，一般一个redis集群中就只有1个master，分布式锁的获取只是单机操作（包括redisson的getLock）。<br>而如果是cluster集群模式，不同key分布在不同的master上；或者在哨兵模式集群之上加一次负载均衡，串联多个哨兵集群作为一个大集群。针对这种相互独立的多个Master，需要加上一个分布式锁的话，Redis官方推出了一个规范的算法：RedLock。</p>\n<blockquote>\n<p>参考：<br>    <a href=\"https://zhuanlan.zhihu.com/p/145186839\">Redis的三种集群模式</a>  </p>\n</blockquote>\n<h2 id=\"通过jedis获取分布式锁\"><a href=\"#通过jedis获取分布式锁\" class=\"headerlink\" title=\"通过jedis获取分布式锁\"></a>通过jedis获取分布式锁</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.params.SetParams;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long RELEASE_SUCCESS = <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_SUCCESS = <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY_PREFIX=<span class=\"string\">&quot;DE_BATCH_LOCK_&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey 锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否释放成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String script = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class=\"line\">        Object result = jedis.eval(script, Collections.singletonList(KEY_PREFIX+lockKey), Collections.singletonList(requestId));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey 锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireTime 超期时间 s</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否获取成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryGetDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId, Integer expireTime)</span> </span>&#123;</span><br><span class=\"line\">        SetParams params = SetParams.setParams().nx();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expireTime != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            params.ex(expireTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String result = jedis.set(KEY_PREFIX+lockKey, requestId, params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String value=jedis.get(KEY_PREFIX+lockKey);</span><br><span class=\"line\">        logger.error(<span class=\"string\">&quot;try get lock failed，current value = &quot;</span> + value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"通过Redisson获取分布式锁\"><a href=\"#通过Redisson获取分布式锁\" class=\"headerlink\" title=\"通过Redisson获取分布式锁\"></a>通过Redisson获取分布式锁</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RedissonClient client = Redisson.create(config);</span><br><span class=\"line\">RLock lock = getClient().getLock(lockKey);</span><br><span class=\"line\">lock.tryLock(waitTime, leaseTime, unit);</span><br><span class=\"line\"><span class=\"comment\">// lock.lock()是阻塞方法 </span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"基于Redisson的RedLock实现\"><a href=\"#基于Redisson的RedLock实现\" class=\"headerlink\" title=\"基于Redisson的RedLock实现\"></a>基于Redisson的RedLock实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RLock lock1 = redissonClient1.getLock(lockKey);</span><br><span class=\"line\">RLock lock2 = redissonClient2.getLock(lockKey);</span><br><span class=\"line\">RLock lock3 = redissonClient3.getLock(lockKey);</span><br><span class=\"line\"><span class=\"comment\">// 向3个master加锁</span></span><br><span class=\"line\">RedissonRedLock redLock = <span class=\"keyword\">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isLock;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    isLock = redLock.tryLock(<span class=\"number\">1</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    redLock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>RedLock是一种分布式锁的实现方式，算法思想很好理解：假设有N个相互独立无任何协作的Redis master，在每个master上使用单机Redis的加锁方式加锁。当有N&#x2F;2+1个节点加锁成功，即获取分布式锁成功；否则在所有实例上解锁。</p>","more":"<h1 id=\"客户端行为\"><a href=\"#客户端行为\" class=\"headerlink\" title=\"客户端行为\"></a>客户端行为</h1><ol>\n<li>获取当前Unix时间，以毫秒为单位。</li>\n<li>依次尝试从N个Master实例使用相同的key和随机值获取锁（假设这个key是LOCK_KEY）。当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>\n<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>\n<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>\n<li>如果因为某些原因，获取锁失败（没有在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。  <blockquote>\n<p>参考:<br> <a href=\"https://zhuanlan.zhihu.com/p/374732293\">RedLock算法理解</a></p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><ul>\n<li>存在网络分区</li>\n<li>集群存在故障转移，需要容错</li>\n</ul>\n<h2 id=\"分布式锁说明\"><a href=\"#分布式锁说明\" class=\"headerlink\" title=\"分布式锁说明\"></a>分布式锁说明</h2><p>一般说的redis分布式锁，其实是针对多个客户端获取锁和释放锁，redis分布式锁需要保证操作的原子性。这种情况下的，一般一个redis集群中就只有1个master，分布式锁的获取只是单机操作（包括redisson的getLock）。<br>而如果是cluster集群模式，不同key分布在不同的master上；或者在哨兵模式集群之上加一次负载均衡，串联多个哨兵集群作为一个大集群。针对这种相互独立的多个Master，需要加上一个分布式锁的话，Redis官方推出了一个规范的算法：RedLock。</p>\n<blockquote>\n<p>参考：<br>    <a href=\"https://zhuanlan.zhihu.com/p/145186839\">Redis的三种集群模式</a>  </p>\n</blockquote>\n<h2 id=\"通过jedis获取分布式锁\"><a href=\"#通过jedis获取分布式锁\" class=\"headerlink\" title=\"通过jedis获取分布式锁\"></a>通过jedis获取分布式锁</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.params.SetParams;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long RELEASE_SUCCESS = <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_SUCCESS = <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY_PREFIX=<span class=\"string\">&quot;DE_BATCH_LOCK_&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey 锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否释放成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String script = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class=\"line\">        Object result = jedis.eval(script, Collections.singletonList(KEY_PREFIX+lockKey), Collections.singletonList(requestId));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey 锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireTime 超期时间 s</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否获取成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryGetDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId, Integer expireTime)</span> </span>&#123;</span><br><span class=\"line\">        SetParams params = SetParams.setParams().nx();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expireTime != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            params.ex(expireTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String result = jedis.set(KEY_PREFIX+lockKey, requestId, params);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String value=jedis.get(KEY_PREFIX+lockKey);</span><br><span class=\"line\">        logger.error(<span class=\"string\">&quot;try get lock failed，current value = &quot;</span> + value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"通过Redisson获取分布式锁\"><a href=\"#通过Redisson获取分布式锁\" class=\"headerlink\" title=\"通过Redisson获取分布式锁\"></a>通过Redisson获取分布式锁</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RedissonClient client = Redisson.create(config);</span><br><span class=\"line\">RLock lock = getClient().getLock(lockKey);</span><br><span class=\"line\">lock.tryLock(waitTime, leaseTime, unit);</span><br><span class=\"line\"><span class=\"comment\">// lock.lock()是阻塞方法 </span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"基于Redisson的RedLock实现\"><a href=\"#基于Redisson的RedLock实现\" class=\"headerlink\" title=\"基于Redisson的RedLock实现\"></a>基于Redisson的RedLock实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RLock lock1 = redissonClient1.getLock(lockKey);</span><br><span class=\"line\">RLock lock2 = redissonClient2.getLock(lockKey);</span><br><span class=\"line\">RLock lock3 = redissonClient3.getLock(lockKey);</span><br><span class=\"line\"><span class=\"comment\">// 向3个master加锁</span></span><br><span class=\"line\">RedissonRedLock redLock = <span class=\"keyword\">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isLock;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    isLock = redLock.tryLock(<span class=\"number\">1</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    redLock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Redis高级功能","date":"2023-12-26T06:23:35.000Z","_content":"Redis高级功能，绝非一些面试网站说的消息队列、哨兵模式什么的。而是位图、Geo模块、概率数据结构类型等等，它们都是解决特定场景问题的利器。当你明白它们的大致原理和使用方式，那么遇到的时候，你就是最靓的仔 :)\n<!--more-->\n\n# 管道pipeline\nRedis 流水线是一种通过一次发出多个命令来提高性能的技术，而无需等待对每个单独命令的响应。大量的命令，只需要一次网络交互，这在实际应用中很有用。曾经在一次营销活动中，需要预热数据帮我提升了10倍不止的效率。  \n以下是用jedis客户端批处理hset存一个map的示例：  \n``` java\n    private void pipeline(String key, Map fvMap) {\n        try(Jedis redis = RedisUtil.getJedis();) {\n            Pipeline pipe = redis.pipelined();\n            fvMap.forEach((field,value) -> {\n                pipe.hset(key, String.valueOf(field), String.valueOf(value));\n            });\n            pipe.sync();\n        }\n    }\n```\n\n# 布隆过滤器Bloom filter\n大名鼎鼎的布隆过滤器，其实是一种概率数据结构，用于检查集合中是否存在元素。类似的概率型数据结构，在Redis官网下有一个专栏: Probabilistic[概率](https://redis.io/docs/data-types/probabilistic/) ，并且有多重概率型数据结构在不断添加中。比如Top-K（获取排名前K元素）、Count-min sketch(估计数据流中元素的频率)。\n\n## 原理\n首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。  \n- 加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。\n- 检测 key 是否存在，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在\n![](/images/6f68e8517ae6e68ac63f4a34b8d14ca5.png)  \n**注意**： \n> 基于以上原理，那么就可以得出1个结论：  \n如果判定不存在，那么一定不存在；如果判断存在，那么可能不存在。  \n例：如果v1的hash值落到bit数组的1、2、3，计算v2的hash值对应到2、3。而v1存在,v2不存在,那么判断v2就会有误判。\n\n\n## 安装\n[布隆过滤器](https://github.com/RedisBloom/RedisBloom/)并非Redis的自带功能，而是通过插件的方式来支持的。你可以通过docker直接运行打包好了的docker镜像，或者自己编译。    \n\n- docker方式\n```\ndocker run -p 6379:6379 -it --rm redis/redis-stack-server:latest\n```\n\n- 自己编译\n``` bash\napt-get install -y git\ncd ~/Redis\ngit clone --recursive https://github.com/RedisBloom/RedisBloom.git\ncd RedisBloom\n./sbin/setup\nbash -l\nmake\n```\n> 我在自己编译的时候，`./sbin/setup` 这一步引发的python依赖错误把我劝退了。  \n[参考] https://cloud.tencent.com/developer/article/1975700\n\n## 使用\n``` bash\n127.0.0.1:6380> BF.ADD Filter1 a \n(integer) 1\n127.0.0.1:6380> BF.EXISTS Filter1 a \n(integer) 1\n127.0.0.1:6380> BF.MADD Filter1 b c d\n1) (integer) 1\n2) (integer) 1\n3) (integer) 1\n127.0.0.1:6380> BF.MEXISTS Filter1 b d f\n1) (integer) 1\n2) (integer) 1\n3) (integer) 0\n\n```\n\n## 参数说明\n配置布隆过滤器，如果不配置参数，BF.ADD的时候会使用默认参数  \n``` ini\nBF.RESERVE {key} {error_rate} {capacity} [EXPANSION {expansion}] [NONSCALING]\n```\n- 默认参数值  \n\n|error_rate错误率|capacity容量|expansion扩容|\n|--|--|--|\n|0.01|100|2|  \n\n使用注意：\n> 1. 布隆过滤器不支持删除，如果需要删除，使用布谷鸟过滤器(Cuckoo)  \n> 2. 初始容量设计过大会浪费空间，过小虽然会扩容，但会导致实时错误率攀升\n \n\n# Streams流\n参考kafka设计，实现了仅追加的数据结构，通常用于可以持久化的消息队列。\nRedis为每个流条目生成一个唯一的ID，向流中添加条目是O(1),访问任何单个条目都是O(n)(n是ID 的长度)\n> 版本5以上才有(`info server`命令检查)  \n\n\n\n## 基本命令\n``` ini\nXADD 将新条目添加到流中\nXREAD 读取一个或多个条目，从给定位置开始并按时间向前移动\nXRANGE 返回两个提供的条目 ID 之间的条目范围\nXLEN 返回流的长度\n```\n\n## 基本使用\n``` cmd\n# * 号表示服务器自动生成 ID，后面顺序跟着一堆 key/value\n127.0.0.1:6379> xadd mystream * f1 v1 f2 v2 f3 v3\n\"1609404470049-0\"  ## 生成的消息 ID，有两部分组成，毫秒时间戳-该毫秒内产生的第1条消息\n\n# 消息ID 必须要比上个 ID 大\n127.0.0.1:6379> xadd mystream 123 f4 v4  \n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n\n# 自定义ID\n127.0.0.1:6379> xadd mystream 1609404470049-1 f4 v4\n\"1609404470049-1\"\n\n# -表示最小值 , + 表示最大值,也可以指定最大消息ID，或最小消息ID，配合 -、+ 使用\n127.0.0.1:6379> xrange mystream - +\n1) 1) \"1609404470049-0\"\n   2) 1) \"f1\"\n      2) \"v1\"\n      3) \"f2\"\n      4) \"v2\"\n      5) \"f3\"\n      6) \"v3\"\n2) 1) \"1609404470049-1\"\n   2) 1) \"f4\"\n      2) \"v4\"\n\n127.0.0.1:6379> xdel mystream 1609404470049-1\n(integer) 1\n127.0.0.1:6379> xlen mystream\n(integer) 1\n# 删除整个 stream\n127.0.0.1:6379> del mystream\n(integer) 1\n```\n\n# 位图BitMap\n位图不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作，该类型被视为位向量。由于字符串是二进制安全 blob，其最大长度为 512 MB，因此它们适合设置多达 2^32 个不同的位。\n\n## 基本命令\n``` ini\nSETBIT 将提供的偏移位设置为 0 或 1\nGETBIT 返回给定偏移处的位值\nBITOP 允许您对一个或多个字符串执行按位运算,在不同字符串之间执行按位运算。提供的操作是 AND、OR、XOR 和 NOT\n\n\t> BITCOUNT 执行填充计数，报告设置为 1 的位数\n\t> BITPOS 查找指定值为 0 或 1 的第一个位\n```\n## 基本使用\n``` cmd\n127.0.0.1:6380> setbit key 1 1\n(integer) 0\n127.0.0.1:6380> setbit key 2 1\n(integer) 0\n127.0.0.1:6380> setbit key 100 1\n(integer) 0\n127.0.0.1:6380> getbit key 2\n(integer) 1\n127.0.0.1:6380> setbit key 100 0\n(integer) 1\n127.0.0.1:6380> getbit key 100\n(integer) 0\n127.0.0.1:6380> bitcount key\n(integer) 2\n127.0.0.1:6380> setbit key 110 1\n(integer) 0\n127.0.0.1:6380> bitcount key\n(integer) 3\n\n```\n\n","source":"_posts/Redis高级功能.md","raw":"---\ntitle: Redis高级功能\ndate: 2023-12-26 14:23:35\ntags: Redis\ncategories: 中间件\n---\nRedis高级功能，绝非一些面试网站说的消息队列、哨兵模式什么的。而是位图、Geo模块、概率数据结构类型等等，它们都是解决特定场景问题的利器。当你明白它们的大致原理和使用方式，那么遇到的时候，你就是最靓的仔 :)\n<!--more-->\n\n# 管道pipeline\nRedis 流水线是一种通过一次发出多个命令来提高性能的技术，而无需等待对每个单独命令的响应。大量的命令，只需要一次网络交互，这在实际应用中很有用。曾经在一次营销活动中，需要预热数据帮我提升了10倍不止的效率。  \n以下是用jedis客户端批处理hset存一个map的示例：  \n``` java\n    private void pipeline(String key, Map fvMap) {\n        try(Jedis redis = RedisUtil.getJedis();) {\n            Pipeline pipe = redis.pipelined();\n            fvMap.forEach((field,value) -> {\n                pipe.hset(key, String.valueOf(field), String.valueOf(value));\n            });\n            pipe.sync();\n        }\n    }\n```\n\n# 布隆过滤器Bloom filter\n大名鼎鼎的布隆过滤器，其实是一种概率数据结构，用于检查集合中是否存在元素。类似的概率型数据结构，在Redis官网下有一个专栏: Probabilistic[概率](https://redis.io/docs/data-types/probabilistic/) ，并且有多重概率型数据结构在不断添加中。比如Top-K（获取排名前K元素）、Count-min sketch(估计数据流中元素的频率)。\n\n## 原理\n首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。  \n- 加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。\n- 检测 key 是否存在，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在\n![](/images/6f68e8517ae6e68ac63f4a34b8d14ca5.png)  \n**注意**： \n> 基于以上原理，那么就可以得出1个结论：  \n如果判定不存在，那么一定不存在；如果判断存在，那么可能不存在。  \n例：如果v1的hash值落到bit数组的1、2、3，计算v2的hash值对应到2、3。而v1存在,v2不存在,那么判断v2就会有误判。\n\n\n## 安装\n[布隆过滤器](https://github.com/RedisBloom/RedisBloom/)并非Redis的自带功能，而是通过插件的方式来支持的。你可以通过docker直接运行打包好了的docker镜像，或者自己编译。    \n\n- docker方式\n```\ndocker run -p 6379:6379 -it --rm redis/redis-stack-server:latest\n```\n\n- 自己编译\n``` bash\napt-get install -y git\ncd ~/Redis\ngit clone --recursive https://github.com/RedisBloom/RedisBloom.git\ncd RedisBloom\n./sbin/setup\nbash -l\nmake\n```\n> 我在自己编译的时候，`./sbin/setup` 这一步引发的python依赖错误把我劝退了。  \n[参考] https://cloud.tencent.com/developer/article/1975700\n\n## 使用\n``` bash\n127.0.0.1:6380> BF.ADD Filter1 a \n(integer) 1\n127.0.0.1:6380> BF.EXISTS Filter1 a \n(integer) 1\n127.0.0.1:6380> BF.MADD Filter1 b c d\n1) (integer) 1\n2) (integer) 1\n3) (integer) 1\n127.0.0.1:6380> BF.MEXISTS Filter1 b d f\n1) (integer) 1\n2) (integer) 1\n3) (integer) 0\n\n```\n\n## 参数说明\n配置布隆过滤器，如果不配置参数，BF.ADD的时候会使用默认参数  \n``` ini\nBF.RESERVE {key} {error_rate} {capacity} [EXPANSION {expansion}] [NONSCALING]\n```\n- 默认参数值  \n\n|error_rate错误率|capacity容量|expansion扩容|\n|--|--|--|\n|0.01|100|2|  \n\n使用注意：\n> 1. 布隆过滤器不支持删除，如果需要删除，使用布谷鸟过滤器(Cuckoo)  \n> 2. 初始容量设计过大会浪费空间，过小虽然会扩容，但会导致实时错误率攀升\n \n\n# Streams流\n参考kafka设计，实现了仅追加的数据结构，通常用于可以持久化的消息队列。\nRedis为每个流条目生成一个唯一的ID，向流中添加条目是O(1),访问任何单个条目都是O(n)(n是ID 的长度)\n> 版本5以上才有(`info server`命令检查)  \n\n\n\n## 基本命令\n``` ini\nXADD 将新条目添加到流中\nXREAD 读取一个或多个条目，从给定位置开始并按时间向前移动\nXRANGE 返回两个提供的条目 ID 之间的条目范围\nXLEN 返回流的长度\n```\n\n## 基本使用\n``` cmd\n# * 号表示服务器自动生成 ID，后面顺序跟着一堆 key/value\n127.0.0.1:6379> xadd mystream * f1 v1 f2 v2 f3 v3\n\"1609404470049-0\"  ## 生成的消息 ID，有两部分组成，毫秒时间戳-该毫秒内产生的第1条消息\n\n# 消息ID 必须要比上个 ID 大\n127.0.0.1:6379> xadd mystream 123 f4 v4  \n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n\n# 自定义ID\n127.0.0.1:6379> xadd mystream 1609404470049-1 f4 v4\n\"1609404470049-1\"\n\n# -表示最小值 , + 表示最大值,也可以指定最大消息ID，或最小消息ID，配合 -、+ 使用\n127.0.0.1:6379> xrange mystream - +\n1) 1) \"1609404470049-0\"\n   2) 1) \"f1\"\n      2) \"v1\"\n      3) \"f2\"\n      4) \"v2\"\n      5) \"f3\"\n      6) \"v3\"\n2) 1) \"1609404470049-1\"\n   2) 1) \"f4\"\n      2) \"v4\"\n\n127.0.0.1:6379> xdel mystream 1609404470049-1\n(integer) 1\n127.0.0.1:6379> xlen mystream\n(integer) 1\n# 删除整个 stream\n127.0.0.1:6379> del mystream\n(integer) 1\n```\n\n# 位图BitMap\n位图不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作，该类型被视为位向量。由于字符串是二进制安全 blob，其最大长度为 512 MB，因此它们适合设置多达 2^32 个不同的位。\n\n## 基本命令\n``` ini\nSETBIT 将提供的偏移位设置为 0 或 1\nGETBIT 返回给定偏移处的位值\nBITOP 允许您对一个或多个字符串执行按位运算,在不同字符串之间执行按位运算。提供的操作是 AND、OR、XOR 和 NOT\n\n\t> BITCOUNT 执行填充计数，报告设置为 1 的位数\n\t> BITPOS 查找指定值为 0 或 1 的第一个位\n```\n## 基本使用\n``` cmd\n127.0.0.1:6380> setbit key 1 1\n(integer) 0\n127.0.0.1:6380> setbit key 2 1\n(integer) 0\n127.0.0.1:6380> setbit key 100 1\n(integer) 0\n127.0.0.1:6380> getbit key 2\n(integer) 1\n127.0.0.1:6380> setbit key 100 0\n(integer) 1\n127.0.0.1:6380> getbit key 100\n(integer) 0\n127.0.0.1:6380> bitcount key\n(integer) 2\n127.0.0.1:6380> setbit key 110 1\n(integer) 0\n127.0.0.1:6380> bitcount key\n(integer) 3\n\n```\n\n","slug":"Redis高级功能","published":1,"updated":"2024-02-18T08:28:59.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyw000zqwvd1svj85cw","content":"<p>Redis高级功能，绝非一些面试网站说的消息队列、哨兵模式什么的。而是位图、Geo模块、概率数据结构类型等等，它们都是解决特定场景问题的利器。当你明白它们的大致原理和使用方式，那么遇到的时候，你就是最靓的仔 :)</p>\n<span id=\"more\"></span>\n\n<h1 id=\"管道pipeline\"><a href=\"#管道pipeline\" class=\"headerlink\" title=\"管道pipeline\"></a>管道pipeline</h1><p>Redis 流水线是一种通过一次发出多个命令来提高性能的技术，而无需等待对每个单独命令的响应。大量的命令，只需要一次网络交互，这在实际应用中很有用。曾经在一次营销活动中，需要预热数据帮我提升了10倍不止的效率。<br>以下是用jedis客户端批处理hset存一个map的示例：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pipeline</span><span class=\"params\">(String key, Map fvMap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>(Jedis redis = RedisUtil.getJedis();) &#123;</span><br><span class=\"line\">        Pipeline pipe = redis.pipelined();</span><br><span class=\"line\">        fvMap.forEach((field,value) -&gt; &#123;</span><br><span class=\"line\">            pipe.hset(key, String.valueOf(field), String.valueOf(value));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        pipe.sync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"布隆过滤器Bloom-filter\"><a href=\"#布隆过滤器Bloom-filter\" class=\"headerlink\" title=\"布隆过滤器Bloom filter\"></a>布隆过滤器Bloom filter</h1><p>大名鼎鼎的布隆过滤器，其实是一种概率数据结构，用于检查集合中是否存在元素。类似的概率型数据结构，在Redis官网下有一个专栏: Probabilistic<a href=\"https://redis.io/docs/data-types/probabilistic/\">概率</a> ，并且有多重概率型数据结构在不断添加中。比如Top-K（获取排名前K元素）、Count-min sketch(估计数据流中元素的频率)。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。  </p>\n<ul>\n<li>加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。</li>\n<li>检测 key 是否存在，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在<br><img src=\"/images/6f68e8517ae6e68ac63f4a34b8d14ca5.png\"><br><strong>注意</strong>： <blockquote>\n<p>基于以上原理，那么就可以得出1个结论：<br>如果判定不存在，那么一定不存在；如果判断存在，那么可能不存在。<br>例：如果v1的hash值落到bit数组的1、2、3，计算v2的hash值对应到2、3。而v1存在,v2不存在,那么判断v2就会有误判。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><a href=\"https://github.com/RedisBloom/RedisBloom/\">布隆过滤器</a>并非Redis的自带功能，而是通过插件的方式来支持的。你可以通过docker直接运行打包好了的docker镜像，或者自己编译。    </p>\n<ul>\n<li><p>docker方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 6379:6379 -it --rm redis/redis-stack-server:latest</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自己编译</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install -y git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/Redis</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisBloom</span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\">bash -l</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我在自己编译的时候，<code>./sbin/setup</code> 这一步引发的python依赖错误把我劝退了。<br>[参考] <a href=\"https://cloud.tencent.com/developer/article/1975700\">https://cloud.tencent.com/developer/article/1975700</a></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6380&gt; BF.ADD Filter1 a </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6380&gt; BF.EXISTS Filter1 a </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6380&gt; BF.MADD Filter1 b c d</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6380&gt; BF.MEXISTS Filter1 b d f</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><p>配置布隆过滤器，如果不配置参数，BF.ADD的时候会使用默认参数  </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; <span class=\"section\">[EXPANSION &#123;expansion&#125;]</span> <span class=\"section\">[NONSCALING]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>默认参数值</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>error_rate错误率</th>\n<th>capacity容量</th>\n<th>expansion扩容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0.01</td>\n<td>100</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>使用注意：</p>\n<blockquote>\n<ol>\n<li>布隆过滤器不支持删除，如果需要删除，使用布谷鸟过滤器(Cuckoo)  </li>\n<li>初始容量设计过大会浪费空间，过小虽然会扩容，但会导致实时错误率攀升</li>\n</ol>\n</blockquote>\n<h1 id=\"Streams流\"><a href=\"#Streams流\" class=\"headerlink\" title=\"Streams流\"></a>Streams流</h1><p>参考kafka设计，实现了仅追加的数据结构，通常用于可以持久化的消息队列。<br>Redis为每个流条目生成一个唯一的ID，向流中添加条目是O(1),访问任何单个条目都是O(n)(n是ID 的长度)</p>\n<blockquote>\n<p>版本5以上才有(<code>info server</code>命令检查)  </p>\n</blockquote>\n<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XADD 将新条目添加到流中</span><br><span class=\"line\">XREAD 读取一个或多个条目，从给定位置开始并按时间向前移动</span><br><span class=\"line\">XRANGE 返回两个提供的条目 ID 之间的条目范围</span><br><span class=\"line\">XLEN 返回流的长度</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># * 号表示服务器自动生成 ID，后面顺序跟着一堆 key/value</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xadd mystream * f1 v1 f2 v2 f3 v3</span><br><span class=\"line\">&quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">0</span>&quot;  ## 生成的消息 ID，有两部分组成，毫秒时间戳-该毫秒内产生的第<span class=\"number\">1</span>条消息</span><br><span class=\"line\"></span><br><span class=\"line\"># 消息ID 必须要比上个 ID 大</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xadd mystream <span class=\"number\">123</span> f4 v4  </span><br><span class=\"line\">(error) ERR The ID specified <span class=\"keyword\">in</span> XADD is equal or smaller than the target stream top item</span><br><span class=\"line\"></span><br><span class=\"line\"># 自定义ID</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xadd mystream <span class=\"number\">1609404470049</span>-<span class=\"number\">1</span> f4 v4</span><br><span class=\"line\">&quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">1</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># -表示最小值 , + 表示最大值,也可以指定最大消息ID，或最小消息ID，配合 -、+ 使用</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xrange mystream - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"number\">1</span>) &quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">0</span>&quot;</span><br><span class=\"line\">   <span class=\"number\">2</span>) <span class=\"number\">1</span>) &quot;f1&quot;</span><br><span class=\"line\">      <span class=\"number\">2</span>) &quot;v1&quot;</span><br><span class=\"line\">      <span class=\"number\">3</span>) &quot;f2&quot;</span><br><span class=\"line\">      <span class=\"number\">4</span>) &quot;v2&quot;</span><br><span class=\"line\">      <span class=\"number\">5</span>) &quot;f3&quot;</span><br><span class=\"line\">      <span class=\"number\">6</span>) &quot;v3&quot;</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"number\">1</span>) &quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">1</span>&quot;</span><br><span class=\"line\">   <span class=\"number\">2</span>) <span class=\"number\">1</span>) &quot;f4&quot;</span><br><span class=\"line\">      <span class=\"number\">2</span>) &quot;v4&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xdel mystream <span class=\"number\">1609404470049</span>-<span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xlen mystream</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"># 删除整个 stream</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; <span class=\"built_in\">del</span> mystream</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"位图BitMap\"><a href=\"#位图BitMap\" class=\"headerlink\" title=\"位图BitMap\"></a>位图BitMap</h1><p>位图不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作，该类型被视为位向量。由于字符串是二进制安全 blob，其最大长度为 512 MB，因此它们适合设置多达 2^32 个不同的位。</p>\n<h2 id=\"基本命令-1\"><a href=\"#基本命令-1\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETBIT 将提供的偏移位设置为 0 或 1</span><br><span class=\"line\">GETBIT 返回给定偏移处的位值</span><br><span class=\"line\">BITOP 允许您对一个或多个字符串执行按位运算,在不同字符串之间执行按位运算。提供的操作是 AND、OR、XOR 和 NOT</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; BITCOUNT 执行填充计数，报告设置为 1 的位数</span><br><span class=\"line\">\t&gt; BITPOS 查找指定值为 0 或 1 的第一个位</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本使用-1\"><a href=\"#基本使用-1\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">2</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">100</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; getbit key <span class=\"number\">2</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">100</span> <span class=\"number\">0</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; getbit key <span class=\"number\">100</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; bitcount key</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">110</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; bitcount key</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Redis高级功能，绝非一些面试网站说的消息队列、哨兵模式什么的。而是位图、Geo模块、概率数据结构类型等等，它们都是解决特定场景问题的利器。当你明白它们的大致原理和使用方式，那么遇到的时候，你就是最靓的仔 :)</p>","more":"<h1 id=\"管道pipeline\"><a href=\"#管道pipeline\" class=\"headerlink\" title=\"管道pipeline\"></a>管道pipeline</h1><p>Redis 流水线是一种通过一次发出多个命令来提高性能的技术，而无需等待对每个单独命令的响应。大量的命令，只需要一次网络交互，这在实际应用中很有用。曾经在一次营销活动中，需要预热数据帮我提升了10倍不止的效率。<br>以下是用jedis客户端批处理hset存一个map的示例：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pipeline</span><span class=\"params\">(String key, Map fvMap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>(Jedis redis = RedisUtil.getJedis();) &#123;</span><br><span class=\"line\">        Pipeline pipe = redis.pipelined();</span><br><span class=\"line\">        fvMap.forEach((field,value) -&gt; &#123;</span><br><span class=\"line\">            pipe.hset(key, String.valueOf(field), String.valueOf(value));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        pipe.sync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"布隆过滤器Bloom-filter\"><a href=\"#布隆过滤器Bloom-filter\" class=\"headerlink\" title=\"布隆过滤器Bloom filter\"></a>布隆过滤器Bloom filter</h1><p>大名鼎鼎的布隆过滤器，其实是一种概率数据结构，用于检查集合中是否存在元素。类似的概率型数据结构，在Redis官网下有一个专栏: Probabilistic<a href=\"https://redis.io/docs/data-types/probabilistic/\">概率</a> ，并且有多重概率型数据结构在不断添加中。比如Top-K（获取排名前K元素）、Count-min sketch(估计数据流中元素的频率)。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。  </p>\n<ul>\n<li>加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。</li>\n<li>检测 key 是否存在，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在<br><img src=\"/images/6f68e8517ae6e68ac63f4a34b8d14ca5.png\"><br><strong>注意</strong>： <blockquote>\n<p>基于以上原理，那么就可以得出1个结论：<br>如果判定不存在，那么一定不存在；如果判断存在，那么可能不存在。<br>例：如果v1的hash值落到bit数组的1、2、3，计算v2的hash值对应到2、3。而v1存在,v2不存在,那么判断v2就会有误判。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><a href=\"https://github.com/RedisBloom/RedisBloom/\">布隆过滤器</a>并非Redis的自带功能，而是通过插件的方式来支持的。你可以通过docker直接运行打包好了的docker镜像，或者自己编译。    </p>\n<ul>\n<li><p>docker方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 6379:6379 -it --rm redis/redis-stack-server:latest</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自己编译</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install -y git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/Redis</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> RedisBloom</span><br><span class=\"line\">./sbin/setup</span><br><span class=\"line\">bash -l</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我在自己编译的时候，<code>./sbin/setup</code> 这一步引发的python依赖错误把我劝退了。<br>[参考] <a href=\"https://cloud.tencent.com/developer/article/1975700\">https://cloud.tencent.com/developer/article/1975700</a></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6380&gt; BF.ADD Filter1 a </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6380&gt; BF.EXISTS Filter1 a </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6380&gt; BF.MADD Filter1 b c d</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6380&gt; BF.MEXISTS Filter1 b d f</span><br><span class=\"line\">1) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">2) (<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">3) (<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><p>配置布隆过滤器，如果不配置参数，BF.ADD的时候会使用默认参数  </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; <span class=\"section\">[EXPANSION &#123;expansion&#125;]</span> <span class=\"section\">[NONSCALING]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>默认参数值</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>error_rate错误率</th>\n<th>capacity容量</th>\n<th>expansion扩容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0.01</td>\n<td>100</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>使用注意：</p>\n<blockquote>\n<ol>\n<li>布隆过滤器不支持删除，如果需要删除，使用布谷鸟过滤器(Cuckoo)  </li>\n<li>初始容量设计过大会浪费空间，过小虽然会扩容，但会导致实时错误率攀升</li>\n</ol>\n</blockquote>\n<h1 id=\"Streams流\"><a href=\"#Streams流\" class=\"headerlink\" title=\"Streams流\"></a>Streams流</h1><p>参考kafka设计，实现了仅追加的数据结构，通常用于可以持久化的消息队列。<br>Redis为每个流条目生成一个唯一的ID，向流中添加条目是O(1),访问任何单个条目都是O(n)(n是ID 的长度)</p>\n<blockquote>\n<p>版本5以上才有(<code>info server</code>命令检查)  </p>\n</blockquote>\n<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XADD 将新条目添加到流中</span><br><span class=\"line\">XREAD 读取一个或多个条目，从给定位置开始并按时间向前移动</span><br><span class=\"line\">XRANGE 返回两个提供的条目 ID 之间的条目范围</span><br><span class=\"line\">XLEN 返回流的长度</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># * 号表示服务器自动生成 ID，后面顺序跟着一堆 key/value</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xadd mystream * f1 v1 f2 v2 f3 v3</span><br><span class=\"line\">&quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">0</span>&quot;  ## 生成的消息 ID，有两部分组成，毫秒时间戳-该毫秒内产生的第<span class=\"number\">1</span>条消息</span><br><span class=\"line\"></span><br><span class=\"line\"># 消息ID 必须要比上个 ID 大</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xadd mystream <span class=\"number\">123</span> f4 v4  </span><br><span class=\"line\">(error) ERR The ID specified <span class=\"keyword\">in</span> XADD is equal or smaller than the target stream top item</span><br><span class=\"line\"></span><br><span class=\"line\"># 自定义ID</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xadd mystream <span class=\"number\">1609404470049</span>-<span class=\"number\">1</span> f4 v4</span><br><span class=\"line\">&quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">1</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># -表示最小值 , + 表示最大值,也可以指定最大消息ID，或最小消息ID，配合 -、+ 使用</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xrange mystream - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"number\">1</span>) &quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">0</span>&quot;</span><br><span class=\"line\">   <span class=\"number\">2</span>) <span class=\"number\">1</span>) &quot;f1&quot;</span><br><span class=\"line\">      <span class=\"number\">2</span>) &quot;v1&quot;</span><br><span class=\"line\">      <span class=\"number\">3</span>) &quot;f2&quot;</span><br><span class=\"line\">      <span class=\"number\">4</span>) &quot;v2&quot;</span><br><span class=\"line\">      <span class=\"number\">5</span>) &quot;f3&quot;</span><br><span class=\"line\">      <span class=\"number\">6</span>) &quot;v3&quot;</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"number\">1</span>) &quot;<span class=\"number\">1609404470049</span>-<span class=\"number\">1</span>&quot;</span><br><span class=\"line\">   <span class=\"number\">2</span>) <span class=\"number\">1</span>) &quot;f4&quot;</span><br><span class=\"line\">      <span class=\"number\">2</span>) &quot;v4&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xdel mystream <span class=\"number\">1609404470049</span>-<span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; xlen mystream</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"># 删除整个 stream</span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6379</span>&gt; <span class=\"built_in\">del</span> mystream</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"位图BitMap\"><a href=\"#位图BitMap\" class=\"headerlink\" title=\"位图BitMap\"></a>位图BitMap</h1><p>位图不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作，该类型被视为位向量。由于字符串是二进制安全 blob，其最大长度为 512 MB，因此它们适合设置多达 2^32 个不同的位。</p>\n<h2 id=\"基本命令-1\"><a href=\"#基本命令-1\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SETBIT 将提供的偏移位设置为 0 或 1</span><br><span class=\"line\">GETBIT 返回给定偏移处的位值</span><br><span class=\"line\">BITOP 允许您对一个或多个字符串执行按位运算,在不同字符串之间执行按位运算。提供的操作是 AND、OR、XOR 和 NOT</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; BITCOUNT 执行填充计数，报告设置为 1 的位数</span><br><span class=\"line\">\t&gt; BITPOS 查找指定值为 0 或 1 的第一个位</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本使用-1\"><a href=\"#基本使用-1\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">2</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">100</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; getbit key <span class=\"number\">2</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">100</span> <span class=\"number\">0</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; getbit key <span class=\"number\">100</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; bitcount key</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; setbit key <span class=\"number\">110</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">6380</span>&gt; bitcount key</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Spark","date":"2023-12-26T06:24:38.000Z","_content":"","source":"_posts/Spark.md","raw":"---\ntitle: Spark\ndate: 2023-12-26 14:24:38\ntags: \n- Spark\ncategories: 大数据\n---\n","slug":"Spark","published":1,"updated":"2024-02-18T08:29:54.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyx0012qwvdc5fth7zh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Sping Cache源码","date":"2023-04-04T02:27:52.000Z","_content":"我们常说读源码一定要带着问题来读。那么你的疑问又是哪些呢？  \n就与我而言，在大概明白SpringCache的使用方式后，我想知道  \n1. @EnableCaching 这个注解到底干了什么事情  \n2. @Cacheable这种方法上的注解，是怎么替换我方法的返回的  \n3. 我想对SpringCache有个更深入一层的理解，后续如果有问题，我知道在哪里去切入。\n<!--more-->\n\n## EnableCaching注释解读\n看源码一定要看注释，注释开头说明了这个注解的作用类似xml中\n``` xml\n <cache:annotation-driven/>\n```  \n它们负责负责注册必要的Spring组件，提供缓存管理，例如`CacheInterceptor`和基于代理的增强。  \n然后就给出了很清晰的使用方法：\n``` java\n @Configuration\n   @EnableCaching\n   public class AppConfig {\n  \n       @Bean\n       public MyService myService() {\n           // configure and return a class having @Cacheable methods\n           return new MyService();\n       }\n  \n       @Bean\n       public CacheManager cacheManager() {\n           // configure and return an implementation of Spring's CacheManager SPI\n           SimpleCacheManager cacheManager = new SimpleCacheManager();\n           cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n           return cacheManager;\n       }\n   }\n```\nCacheManager必须指定，因为居然没有提供默认的Cache。CacheManager是接口，它的实现类就是可支持的Cache实现。通过配置就可以支持的Cache类型可以参考`CacheType`,可以通过spring.cache.type指定。  \n为了更精确的使用Cache，可以自定义`CachingConfigurer`的实现，从而指定自定义的 CacheManager, CacheResolver, KeyGenerator, CacheErrorHandler。如果CacheManager和CacheResolver同时指定了，那么CacheManager将被忽略。然后，配置类必须要纳入Spring的Bean管理，推荐使用@Configuration，然后继承 CachingConfigurerSupport 。打开一看，居然是四个类型的空实现，而注释里面声明只有CacheManager必须要指定。那么，必然存在一个位置给他们赋默认值（后面解答）。然后，缓存通知的模式默认为AdviceMode.PROXY，它只支持基于Bean对象的调用，不支持本地方法的调用。毕竟是基于Spring的AOP，跟事务拦截类似。  \n\n## EnableCaching还做了什么\n通过`@Import(CachingConfigurationSelector.class)`可以看到Import了一个增强类，其中selectImports方法定义了如果使用`proxy`代理的话，又另外引入了两个类：`AutoProxyRegistrar`和`ProxyCachingConfiguration`。  \n其中 AutoProxyRegistrar 的作用是根据当前BeanDefinitionRegistry适当地注册自动代理创建者。参考  \n`AopConfigUtils.registerAutoProxyCreatorIfNecessary`\n而 ProxyCachingConfiguration 则是注册基于Spring注解的缓存管理的必要类。这是一个核心的类。  \n``` java\n@Configuration(proxyBeanMethods = false)\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\npublic class ProxyCachingConfiguration extends AbstractCachingConfiguration {\n\n\t// 创建一个基于CacheOperationSource可访问bean工厂的增强器\n\t@Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic BeanFactoryCacheOperationSourceAdvisor cacheAdvisor(\n\t\t\tCacheOperationSource cacheOperationSource, CacheInterceptor cacheInterceptor) {\n\n\t\tBeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor();\n\t\tadvisor.setCacheOperationSource(cacheOperationSource);\n\t\tadvisor.setAdvice(cacheInterceptor);\n\t\tif (this.enableCaching != null) {\n\t\t\tadvisor.setOrder(this.enableCaching.<Integer>getNumber(\"order\"));\n\t\t}\n\t\treturn advisor;\n\t}\n\n\n\t// 创建一个默认的AnnotationCacheOperationSource，支持带有Cacheable和CacheEvict注解的公共方法\n\t// 核心是定义getCacheOperations\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic CacheOperationSource cacheOperationSource() {\n\t\treturn new AnnotationCacheOperationSource();\n\t}\n\n\t// 使用策略设计模式, 本身只负责调用顺序, CacheAspectSupport 完成具体操作的定义。CacheOperationSource用于确定缓存操作，KeyGenerator将构建缓存键，CacheResolver将解析要使用的实际缓存\n\t// 前面说了默认组件也在这里制定，分别是 SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)\n\t// SimpleKeyGenerator SimpleCacheErrorHandler ,注意这里cacheResolver默认的指定仍然来自于CacheManager，所以再次说明CacheManager必须有\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic CacheInterceptor cacheInterceptor(CacheOperationSource cacheOperationSource) {\n\t\tCacheInterceptor interceptor = new CacheInterceptor();\n\t\tinterceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager);\n\t\tinterceptor.setCacheOperationSource(cacheOperationSource);\n\t\treturn interceptor;\n\t}\n\n}\n```\n\n## 缓存代理是怎么执行的  \n之前在分析相关类的时候就说明了真正缓存操作都是`CacheInterceptor`这里面完成的，这里只有一个`invoke`方法，断点跟进一下。  \n``` java\npublic Object invoke(final MethodInvocation invocation) throws Throwable {\n\t\t// invocation 其实是一个cglib的代理类org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation ，指向的是有Cacheable的方法\n\t\tMethod method = invocation.getMethod();\n\t\t\n\t\t// 定义一个缓存操作执行方法\n\t\tCacheOperationInvoker aopAllianceInvoker = () -> {\n\t\t\ttry {\n\t\t\t\treturn invocation.proceed();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CacheOperationInvoker.ThrowableWrapper(ex);\n\t\t\t}\n\t\t};\n\n\t\tObject target = invocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\t\ttry {\n\t\t\t// 通过代理对象及方法，执行缓存获取操作\n\t\t\treturn execute(aopAllianceInvoker, target, method, invocation.getArguments());\n\t\t}\n\t\tcatch (CacheOperationInvoker.ThrowableWrapper th) {\n\t\t\tthrow th.getOriginal();\n\t\t}\n\t}\n```\n跟下去发现，真正起作用的地方还是`CacheAspectSupport`的excute方法：  \n``` java\nprivate Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) {\n\t\t// Special handling of synchronized invocation\n\t\t// 同步调用特殊处理\n\t\tif (contexts.isSynchronized()) {\n\t\t\tCacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next();\n\t\t\tif (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {\n\t\t\t\tObject key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);\n\t\t\t\tCache cache = context.getCaches().iterator().next();\n\t\t\t\ttry {\n\t\t\t\t\treturn wrapCacheValue(method, handleSynchronizedGet(invoker, key, cache));\n\t\t\t\t}\n\t\t\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\t\t\t// Directly propagate ThrowableWrapper from the invoker,\n\t\t\t\t\t// or potentially also an IllegalArgumentException etc.\n\t\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No caching required, only call the underlying method\n\t\t\t\treturn invokeOperation(invoker);\n\t\t\t}\n\t\t}\n\n\t\t// Process any early evictions\n\t\t// 处理beforeInvocation\n\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), true,\n\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT);\n\n\t\t// Check if we have a cached item matching the conditions\n\t\t// 就是这里从缓存中获取对象，实际处理了注解中condition、key\n\t\tCache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));\n\n\t\t// Collect puts from any @Cacheable miss, if no cached item is found\n\t\t// 判断unless\n\t\tList<CachePutRequest> cachePutRequests = new ArrayList<>();\n\t\tif (cacheHit == null) {\n\t\t\tcollectPutRequests(contexts.get(CacheableOperation.class),\n\t\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);\n\t\t}\n\n\t\tObject cacheValue;\n\t\tObject returnValue;\n\n\t\tif (cacheHit != null && !hasCachePut(contexts)) {\n\t\t\t// If there are no put requests, just use the cache hit\n\t\t\tcacheValue = cacheHit.get();\n\t\t\treturnValue = wrapCacheValue(method, cacheValue);\n\t\t}\n\t\telse {\n\t\t\t// Invoke the method if we don't have a cache hit\n\t\t\treturnValue = invokeOperation(invoker);\n\t\t\tcacheValue = unwrapReturnValue(returnValue);\n\t\t}\n\n\t\t// Collect any explicit @CachePuts\n\t\tcollectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);\n\n\t\t// Process any collected put requests, either from @CachePut or a @Cacheable miss\n\t\t// 处理其他CachePut\n\t\tfor (CachePutRequest cachePutRequest : cachePutRequests) {\n\t\t\tcachePutRequest.apply(cacheValue);\n\t\t}\n\n\t\t// Process any late evictions\n\t\t// 处理condition\n\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);\n\n\t\treturn returnValue;\n\t}\n```\n\n## 总结 \n其实，基于以上内容，Spring Cache的大致缓存处理的代码已经涉及到了。 但是，要理解代理是怎么环绕增强的，那么久需要AspectJ相关的知识了。其实，切点的相关概念也是Spring从AspectJ中引入的，然后结合了自身的Spring的Bean管理形成了SpringAop。可以参考：  \n\nhttps://www.baeldung.com/spring-aop  \n\nhttps://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html  \n\n发现自己其实对Spring的AOP和AspectJ缺乏更清晰的理解，后面再整理一到两篇跟进一下吧。\n\n\n\n\n","source":"_posts/Sping-Cache源码.md","raw":"---\ntitle: Sping Cache源码\ndate: 2023-04-04 10:27:52\ntags: \n    - spring cache\n    - spring增强\ncategories: Spring+\n---\n我们常说读源码一定要带着问题来读。那么你的疑问又是哪些呢？  \n就与我而言，在大概明白SpringCache的使用方式后，我想知道  \n1. @EnableCaching 这个注解到底干了什么事情  \n2. @Cacheable这种方法上的注解，是怎么替换我方法的返回的  \n3. 我想对SpringCache有个更深入一层的理解，后续如果有问题，我知道在哪里去切入。\n<!--more-->\n\n## EnableCaching注释解读\n看源码一定要看注释，注释开头说明了这个注解的作用类似xml中\n``` xml\n <cache:annotation-driven/>\n```  \n它们负责负责注册必要的Spring组件，提供缓存管理，例如`CacheInterceptor`和基于代理的增强。  \n然后就给出了很清晰的使用方法：\n``` java\n @Configuration\n   @EnableCaching\n   public class AppConfig {\n  \n       @Bean\n       public MyService myService() {\n           // configure and return a class having @Cacheable methods\n           return new MyService();\n       }\n  \n       @Bean\n       public CacheManager cacheManager() {\n           // configure and return an implementation of Spring's CacheManager SPI\n           SimpleCacheManager cacheManager = new SimpleCacheManager();\n           cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n           return cacheManager;\n       }\n   }\n```\nCacheManager必须指定，因为居然没有提供默认的Cache。CacheManager是接口，它的实现类就是可支持的Cache实现。通过配置就可以支持的Cache类型可以参考`CacheType`,可以通过spring.cache.type指定。  \n为了更精确的使用Cache，可以自定义`CachingConfigurer`的实现，从而指定自定义的 CacheManager, CacheResolver, KeyGenerator, CacheErrorHandler。如果CacheManager和CacheResolver同时指定了，那么CacheManager将被忽略。然后，配置类必须要纳入Spring的Bean管理，推荐使用@Configuration，然后继承 CachingConfigurerSupport 。打开一看，居然是四个类型的空实现，而注释里面声明只有CacheManager必须要指定。那么，必然存在一个位置给他们赋默认值（后面解答）。然后，缓存通知的模式默认为AdviceMode.PROXY，它只支持基于Bean对象的调用，不支持本地方法的调用。毕竟是基于Spring的AOP，跟事务拦截类似。  \n\n## EnableCaching还做了什么\n通过`@Import(CachingConfigurationSelector.class)`可以看到Import了一个增强类，其中selectImports方法定义了如果使用`proxy`代理的话，又另外引入了两个类：`AutoProxyRegistrar`和`ProxyCachingConfiguration`。  \n其中 AutoProxyRegistrar 的作用是根据当前BeanDefinitionRegistry适当地注册自动代理创建者。参考  \n`AopConfigUtils.registerAutoProxyCreatorIfNecessary`\n而 ProxyCachingConfiguration 则是注册基于Spring注解的缓存管理的必要类。这是一个核心的类。  \n``` java\n@Configuration(proxyBeanMethods = false)\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\npublic class ProxyCachingConfiguration extends AbstractCachingConfiguration {\n\n\t// 创建一个基于CacheOperationSource可访问bean工厂的增强器\n\t@Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic BeanFactoryCacheOperationSourceAdvisor cacheAdvisor(\n\t\t\tCacheOperationSource cacheOperationSource, CacheInterceptor cacheInterceptor) {\n\n\t\tBeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor();\n\t\tadvisor.setCacheOperationSource(cacheOperationSource);\n\t\tadvisor.setAdvice(cacheInterceptor);\n\t\tif (this.enableCaching != null) {\n\t\t\tadvisor.setOrder(this.enableCaching.<Integer>getNumber(\"order\"));\n\t\t}\n\t\treturn advisor;\n\t}\n\n\n\t// 创建一个默认的AnnotationCacheOperationSource，支持带有Cacheable和CacheEvict注解的公共方法\n\t// 核心是定义getCacheOperations\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic CacheOperationSource cacheOperationSource() {\n\t\treturn new AnnotationCacheOperationSource();\n\t}\n\n\t// 使用策略设计模式, 本身只负责调用顺序, CacheAspectSupport 完成具体操作的定义。CacheOperationSource用于确定缓存操作，KeyGenerator将构建缓存键，CacheResolver将解析要使用的实际缓存\n\t// 前面说了默认组件也在这里制定，分别是 SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)\n\t// SimpleKeyGenerator SimpleCacheErrorHandler ,注意这里cacheResolver默认的指定仍然来自于CacheManager，所以再次说明CacheManager必须有\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic CacheInterceptor cacheInterceptor(CacheOperationSource cacheOperationSource) {\n\t\tCacheInterceptor interceptor = new CacheInterceptor();\n\t\tinterceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager);\n\t\tinterceptor.setCacheOperationSource(cacheOperationSource);\n\t\treturn interceptor;\n\t}\n\n}\n```\n\n## 缓存代理是怎么执行的  \n之前在分析相关类的时候就说明了真正缓存操作都是`CacheInterceptor`这里面完成的，这里只有一个`invoke`方法，断点跟进一下。  \n``` java\npublic Object invoke(final MethodInvocation invocation) throws Throwable {\n\t\t// invocation 其实是一个cglib的代理类org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation ，指向的是有Cacheable的方法\n\t\tMethod method = invocation.getMethod();\n\t\t\n\t\t// 定义一个缓存操作执行方法\n\t\tCacheOperationInvoker aopAllianceInvoker = () -> {\n\t\t\ttry {\n\t\t\t\treturn invocation.proceed();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CacheOperationInvoker.ThrowableWrapper(ex);\n\t\t\t}\n\t\t};\n\n\t\tObject target = invocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\t\ttry {\n\t\t\t// 通过代理对象及方法，执行缓存获取操作\n\t\t\treturn execute(aopAllianceInvoker, target, method, invocation.getArguments());\n\t\t}\n\t\tcatch (CacheOperationInvoker.ThrowableWrapper th) {\n\t\t\tthrow th.getOriginal();\n\t\t}\n\t}\n```\n跟下去发现，真正起作用的地方还是`CacheAspectSupport`的excute方法：  \n``` java\nprivate Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) {\n\t\t// Special handling of synchronized invocation\n\t\t// 同步调用特殊处理\n\t\tif (contexts.isSynchronized()) {\n\t\t\tCacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next();\n\t\t\tif (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {\n\t\t\t\tObject key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);\n\t\t\t\tCache cache = context.getCaches().iterator().next();\n\t\t\t\ttry {\n\t\t\t\t\treturn wrapCacheValue(method, handleSynchronizedGet(invoker, key, cache));\n\t\t\t\t}\n\t\t\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\t\t\t// Directly propagate ThrowableWrapper from the invoker,\n\t\t\t\t\t// or potentially also an IllegalArgumentException etc.\n\t\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No caching required, only call the underlying method\n\t\t\t\treturn invokeOperation(invoker);\n\t\t\t}\n\t\t}\n\n\t\t// Process any early evictions\n\t\t// 处理beforeInvocation\n\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), true,\n\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT);\n\n\t\t// Check if we have a cached item matching the conditions\n\t\t// 就是这里从缓存中获取对象，实际处理了注解中condition、key\n\t\tCache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));\n\n\t\t// Collect puts from any @Cacheable miss, if no cached item is found\n\t\t// 判断unless\n\t\tList<CachePutRequest> cachePutRequests = new ArrayList<>();\n\t\tif (cacheHit == null) {\n\t\t\tcollectPutRequests(contexts.get(CacheableOperation.class),\n\t\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);\n\t\t}\n\n\t\tObject cacheValue;\n\t\tObject returnValue;\n\n\t\tif (cacheHit != null && !hasCachePut(contexts)) {\n\t\t\t// If there are no put requests, just use the cache hit\n\t\t\tcacheValue = cacheHit.get();\n\t\t\treturnValue = wrapCacheValue(method, cacheValue);\n\t\t}\n\t\telse {\n\t\t\t// Invoke the method if we don't have a cache hit\n\t\t\treturnValue = invokeOperation(invoker);\n\t\t\tcacheValue = unwrapReturnValue(returnValue);\n\t\t}\n\n\t\t// Collect any explicit @CachePuts\n\t\tcollectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);\n\n\t\t// Process any collected put requests, either from @CachePut or a @Cacheable miss\n\t\t// 处理其他CachePut\n\t\tfor (CachePutRequest cachePutRequest : cachePutRequests) {\n\t\t\tcachePutRequest.apply(cacheValue);\n\t\t}\n\n\t\t// Process any late evictions\n\t\t// 处理condition\n\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);\n\n\t\treturn returnValue;\n\t}\n```\n\n## 总结 \n其实，基于以上内容，Spring Cache的大致缓存处理的代码已经涉及到了。 但是，要理解代理是怎么环绕增强的，那么久需要AspectJ相关的知识了。其实，切点的相关概念也是Spring从AspectJ中引入的，然后结合了自身的Spring的Bean管理形成了SpringAop。可以参考：  \n\nhttps://www.baeldung.com/spring-aop  \n\nhttps://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html  \n\n发现自己其实对Spring的AOP和AspectJ缺乏更清晰的理解，后面再整理一到两篇跟进一下吧。\n\n\n\n\n","slug":"Sping-Cache源码","published":1,"updated":"2024-02-18T08:30:13.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyx0015qwvd8ggbbis0","content":"<p>我们常说读源码一定要带着问题来读。那么你的疑问又是哪些呢？<br>就与我而言，在大概明白SpringCache的使用方式后，我想知道  </p>\n<ol>\n<li>@EnableCaching 这个注解到底干了什么事情  </li>\n<li>@Cacheable这种方法上的注解，是怎么替换我方法的返回的  </li>\n<li>我想对SpringCache有个更深入一层的理解，后续如果有问题，我知道在哪里去切入。<span id=\"more\"></span></li>\n</ol>\n<h2 id=\"EnableCaching注释解读\"><a href=\"#EnableCaching注释解读\" class=\"headerlink\" title=\"EnableCaching注释解读\"></a>EnableCaching注释解读</h2><p>看源码一定要看注释，注释开头说明了这个注解的作用类似xml中</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">cache:annotation-driven</span>/&gt;</span></span><br><span class=\"line\">```  </span><br><span class=\"line\">它们负责负责注册必要的Spring组件，提供缓存管理，例如`CacheInterceptor`和基于代理的增强。  </span><br><span class=\"line\">然后就给出了很清晰的使用方法：</span><br><span class=\"line\">``` java</span><br><span class=\"line\"> @Configuration</span><br><span class=\"line\">   @EnableCaching</span><br><span class=\"line\">   public class AppConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">       @Bean</span><br><span class=\"line\">       public MyService myService() &#123;</span><br><span class=\"line\">           // configure and return a class having @Cacheable methods</span><br><span class=\"line\">           return new MyService();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">       @Bean</span><br><span class=\"line\">       public CacheManager cacheManager() &#123;</span><br><span class=\"line\">           // configure and return an implementation of Spring&#x27;s CacheManager SPI</span><br><span class=\"line\">           SimpleCacheManager cacheManager = new SimpleCacheManager();</span><br><span class=\"line\">           cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(&quot;default&quot;)));</span><br><span class=\"line\">           return cacheManager;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>CacheManager必须指定，因为居然没有提供默认的Cache。CacheManager是接口，它的实现类就是可支持的Cache实现。通过配置就可以支持的Cache类型可以参考<code>CacheType</code>,可以通过spring.cache.type指定。<br>为了更精确的使用Cache，可以自定义<code>CachingConfigurer</code>的实现，从而指定自定义的 CacheManager, CacheResolver, KeyGenerator, CacheErrorHandler。如果CacheManager和CacheResolver同时指定了，那么CacheManager将被忽略。然后，配置类必须要纳入Spring的Bean管理，推荐使用@Configuration，然后继承 CachingConfigurerSupport 。打开一看，居然是四个类型的空实现，而注释里面声明只有CacheManager必须要指定。那么，必然存在一个位置给他们赋默认值（后面解答）。然后，缓存通知的模式默认为AdviceMode.PROXY，它只支持基于Bean对象的调用，不支持本地方法的调用。毕竟是基于Spring的AOP，跟事务拦截类似。  </p>\n<h2 id=\"EnableCaching还做了什么\"><a href=\"#EnableCaching还做了什么\" class=\"headerlink\" title=\"EnableCaching还做了什么\"></a>EnableCaching还做了什么</h2><p>通过<code>@Import(CachingConfigurationSelector.class)</code>可以看到Import了一个增强类，其中selectImports方法定义了如果使用<code>proxy</code>代理的话，又另外引入了两个类：<code>AutoProxyRegistrar</code>和<code>ProxyCachingConfiguration</code>。<br>其中 AutoProxyRegistrar 的作用是根据当前BeanDefinitionRegistry适当地注册自动代理创建者。参考<br><code>AopConfigUtils.registerAutoProxyCreatorIfNecessary</code><br>而 ProxyCachingConfiguration 则是注册基于Spring注解的缓存管理的必要类。这是一个核心的类。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyCachingConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个基于CacheOperationSource可访问bean工厂的增强器</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> BeanFactoryCacheOperationSourceAdvisor <span class=\"title\">cacheAdvisor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tCacheOperationSource cacheOperationSource, CacheInterceptor cacheInterceptor)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBeanFactoryCacheOperationSourceAdvisor advisor = <span class=\"keyword\">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class=\"line\">\t\tadvisor.setCacheOperationSource(cacheOperationSource);</span><br><span class=\"line\">\t\tadvisor.setAdvice(cacheInterceptor);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.enableCaching != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tadvisor.setOrder(<span class=\"keyword\">this</span>.enableCaching.&lt;Integer&gt;getNumber(<span class=\"string\">&quot;order&quot;</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> advisor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个默认的AnnotationCacheOperationSource，支持带有Cacheable和CacheEvict注解的公共方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 核心是定义getCacheOperations</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> CacheOperationSource <span class=\"title\">cacheOperationSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AnnotationCacheOperationSource();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用策略设计模式, 本身只负责调用顺序, CacheAspectSupport 完成具体操作的定义。CacheOperationSource用于确定缓存操作，KeyGenerator将构建缓存键，CacheResolver将解析要使用的实际缓存</span></span><br><span class=\"line\">\t<span class=\"comment\">// 前面说了默认组件也在这里制定，分别是 SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)</span></span><br><span class=\"line\">\t<span class=\"comment\">// SimpleKeyGenerator SimpleCacheErrorHandler ,注意这里cacheResolver默认的指定仍然来自于CacheManager，所以再次说明CacheManager必须有</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> CacheInterceptor <span class=\"title\">cacheInterceptor</span><span class=\"params\">(CacheOperationSource cacheOperationSource)</span> </span>&#123;</span><br><span class=\"line\">\t\tCacheInterceptor interceptor = <span class=\"keyword\">new</span> CacheInterceptor();</span><br><span class=\"line\">\t\tinterceptor.configure(<span class=\"keyword\">this</span>.errorHandler, <span class=\"keyword\">this</span>.keyGenerator, <span class=\"keyword\">this</span>.cacheResolver, <span class=\"keyword\">this</span>.cacheManager);</span><br><span class=\"line\">\t\tinterceptor.setCacheOperationSource(cacheOperationSource);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> interceptor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"缓存代理是怎么执行的\"><a href=\"#缓存代理是怎么执行的\" class=\"headerlink\" title=\"缓存代理是怎么执行的\"></a>缓存代理是怎么执行的</h2><p>之前在分析相关类的时候就说明了真正缓存操作都是<code>CacheInterceptor</code>这里面完成的，这里只有一个<code>invoke</code>方法，断点跟进一下。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"keyword\">final</span> MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// invocation 其实是一个cglib的代理类org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation ，指向的是有Cacheable的方法</span></span><br><span class=\"line\">\t\tMethod method = invocation.getMethod();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 定义一个缓存操作执行方法</span></span><br><span class=\"line\">\t\tCacheOperationInvoker aopAllianceInvoker = () -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> invocation.proceed();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CacheOperationInvoker.ThrowableWrapper(ex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObject target = invocation.getThis();</span><br><span class=\"line\">\t\tAssert.state(target != <span class=\"keyword\">null</span>, <span class=\"string\">&quot;Target must not be null&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过代理对象及方法，执行缓存获取操作</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> execute(aopAllianceInvoker, target, method, invocation.getArguments());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (CacheOperationInvoker.ThrowableWrapper th) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> th.getOriginal();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>跟下去发现，真正起作用的地方还是<code>CacheAspectSupport</code>的excute方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">execute</span><span class=\"params\">(<span class=\"keyword\">final</span> CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Special handling of synchronized invocation</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 同步调用特殊处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (contexts.isSynchronized()) &#123;</span><br><span class=\"line\">\t\t\tCacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123;</span><br><span class=\"line\">\t\t\t\tObject key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class=\"line\">\t\t\t\tCache cache = context.getCaches().iterator().next();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> wrapCacheValue(method, handleSynchronizedGet(invoker, key, cache));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">catch</span> (Cache.ValueRetrievalException ex) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// Directly propagate ThrowableWrapper from the invoker,</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// or potentially also an IllegalArgumentException etc.</span></span><br><span class=\"line\">\t\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// No caching required, only call the underlying method</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> invokeOperation(invoker);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Process any early evictions</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理beforeInvocation</span></span><br><span class=\"line\">\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), <span class=\"keyword\">true</span>,</span><br><span class=\"line\">\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Check if we have a cached item matching the conditions</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 就是这里从缓存中获取对象，实际处理了注解中condition、key</span></span><br><span class=\"line\">\t\tCache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Collect puts from any @Cacheable miss, if no cached item is found</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断unless</span></span><br><span class=\"line\">\t\tList&lt;CachePutRequest&gt; cachePutRequests = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cacheHit == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tcollectPutRequests(contexts.get(CacheableOperation.class),</span><br><span class=\"line\">\t\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObject cacheValue;</span><br><span class=\"line\">\t\tObject returnValue;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cacheHit != <span class=\"keyword\">null</span> &amp;&amp; !hasCachePut(contexts)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// If there are no put requests, just use the cache hit</span></span><br><span class=\"line\">\t\t\tcacheValue = cacheHit.get();</span><br><span class=\"line\">\t\t\treturnValue = wrapCacheValue(method, cacheValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Invoke the method if we don&#x27;t have a cache hit</span></span><br><span class=\"line\">\t\t\treturnValue = invokeOperation(invoker);</span><br><span class=\"line\">\t\t\tcacheValue = unwrapReturnValue(returnValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Collect any explicit @CachePuts</span></span><br><span class=\"line\">\t\tcollectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Process any collected put requests, either from @CachePut or a @Cacheable miss</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理其他CachePut</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (CachePutRequest cachePutRequest : cachePutRequests) &#123;</span><br><span class=\"line\">\t\t\tcachePutRequest.apply(cacheValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Process any late evictions</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理condition</span></span><br><span class=\"line\">\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), <span class=\"keyword\">false</span>, cacheValue);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实，基于以上内容，Spring Cache的大致缓存处理的代码已经涉及到了。 但是，要理解代理是怎么环绕增强的，那么久需要AspectJ相关的知识了。其实，切点的相关概念也是Spring从AspectJ中引入的，然后结合了自身的Spring的Bean管理形成了SpringAop。可以参考：  </p>\n<p><a href=\"https://www.baeldung.com/spring-aop\">https://www.baeldung.com/spring-aop</a>  </p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html\">https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html</a>  </p>\n<p>发现自己其实对Spring的AOP和AspectJ缺乏更清晰的理解，后面再整理一到两篇跟进一下吧。</p>\n","site":{"data":{}},"excerpt":"<p>我们常说读源码一定要带着问题来读。那么你的疑问又是哪些呢？<br>就与我而言，在大概明白SpringCache的使用方式后，我想知道  </p>\n<ol>\n<li>@EnableCaching 这个注解到底干了什么事情  </li>\n<li>@Cacheable这种方法上的注解，是怎么替换我方法的返回的  </li>\n<li>我想对SpringCache有个更深入一层的理解，后续如果有问题，我知道在哪里去切入。</li></ol>","more":"\n\n<h2 id=\"EnableCaching注释解读\"><a href=\"#EnableCaching注释解读\" class=\"headerlink\" title=\"EnableCaching注释解读\"></a>EnableCaching注释解读</h2><p>看源码一定要看注释，注释开头说明了这个注解的作用类似xml中</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">cache:annotation-driven</span>/&gt;</span></span><br><span class=\"line\">```  </span><br><span class=\"line\">它们负责负责注册必要的Spring组件，提供缓存管理，例如`CacheInterceptor`和基于代理的增强。  </span><br><span class=\"line\">然后就给出了很清晰的使用方法：</span><br><span class=\"line\">``` java</span><br><span class=\"line\"> @Configuration</span><br><span class=\"line\">   @EnableCaching</span><br><span class=\"line\">   public class AppConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">       @Bean</span><br><span class=\"line\">       public MyService myService() &#123;</span><br><span class=\"line\">           // configure and return a class having @Cacheable methods</span><br><span class=\"line\">           return new MyService();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">       @Bean</span><br><span class=\"line\">       public CacheManager cacheManager() &#123;</span><br><span class=\"line\">           // configure and return an implementation of Spring&#x27;s CacheManager SPI</span><br><span class=\"line\">           SimpleCacheManager cacheManager = new SimpleCacheManager();</span><br><span class=\"line\">           cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(&quot;default&quot;)));</span><br><span class=\"line\">           return cacheManager;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>CacheManager必须指定，因为居然没有提供默认的Cache。CacheManager是接口，它的实现类就是可支持的Cache实现。通过配置就可以支持的Cache类型可以参考<code>CacheType</code>,可以通过spring.cache.type指定。<br>为了更精确的使用Cache，可以自定义<code>CachingConfigurer</code>的实现，从而指定自定义的 CacheManager, CacheResolver, KeyGenerator, CacheErrorHandler。如果CacheManager和CacheResolver同时指定了，那么CacheManager将被忽略。然后，配置类必须要纳入Spring的Bean管理，推荐使用@Configuration，然后继承 CachingConfigurerSupport 。打开一看，居然是四个类型的空实现，而注释里面声明只有CacheManager必须要指定。那么，必然存在一个位置给他们赋默认值（后面解答）。然后，缓存通知的模式默认为AdviceMode.PROXY，它只支持基于Bean对象的调用，不支持本地方法的调用。毕竟是基于Spring的AOP，跟事务拦截类似。  </p>\n<h2 id=\"EnableCaching还做了什么\"><a href=\"#EnableCaching还做了什么\" class=\"headerlink\" title=\"EnableCaching还做了什么\"></a>EnableCaching还做了什么</h2><p>通过<code>@Import(CachingConfigurationSelector.class)</code>可以看到Import了一个增强类，其中selectImports方法定义了如果使用<code>proxy</code>代理的话，又另外引入了两个类：<code>AutoProxyRegistrar</code>和<code>ProxyCachingConfiguration</code>。<br>其中 AutoProxyRegistrar 的作用是根据当前BeanDefinitionRegistry适当地注册自动代理创建者。参考<br><code>AopConfigUtils.registerAutoProxyCreatorIfNecessary</code><br>而 ProxyCachingConfiguration 则是注册基于Spring注解的缓存管理的必要类。这是一个核心的类。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyCachingConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个基于CacheOperationSource可访问bean工厂的增强器</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> BeanFactoryCacheOperationSourceAdvisor <span class=\"title\">cacheAdvisor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tCacheOperationSource cacheOperationSource, CacheInterceptor cacheInterceptor)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBeanFactoryCacheOperationSourceAdvisor advisor = <span class=\"keyword\">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class=\"line\">\t\tadvisor.setCacheOperationSource(cacheOperationSource);</span><br><span class=\"line\">\t\tadvisor.setAdvice(cacheInterceptor);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.enableCaching != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tadvisor.setOrder(<span class=\"keyword\">this</span>.enableCaching.&lt;Integer&gt;getNumber(<span class=\"string\">&quot;order&quot;</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> advisor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个默认的AnnotationCacheOperationSource，支持带有Cacheable和CacheEvict注解的公共方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 核心是定义getCacheOperations</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> CacheOperationSource <span class=\"title\">cacheOperationSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AnnotationCacheOperationSource();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用策略设计模式, 本身只负责调用顺序, CacheAspectSupport 完成具体操作的定义。CacheOperationSource用于确定缓存操作，KeyGenerator将构建缓存键，CacheResolver将解析要使用的实际缓存</span></span><br><span class=\"line\">\t<span class=\"comment\">// 前面说了默认组件也在这里制定，分别是 SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)</span></span><br><span class=\"line\">\t<span class=\"comment\">// SimpleKeyGenerator SimpleCacheErrorHandler ,注意这里cacheResolver默认的指定仍然来自于CacheManager，所以再次说明CacheManager必须有</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> CacheInterceptor <span class=\"title\">cacheInterceptor</span><span class=\"params\">(CacheOperationSource cacheOperationSource)</span> </span>&#123;</span><br><span class=\"line\">\t\tCacheInterceptor interceptor = <span class=\"keyword\">new</span> CacheInterceptor();</span><br><span class=\"line\">\t\tinterceptor.configure(<span class=\"keyword\">this</span>.errorHandler, <span class=\"keyword\">this</span>.keyGenerator, <span class=\"keyword\">this</span>.cacheResolver, <span class=\"keyword\">this</span>.cacheManager);</span><br><span class=\"line\">\t\tinterceptor.setCacheOperationSource(cacheOperationSource);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> interceptor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"缓存代理是怎么执行的\"><a href=\"#缓存代理是怎么执行的\" class=\"headerlink\" title=\"缓存代理是怎么执行的\"></a>缓存代理是怎么执行的</h2><p>之前在分析相关类的时候就说明了真正缓存操作都是<code>CacheInterceptor</code>这里面完成的，这里只有一个<code>invoke</code>方法，断点跟进一下。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"keyword\">final</span> MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// invocation 其实是一个cglib的代理类org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation ，指向的是有Cacheable的方法</span></span><br><span class=\"line\">\t\tMethod method = invocation.getMethod();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 定义一个缓存操作执行方法</span></span><br><span class=\"line\">\t\tCacheOperationInvoker aopAllianceInvoker = () -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> invocation.proceed();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CacheOperationInvoker.ThrowableWrapper(ex);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObject target = invocation.getThis();</span><br><span class=\"line\">\t\tAssert.state(target != <span class=\"keyword\">null</span>, <span class=\"string\">&quot;Target must not be null&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过代理对象及方法，执行缓存获取操作</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> execute(aopAllianceInvoker, target, method, invocation.getArguments());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (CacheOperationInvoker.ThrowableWrapper th) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> th.getOriginal();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>跟下去发现，真正起作用的地方还是<code>CacheAspectSupport</code>的excute方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">execute</span><span class=\"params\">(<span class=\"keyword\">final</span> CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Special handling of synchronized invocation</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 同步调用特殊处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (contexts.isSynchronized()) &#123;</span><br><span class=\"line\">\t\t\tCacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123;</span><br><span class=\"line\">\t\t\t\tObject key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class=\"line\">\t\t\t\tCache cache = context.getCaches().iterator().next();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> wrapCacheValue(method, handleSynchronizedGet(invoker, key, cache));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">catch</span> (Cache.ValueRetrievalException ex) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// Directly propagate ThrowableWrapper from the invoker,</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// or potentially also an IllegalArgumentException etc.</span></span><br><span class=\"line\">\t\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// No caching required, only call the underlying method</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> invokeOperation(invoker);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Process any early evictions</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理beforeInvocation</span></span><br><span class=\"line\">\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), <span class=\"keyword\">true</span>,</span><br><span class=\"line\">\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Check if we have a cached item matching the conditions</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 就是这里从缓存中获取对象，实际处理了注解中condition、key</span></span><br><span class=\"line\">\t\tCache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Collect puts from any @Cacheable miss, if no cached item is found</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断unless</span></span><br><span class=\"line\">\t\tList&lt;CachePutRequest&gt; cachePutRequests = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cacheHit == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tcollectPutRequests(contexts.get(CacheableOperation.class),</span><br><span class=\"line\">\t\t\t\t\tCacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObject cacheValue;</span><br><span class=\"line\">\t\tObject returnValue;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cacheHit != <span class=\"keyword\">null</span> &amp;&amp; !hasCachePut(contexts)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// If there are no put requests, just use the cache hit</span></span><br><span class=\"line\">\t\t\tcacheValue = cacheHit.get();</span><br><span class=\"line\">\t\t\treturnValue = wrapCacheValue(method, cacheValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Invoke the method if we don&#x27;t have a cache hit</span></span><br><span class=\"line\">\t\t\treturnValue = invokeOperation(invoker);</span><br><span class=\"line\">\t\t\tcacheValue = unwrapReturnValue(returnValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Collect any explicit @CachePuts</span></span><br><span class=\"line\">\t\tcollectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Process any collected put requests, either from @CachePut or a @Cacheable miss</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理其他CachePut</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (CachePutRequest cachePutRequest : cachePutRequests) &#123;</span><br><span class=\"line\">\t\t\tcachePutRequest.apply(cacheValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Process any late evictions</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理condition</span></span><br><span class=\"line\">\t\tprocessCacheEvicts(contexts.get(CacheEvictOperation.class), <span class=\"keyword\">false</span>, cacheValue);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实，基于以上内容，Spring Cache的大致缓存处理的代码已经涉及到了。 但是，要理解代理是怎么环绕增强的，那么久需要AspectJ相关的知识了。其实，切点的相关概念也是Spring从AspectJ中引入的，然后结合了自身的Spring的Bean管理形成了SpringAop。可以参考：  </p>\n<p><a href=\"https://www.baeldung.com/spring-aop\">https://www.baeldung.com/spring-aop</a>  </p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html\">https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html</a>  </p>\n<p>发现自己其实对Spring的AOP和AspectJ缺乏更清晰的理解，后面再整理一到两篇跟进一下吧。</p>"},{"title":"Spring Cache","date":"2023-03-31T11:30:47.000Z","_content":"SpringCache是Spring基于Spring切面提供的缓存增强技术。它集成了缓存常见的各种操作,如Cacheable/CachePut/CacheEvit等；也支持了ConcurrentMapCache/RedisCache/EhCacheCache等各种缓存实现。它集成简单，支持丰富，实乃是业务开发的利器！  \n\n<!--more-->\n\n## SpringCache组件\n先来看看一些接触到的常见注解  \n|  名称   | 解释  |\n|  ----  | ----  |\n| CacheManager  | 缓存管理器 |\n| EnableCaching  | 开启基于注解的缓存 |\n| @Cacheable  | 根据方法的请求参数对其进行缓存 |\n| @CachePut  | 更新缓存 |\n| @CacheEvict  | 清除缓存 |\n|   |  |\n| @CacheConfig  | 统一配置本类的缓存注解的属性 |\n| keyGenerator  | 缓存数据时key生成策略 |\n| serialize  | 缓存数据时value序列化策略 |\n\n## SpringCache基本使用\n1. 引入jar包\n``` xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-cache</artifactId>\n    </dependency>\n```\n\n2. 开启Cache支持  \n这里`@EnableCaching`可以直接作用于SpringBoot的启动类，但为了后续扩展。  \n我们定义一个CachingConfigurerSupport继承类，并加到这里\n``` java\n@EnableCaching\n@Configuration\npublic class CacheConfig extends CachingConfigurerSupport {\n    // 后续扩展\n}\n```\n\n3. @Cacheable(\"xxx\")作用于方法  \n定义一个get方法，并加上Cacheable注解就可以了。  \n这里cache需要要有一个key，因此cacheNames必不可少。  \n\n\n##扩展：使用Reids作为缓存实现 \n1. yml配置  \n```\nspring:\n  cache:\n    type: redis\n```\n2. 定义ttl  \n``` java\n@EnableCaching\n@Configuration\npublic class CacheConfig extends CachingConfigurerSupport {\n\n    @Bean\n    public RedisCacheConfiguration buildRedisConfig() {\n\n        return RedisCacheConfiguration.defaultCacheConfig()\n                // 如果配置不缓存空，则注意返回对象也不可为空，否则报错\n//                .disableCachingNullValues()\n                .entryTtl(Duration.ofMinutes(5L))\n                .prefixCacheNameWith(\"My_Prefix_\")\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));\n    }\n```\n这里，定义了ttl为5分钟，然后使用了自定义的前缀。序列化存储是为了在redisClient中容易参照。  \n\n## 自定义key\n其实，如果你使用@Cacheable和@CachePut分别作用于getById和updateById的时候就会发现，为什么CachePut明明会放置结果到缓存，为什么在get的时候获取不到？ 其实，都是因为默认的key不相同导致的。 \n``` java\n@RequestMapping(\"/user\")\n@RestController\n@CacheConfig(cacheNames = \"userCache\")\n@Slf4j\npublic class CacheController {\n    private static Map<Integer, String> data_map =\n            new HashMap(){{\n                put(1, \"Lily\");\n                put(2, \"Linger\");\n            }};\n    @RequestMapping(\"/get/{id}\")\n    @Cacheable(key = \"#id\")\n    public String get(@PathVariable Integer id) {\n      log.warn(\"get {}\", id);\n      return data_map.get(id);\n    }      \n\n    @RequestMapping(\"/update\")\n   @CachePut(key = \"#id\")\n    public String update(@RequestParam Integer id, @RequestParam String name) {\n        log.warn(\"add {} {}\", id, name);\n        data_map.put(id, name);\n        return name;\n    }      \n\n}    \n```\n像上面这样，都定义key为请求的ID，那么自然能达到我们想要的效果。  \n\n## 使用心得\n  \n1、Spring Cache使用还是很方便的，但是要特别注意，不然容易出bug  \n2、使用统一的CacheConfig, 明确定义查增改的key，或使用统一keyGenerator  \n3、由于get和update使用了一样的key，那么update方法的返回必须和get一致  \n4、注意key对应方法返回值就是key对应value！！尽量少的ttl，不然服务重启依旧取不到最新值  \n5、对于一般非联动缓存，直接用@Cacheable即可。方法cacheNames会覆盖类上的  \n\n---\n以上例子的代码都已上传到Git： \nhttps://github.com/Hugh126/daydayup.git  \n\n参考  \nhttps://blog.csdn.net/qq_32448349/article/details/101696892  \n\n\n\n\n","source":"_posts/Spring-Cache.md","raw":"---\ntitle: Spring Cache\ndate: 2023-03-31 19:30:47\ntags: spring cache\ncategories: Spring+\n---\nSpringCache是Spring基于Spring切面提供的缓存增强技术。它集成了缓存常见的各种操作,如Cacheable/CachePut/CacheEvit等；也支持了ConcurrentMapCache/RedisCache/EhCacheCache等各种缓存实现。它集成简单，支持丰富，实乃是业务开发的利器！  \n\n<!--more-->\n\n## SpringCache组件\n先来看看一些接触到的常见注解  \n|  名称   | 解释  |\n|  ----  | ----  |\n| CacheManager  | 缓存管理器 |\n| EnableCaching  | 开启基于注解的缓存 |\n| @Cacheable  | 根据方法的请求参数对其进行缓存 |\n| @CachePut  | 更新缓存 |\n| @CacheEvict  | 清除缓存 |\n|   |  |\n| @CacheConfig  | 统一配置本类的缓存注解的属性 |\n| keyGenerator  | 缓存数据时key生成策略 |\n| serialize  | 缓存数据时value序列化策略 |\n\n## SpringCache基本使用\n1. 引入jar包\n``` xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-cache</artifactId>\n    </dependency>\n```\n\n2. 开启Cache支持  \n这里`@EnableCaching`可以直接作用于SpringBoot的启动类，但为了后续扩展。  \n我们定义一个CachingConfigurerSupport继承类，并加到这里\n``` java\n@EnableCaching\n@Configuration\npublic class CacheConfig extends CachingConfigurerSupport {\n    // 后续扩展\n}\n```\n\n3. @Cacheable(\"xxx\")作用于方法  \n定义一个get方法，并加上Cacheable注解就可以了。  \n这里cache需要要有一个key，因此cacheNames必不可少。  \n\n\n##扩展：使用Reids作为缓存实现 \n1. yml配置  \n```\nspring:\n  cache:\n    type: redis\n```\n2. 定义ttl  \n``` java\n@EnableCaching\n@Configuration\npublic class CacheConfig extends CachingConfigurerSupport {\n\n    @Bean\n    public RedisCacheConfiguration buildRedisConfig() {\n\n        return RedisCacheConfiguration.defaultCacheConfig()\n                // 如果配置不缓存空，则注意返回对象也不可为空，否则报错\n//                .disableCachingNullValues()\n                .entryTtl(Duration.ofMinutes(5L))\n                .prefixCacheNameWith(\"My_Prefix_\")\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));\n    }\n```\n这里，定义了ttl为5分钟，然后使用了自定义的前缀。序列化存储是为了在redisClient中容易参照。  \n\n## 自定义key\n其实，如果你使用@Cacheable和@CachePut分别作用于getById和updateById的时候就会发现，为什么CachePut明明会放置结果到缓存，为什么在get的时候获取不到？ 其实，都是因为默认的key不相同导致的。 \n``` java\n@RequestMapping(\"/user\")\n@RestController\n@CacheConfig(cacheNames = \"userCache\")\n@Slf4j\npublic class CacheController {\n    private static Map<Integer, String> data_map =\n            new HashMap(){{\n                put(1, \"Lily\");\n                put(2, \"Linger\");\n            }};\n    @RequestMapping(\"/get/{id}\")\n    @Cacheable(key = \"#id\")\n    public String get(@PathVariable Integer id) {\n      log.warn(\"get {}\", id);\n      return data_map.get(id);\n    }      \n\n    @RequestMapping(\"/update\")\n   @CachePut(key = \"#id\")\n    public String update(@RequestParam Integer id, @RequestParam String name) {\n        log.warn(\"add {} {}\", id, name);\n        data_map.put(id, name);\n        return name;\n    }      \n\n}    \n```\n像上面这样，都定义key为请求的ID，那么自然能达到我们想要的效果。  \n\n## 使用心得\n  \n1、Spring Cache使用还是很方便的，但是要特别注意，不然容易出bug  \n2、使用统一的CacheConfig, 明确定义查增改的key，或使用统一keyGenerator  \n3、由于get和update使用了一样的key，那么update方法的返回必须和get一致  \n4、注意key对应方法返回值就是key对应value！！尽量少的ttl，不然服务重启依旧取不到最新值  \n5、对于一般非联动缓存，直接用@Cacheable即可。方法cacheNames会覆盖类上的  \n\n---\n以上例子的代码都已上传到Git： \nhttps://github.com/Hugh126/daydayup.git  \n\n参考  \nhttps://blog.csdn.net/qq_32448349/article/details/101696892  \n\n\n\n\n","slug":"Spring-Cache","published":1,"updated":"2024-02-18T08:31:07.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyy0018qwvdaly5bt4q","content":"<p>SpringCache是Spring基于Spring切面提供的缓存增强技术。它集成了缓存常见的各种操作,如Cacheable&#x2F;CachePut&#x2F;CacheEvit等；也支持了ConcurrentMapCache&#x2F;RedisCache&#x2F;EhCacheCache等各种缓存实现。它集成简单，支持丰富，实乃是业务开发的利器！  </p>\n<span id=\"more\"></span>\n\n<h2 id=\"SpringCache组件\"><a href=\"#SpringCache组件\" class=\"headerlink\" title=\"SpringCache组件\"></a>SpringCache组件</h2><p>先来看看一些接触到的常见注解  </p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CacheManager</td>\n<td>缓存管理器</td>\n</tr>\n<tr>\n<td>EnableCaching</td>\n<td>开启基于注解的缓存</td>\n</tr>\n<tr>\n<td>@Cacheable</td>\n<td>根据方法的请求参数对其进行缓存</td>\n</tr>\n<tr>\n<td>@CachePut</td>\n<td>更新缓存</td>\n</tr>\n<tr>\n<td>@CacheEvict</td>\n<td>清除缓存</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>@CacheConfig</td>\n<td>统一配置本类的缓存注解的属性</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>缓存数据时key生成策略</td>\n</tr>\n<tr>\n<td>serialize</td>\n<td>缓存数据时value序列化策略</td>\n</tr>\n</tbody></table>\n<h2 id=\"SpringCache基本使用\"><a href=\"#SpringCache基本使用\" class=\"headerlink\" title=\"SpringCache基本使用\"></a>SpringCache基本使用</h2><ol>\n<li><p>引入jar包</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启Cache支持<br>这里<code>@EnableCaching</code>可以直接作用于SpringBoot的启动类，但为了后续扩展。<br>我们定义一个CachingConfigurerSupport继承类，并加到这里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">CachingConfigurerSupport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 后续扩展</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@Cacheable(“xxx”)作用于方法<br>定义一个get方法，并加上Cacheable注解就可以了。<br>这里cache需要要有一个key，因此cacheNames必不可少。</p>\n</li>\n</ol>\n<p>##扩展：使用Reids作为缓存实现 </p>\n<ol>\n<li>yml配置  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cache:</span><br><span class=\"line\">    type: redis</span><br></pre></td></tr></table></figure></li>\n<li>定义ttl  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">CachingConfigurerSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisCacheConfiguration <span class=\"title\">buildRedisConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class=\"line\">                <span class=\"comment\">// 如果配置不缓存空，则注意返回对象也不可为空，否则报错</span></span><br><span class=\"line\"><span class=\"comment\">//                .disableCachingNullValues()</span></span><br><span class=\"line\">                .entryTtl(Duration.ofMinutes(<span class=\"number\">5L</span>))</span><br><span class=\"line\">                .prefixCacheNameWith(<span class=\"string\">&quot;My_Prefix_&quot;</span>)</span><br><span class=\"line\">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class=\"keyword\">new</span> StringRedisSerializer()))</span><br><span class=\"line\">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class=\"keyword\">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n这里，定义了ttl为5分钟，然后使用了自定义的前缀。序列化存储是为了在redisClient中容易参照。</li>\n</ol>\n<h2 id=\"自定义key\"><a href=\"#自定义key\" class=\"headerlink\" title=\"自定义key\"></a>自定义key</h2><p>其实，如果你使用@Cacheable和@CachePut分别作用于getById和updateById的时候就会发现，为什么CachePut明明会放置结果到缓存，为什么在get的时候获取不到？ 其实，都是因为默认的key不相同导致的。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/user&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@CacheConfig(cacheNames = &quot;userCache&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;Integer, String&gt; data_map =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap()&#123;&#123;</span><br><span class=\"line\">                put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Lily&quot;</span>);</span><br><span class=\"line\">                put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Linger&quot;</span>);</span><br><span class=\"line\">            &#125;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/get/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class=\"line\">      log.warn(<span class=\"string\">&quot;get &#123;&#125;&quot;</span>, id);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> data_map.get(id);</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/update&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@CachePut(key = &quot;#id&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">update</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> Integer id, <span class=\"meta\">@RequestParam</span> String name)</span> </span>&#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;add &#123;&#125; &#123;&#125;&quot;</span>, id, name);</span><br><span class=\"line\">        data_map.put(id, name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>像上面这样，都定义key为请求的ID，那么自然能达到我们想要的效果。  </p>\n<h2 id=\"使用心得\"><a href=\"#使用心得\" class=\"headerlink\" title=\"使用心得\"></a>使用心得</h2><p>1、Spring Cache使用还是很方便的，但是要特别注意，不然容易出bug<br>2、使用统一的CacheConfig, 明确定义查增改的key，或使用统一keyGenerator<br>3、由于get和update使用了一样的key，那么update方法的返回必须和get一致<br>4、注意key对应方法返回值就是key对应value！！尽量少的ttl，不然服务重启依旧取不到最新值<br>5、对于一般非联动缓存，直接用@Cacheable即可。方法cacheNames会覆盖类上的  </p>\n<hr>\n<p>以上例子的代码都已上传到Git：<br><a href=\"https://github.com/Hugh126/daydayup.git\">https://github.com/Hugh126/daydayup.git</a>  </p>\n<p>参考<br><a href=\"https://blog.csdn.net/qq_32448349/article/details/101696892\">https://blog.csdn.net/qq_32448349/article/details/101696892</a>  </p>\n","site":{"data":{}},"excerpt":"<p>SpringCache是Spring基于Spring切面提供的缓存增强技术。它集成了缓存常见的各种操作,如Cacheable&#x2F;CachePut&#x2F;CacheEvit等；也支持了ConcurrentMapCache&#x2F;RedisCache&#x2F;EhCacheCache等各种缓存实现。它集成简单，支持丰富，实乃是业务开发的利器！  </p>","more":"<h2 id=\"SpringCache组件\"><a href=\"#SpringCache组件\" class=\"headerlink\" title=\"SpringCache组件\"></a>SpringCache组件</h2><p>先来看看一些接触到的常见注解  </p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CacheManager</td>\n<td>缓存管理器</td>\n</tr>\n<tr>\n<td>EnableCaching</td>\n<td>开启基于注解的缓存</td>\n</tr>\n<tr>\n<td>@Cacheable</td>\n<td>根据方法的请求参数对其进行缓存</td>\n</tr>\n<tr>\n<td>@CachePut</td>\n<td>更新缓存</td>\n</tr>\n<tr>\n<td>@CacheEvict</td>\n<td>清除缓存</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>@CacheConfig</td>\n<td>统一配置本类的缓存注解的属性</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>缓存数据时key生成策略</td>\n</tr>\n<tr>\n<td>serialize</td>\n<td>缓存数据时value序列化策略</td>\n</tr>\n</tbody></table>\n<h2 id=\"SpringCache基本使用\"><a href=\"#SpringCache基本使用\" class=\"headerlink\" title=\"SpringCache基本使用\"></a>SpringCache基本使用</h2><ol>\n<li><p>引入jar包</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启Cache支持<br>这里<code>@EnableCaching</code>可以直接作用于SpringBoot的启动类，但为了后续扩展。<br>我们定义一个CachingConfigurerSupport继承类，并加到这里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">CachingConfigurerSupport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 后续扩展</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@Cacheable(“xxx”)作用于方法<br>定义一个get方法，并加上Cacheable注解就可以了。<br>这里cache需要要有一个key，因此cacheNames必不可少。</p>\n</li>\n</ol>\n<p>##扩展：使用Reids作为缓存实现 </p>\n<ol>\n<li>yml配置  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cache:</span><br><span class=\"line\">    type: redis</span><br></pre></td></tr></table></figure></li>\n<li>定义ttl  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">CachingConfigurerSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisCacheConfiguration <span class=\"title\">buildRedisConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class=\"line\">                <span class=\"comment\">// 如果配置不缓存空，则注意返回对象也不可为空，否则报错</span></span><br><span class=\"line\"><span class=\"comment\">//                .disableCachingNullValues()</span></span><br><span class=\"line\">                .entryTtl(Duration.ofMinutes(<span class=\"number\">5L</span>))</span><br><span class=\"line\">                .prefixCacheNameWith(<span class=\"string\">&quot;My_Prefix_&quot;</span>)</span><br><span class=\"line\">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class=\"keyword\">new</span> StringRedisSerializer()))</span><br><span class=\"line\">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class=\"keyword\">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n这里，定义了ttl为5分钟，然后使用了自定义的前缀。序列化存储是为了在redisClient中容易参照。</li>\n</ol>\n<h2 id=\"自定义key\"><a href=\"#自定义key\" class=\"headerlink\" title=\"自定义key\"></a>自定义key</h2><p>其实，如果你使用@Cacheable和@CachePut分别作用于getById和updateById的时候就会发现，为什么CachePut明明会放置结果到缓存，为什么在get的时候获取不到？ 其实，都是因为默认的key不相同导致的。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/user&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@CacheConfig(cacheNames = &quot;userCache&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;Integer, String&gt; data_map =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HashMap()&#123;&#123;</span><br><span class=\"line\">                put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Lily&quot;</span>);</span><br><span class=\"line\">                put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Linger&quot;</span>);</span><br><span class=\"line\">            &#125;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/get/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class=\"line\">      log.warn(<span class=\"string\">&quot;get &#123;&#125;&quot;</span>, id);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> data_map.get(id);</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/update&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@CachePut(key = &quot;#id&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">update</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> Integer id, <span class=\"meta\">@RequestParam</span> String name)</span> </span>&#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;add &#123;&#125; &#123;&#125;&quot;</span>, id, name);</span><br><span class=\"line\">        data_map.put(id, name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>像上面这样，都定义key为请求的ID，那么自然能达到我们想要的效果。  </p>\n<h2 id=\"使用心得\"><a href=\"#使用心得\" class=\"headerlink\" title=\"使用心得\"></a>使用心得</h2><p>1、Spring Cache使用还是很方便的，但是要特别注意，不然容易出bug<br>2、使用统一的CacheConfig, 明确定义查增改的key，或使用统一keyGenerator<br>3、由于get和update使用了一样的key，那么update方法的返回必须和get一致<br>4、注意key对应方法返回值就是key对应value！！尽量少的ttl，不然服务重启依旧取不到最新值<br>5、对于一般非联动缓存，直接用@Cacheable即可。方法cacheNames会覆盖类上的  </p>\n<hr>\n<p>以上例子的代码都已上传到Git：<br><a href=\"https://github.com/Hugh126/daydayup.git\">https://github.com/Hugh126/daydayup.git</a>  </p>\n<p>参考<br><a href=\"https://blog.csdn.net/qq_32448349/article/details/101696892\">https://blog.csdn.net/qq_32448349/article/details/101696892</a>  </p>"},{"title":"Spring源码-Autowired注解","date":"2023-10-11T05:19:59.000Z","_content":"古人说“绝知此事要躬行”，对于学习框架源码更是如此（本篇介绍源码阅读基础）\n<!--more-->\n\n# 一 新建干净的项目\n一个较多业务逻辑的项目对于源码阅读初入门的人，或多或少有一些干扰。  \n\n*从模板新建maven项目*    \n![](/images/Autowired1.png)\n\n*添加maven依赖*\n``` xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>5.2.8.RELEASE</version>\n</dependency>\n```\n\n*准备Bean*\n``` java\n// 新建类B\n@Component\npublic class B {\n}\n// 新建类A，注入属性B\n@Component\npublic class A  {\n    @Autowired\n    private B b;\n    public void test() {\n        System.out.println(\"b.info=\" + b);\n    }\n}\n```\n\n*启动Main方法*\n``` java\npublic class App \n{\n    public static void main( String[] args )\n    {\n        AbstractApplicationContext context = new AnnotationConfigApplicationContext(\"org.example\");\n        context.getBean(A.class).test();\n        context.close();\n    }\n}\n```\n\n# 二 Spring初始化流程认知  \n\n## refresh流程\n大致是如下流程:  \n1. 注解类或xml配置文件读取为BeanDefinition\n2. 创建BeanFactory\n3. 通过BeanDefinition为Bean工厂添加各种后置处理\n4. 遍历BeanDefinition中定义的BeanName，创建->初始化（填充属性、bean前置、自定义初始化、bean后置）  \n\n曾经看过马士兵的一次讲课，觉得很清晰，这里借用一下原图：  \n![](/images/Autowired2.png)\n\n## Bean的生命周期  \n参考BeanFactory接口注释  \n![](/images/Autowired3.png)\n\n## Bean工厂的默认实现  \n\nSpring对ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现:基于bean定义元数据的成熟bean工厂，可通过后处理器扩展。  \n\n## 条件断点  \n这里面设置条件断点：\nDefaultListableBeanFactory.doCreateBean\n    - createBeanInstance(beanName, mbd, args) // 创建Bean\n    - populateBean(beanName, mbd, instanceWrapper) // 填充Bean属性\n    \t-  ibp.postProcessProperties  // 这一行，注意ibp实现类为AutowiredAnnotationBeanPostProcessor\n  - metadata.inject(bean, beanName, pvs);\n内部调用顺序：\n  InjectionMetadata. inject -> AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject\n\n\n  # 三 源码Trace  \n\n*在实例化和初始化位置打条件断点*  \n\n![](/images/Autowired4.png)  \n  \n*在Bean的填充属性位置打条件断点，注意此处处理BP类型*  \n![](/images/Autowired5.png) \n\n*获取到需要注入的元数据后，执行注入*  \n![](/images/Autowired6.png) \n\n\n*然后是调用属性类的注入方法*  \n注意这里是继承内部类后复写的方法 ，OMG\n``` java\nprivate class AutowiredFieldElement extends InjectionMetadata.InjectedElement\n``` \n![](/images/Autowired7.png) \n\n\n*解决依赖 resolveDependency*  \n![](/images/Autowired8.png)\n\n*获取实例化对象b后，反射调用set注入*  \n![](/images/Autowired9.png)\n\n\n*递归调用b的属性填充*  \n对于没有下级依赖的属性，在填属性（populateBean）的时候依旧会走到inject方法，但是它的对象是InjectionMetadata.EMPTY ，会直接返回  \n![](/images/Autowired10.png)\n\n# 四 总结  \n\nAutowired的逻辑主要是在填充属性(populateBean)的时候，doResolveDependency进行处理的。  \n1. 首先会通过findAutowireCandidates查找所有类型匹配的类， 如果找不到直接异常  \n2. 如果有多个候选，那么determineAutowireCandidate会进行决定最终的候选，逻辑：\n    1. 是否有@Primary来赋予bean更高的优先级\n    2. 看是否实现了OrderComparator，通过更高优先级来匹配\n    3. 通过给定的名称匹配  \n\n--- \n在熟悉既有逻辑后，不妨思考一下以前学习Autowired自动装配的规则(优先类型匹配，然后名称匹配)：  \n可以将类型变更为接口，或者Object，又或者改下默认的field名称，看是否可以匹配上。对应的源码又是怎么走的。  \n","source":"_posts/Spring源码-Autowired注解.md","raw":"---\ntitle: Spring源码-Autowired注解\ndate: 2023-10-11 13:19:59\ntags: \n- Spring源码\ncategories: Spring+\n---\n古人说“绝知此事要躬行”，对于学习框架源码更是如此（本篇介绍源码阅读基础）\n<!--more-->\n\n# 一 新建干净的项目\n一个较多业务逻辑的项目对于源码阅读初入门的人，或多或少有一些干扰。  \n\n*从模板新建maven项目*    \n![](/images/Autowired1.png)\n\n*添加maven依赖*\n``` xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>5.2.8.RELEASE</version>\n</dependency>\n```\n\n*准备Bean*\n``` java\n// 新建类B\n@Component\npublic class B {\n}\n// 新建类A，注入属性B\n@Component\npublic class A  {\n    @Autowired\n    private B b;\n    public void test() {\n        System.out.println(\"b.info=\" + b);\n    }\n}\n```\n\n*启动Main方法*\n``` java\npublic class App \n{\n    public static void main( String[] args )\n    {\n        AbstractApplicationContext context = new AnnotationConfigApplicationContext(\"org.example\");\n        context.getBean(A.class).test();\n        context.close();\n    }\n}\n```\n\n# 二 Spring初始化流程认知  \n\n## refresh流程\n大致是如下流程:  \n1. 注解类或xml配置文件读取为BeanDefinition\n2. 创建BeanFactory\n3. 通过BeanDefinition为Bean工厂添加各种后置处理\n4. 遍历BeanDefinition中定义的BeanName，创建->初始化（填充属性、bean前置、自定义初始化、bean后置）  \n\n曾经看过马士兵的一次讲课，觉得很清晰，这里借用一下原图：  \n![](/images/Autowired2.png)\n\n## Bean的生命周期  \n参考BeanFactory接口注释  \n![](/images/Autowired3.png)\n\n## Bean工厂的默认实现  \n\nSpring对ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现:基于bean定义元数据的成熟bean工厂，可通过后处理器扩展。  \n\n## 条件断点  \n这里面设置条件断点：\nDefaultListableBeanFactory.doCreateBean\n    - createBeanInstance(beanName, mbd, args) // 创建Bean\n    - populateBean(beanName, mbd, instanceWrapper) // 填充Bean属性\n    \t-  ibp.postProcessProperties  // 这一行，注意ibp实现类为AutowiredAnnotationBeanPostProcessor\n  - metadata.inject(bean, beanName, pvs);\n内部调用顺序：\n  InjectionMetadata. inject -> AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject\n\n\n  # 三 源码Trace  \n\n*在实例化和初始化位置打条件断点*  \n\n![](/images/Autowired4.png)  \n  \n*在Bean的填充属性位置打条件断点，注意此处处理BP类型*  \n![](/images/Autowired5.png) \n\n*获取到需要注入的元数据后，执行注入*  \n![](/images/Autowired6.png) \n\n\n*然后是调用属性类的注入方法*  \n注意这里是继承内部类后复写的方法 ，OMG\n``` java\nprivate class AutowiredFieldElement extends InjectionMetadata.InjectedElement\n``` \n![](/images/Autowired7.png) \n\n\n*解决依赖 resolveDependency*  \n![](/images/Autowired8.png)\n\n*获取实例化对象b后，反射调用set注入*  \n![](/images/Autowired9.png)\n\n\n*递归调用b的属性填充*  \n对于没有下级依赖的属性，在填属性（populateBean）的时候依旧会走到inject方法，但是它的对象是InjectionMetadata.EMPTY ，会直接返回  \n![](/images/Autowired10.png)\n\n# 四 总结  \n\nAutowired的逻辑主要是在填充属性(populateBean)的时候，doResolveDependency进行处理的。  \n1. 首先会通过findAutowireCandidates查找所有类型匹配的类， 如果找不到直接异常  \n2. 如果有多个候选，那么determineAutowireCandidate会进行决定最终的候选，逻辑：\n    1. 是否有@Primary来赋予bean更高的优先级\n    2. 看是否实现了OrderComparator，通过更高优先级来匹配\n    3. 通过给定的名称匹配  \n\n--- \n在熟悉既有逻辑后，不妨思考一下以前学习Autowired自动装配的规则(优先类型匹配，然后名称匹配)：  \n可以将类型变更为接口，或者Object，又或者改下默认的field名称，看是否可以匹配上。对应的源码又是怎么走的。  \n","slug":"Spring源码-Autowired注解","published":1,"updated":"2024-02-18T08:31:32.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyz001aqwvdgkjh86e5","content":"<p>古人说“绝知此事要躬行”，对于学习框架源码更是如此（本篇介绍源码阅读基础）</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一-新建干净的项目\"><a href=\"#一-新建干净的项目\" class=\"headerlink\" title=\"一 新建干净的项目\"></a>一 新建干净的项目</h1><p>一个较多业务逻辑的项目对于源码阅读初入门的人，或多或少有一些干扰。  </p>\n<p><em>从模板新建maven项目</em><br><img src=\"/images/Autowired1.png\"></p>\n<p><em>添加maven依赖</em></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>准备Bean</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建类B</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 新建类A，注入属性B</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;b.info=&quot;</span> + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>启动Main方法</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">( String[] args )</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        AbstractApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(<span class=\"string\">&quot;org.example&quot;</span>);</span><br><span class=\"line\">        context.getBean(A.class).test();</span><br><span class=\"line\">        context.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二-Spring初始化流程认知\"><a href=\"#二-Spring初始化流程认知\" class=\"headerlink\" title=\"二 Spring初始化流程认知\"></a>二 Spring初始化流程认知</h1><h2 id=\"refresh流程\"><a href=\"#refresh流程\" class=\"headerlink\" title=\"refresh流程\"></a>refresh流程</h2><p>大致是如下流程:  </p>\n<ol>\n<li>注解类或xml配置文件读取为BeanDefinition</li>\n<li>创建BeanFactory</li>\n<li>通过BeanDefinition为Bean工厂添加各种后置处理</li>\n<li>遍历BeanDefinition中定义的BeanName，创建-&gt;初始化（填充属性、bean前置、自定义初始化、bean后置）</li>\n</ol>\n<p>曾经看过马士兵的一次讲课，觉得很清晰，这里借用一下原图：<br><img src=\"/images/Autowired2.png\"></p>\n<h2 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h2><p>参考BeanFactory接口注释<br><img src=\"/images/Autowired3.png\"></p>\n<h2 id=\"Bean工厂的默认实现\"><a href=\"#Bean工厂的默认实现\" class=\"headerlink\" title=\"Bean工厂的默认实现\"></a>Bean工厂的默认实现</h2><p>Spring对ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现:基于bean定义元数据的成熟bean工厂，可通过后处理器扩展。  </p>\n<h2 id=\"条件断点\"><a href=\"#条件断点\" class=\"headerlink\" title=\"条件断点\"></a>条件断点</h2><p>这里面设置条件断点：<br>DefaultListableBeanFactory.doCreateBean<br>    - createBeanInstance(beanName, mbd, args) &#x2F;&#x2F; 创建Bean<br>    - populateBean(beanName, mbd, instanceWrapper) &#x2F;&#x2F; 填充Bean属性<br>        -  ibp.postProcessProperties  &#x2F;&#x2F; 这一行，注意ibp实现类为AutowiredAnnotationBeanPostProcessor</p>\n<ul>\n<li>metadata.inject(bean, beanName, pvs);<br>内部调用顺序：<br>  InjectionMetadata. inject -&gt; AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject</li>\n</ul>\n<h1 id=\"三-源码Trace\"><a href=\"#三-源码Trace\" class=\"headerlink\" title=\"三 源码Trace\"></a>三 源码Trace</h1><p><em>在实例化和初始化位置打条件断点</em>  </p>\n<p><img src=\"/images/Autowired4.png\">  </p>\n<p><em>在Bean的填充属性位置打条件断点，注意此处处理BP类型</em><br><img src=\"/images/Autowired5.png\"> </p>\n<p><em>获取到需要注入的元数据后，执行注入</em><br><img src=\"/images/Autowired6.png\"> </p>\n<p><em>然后是调用属性类的注入方法</em><br>注意这里是继承内部类后复写的方法 ，OMG</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutowiredFieldElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">InjectionMetadata</span>.<span class=\"title\">InjectedElement</span></span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/Autowired7.png\"> </p>\n<p><em>解决依赖 resolveDependency</em><br><img src=\"/images/Autowired8.png\"></p>\n<p><em>获取实例化对象b后，反射调用set注入</em><br><img src=\"/images/Autowired9.png\"></p>\n<p><em>递归调用b的属性填充</em><br>对于没有下级依赖的属性，在填属性（populateBean）的时候依旧会走到inject方法，但是它的对象是InjectionMetadata.EMPTY ，会直接返回<br><img src=\"/images/Autowired10.png\"></p>\n<h1 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h1><p>Autowired的逻辑主要是在填充属性(populateBean)的时候，doResolveDependency进行处理的。  </p>\n<ol>\n<li>首先会通过findAutowireCandidates查找所有类型匹配的类， 如果找不到直接异常  </li>\n<li>如果有多个候选，那么determineAutowireCandidate会进行决定最终的候选，逻辑：<ol>\n<li>是否有@Primary来赋予bean更高的优先级</li>\n<li>看是否实现了OrderComparator，通过更高优先级来匹配</li>\n<li>通过给定的名称匹配</li>\n</ol>\n</li>\n</ol>\n<hr>\n<p>在熟悉既有逻辑后，不妨思考一下以前学习Autowired自动装配的规则(优先类型匹配，然后名称匹配)：<br>可以将类型变更为接口，或者Object，又或者改下默认的field名称，看是否可以匹配上。对应的源码又是怎么走的。  </p>\n","site":{"data":{}},"excerpt":"<p>古人说“绝知此事要躬行”，对于学习框架源码更是如此（本篇介绍源码阅读基础）</p>","more":"<h1 id=\"一-新建干净的项目\"><a href=\"#一-新建干净的项目\" class=\"headerlink\" title=\"一 新建干净的项目\"></a>一 新建干净的项目</h1><p>一个较多业务逻辑的项目对于源码阅读初入门的人，或多或少有一些干扰。  </p>\n<p><em>从模板新建maven项目</em><br><img src=\"/images/Autowired1.png\"></p>\n<p><em>添加maven依赖</em></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>准备Bean</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建类B</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 新建类A，注入属性B</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;b.info=&quot;</span> + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>启动Main方法</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">( String[] args )</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        AbstractApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(<span class=\"string\">&quot;org.example&quot;</span>);</span><br><span class=\"line\">        context.getBean(A.class).test();</span><br><span class=\"line\">        context.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二-Spring初始化流程认知\"><a href=\"#二-Spring初始化流程认知\" class=\"headerlink\" title=\"二 Spring初始化流程认知\"></a>二 Spring初始化流程认知</h1><h2 id=\"refresh流程\"><a href=\"#refresh流程\" class=\"headerlink\" title=\"refresh流程\"></a>refresh流程</h2><p>大致是如下流程:  </p>\n<ol>\n<li>注解类或xml配置文件读取为BeanDefinition</li>\n<li>创建BeanFactory</li>\n<li>通过BeanDefinition为Bean工厂添加各种后置处理</li>\n<li>遍历BeanDefinition中定义的BeanName，创建-&gt;初始化（填充属性、bean前置、自定义初始化、bean后置）</li>\n</ol>\n<p>曾经看过马士兵的一次讲课，觉得很清晰，这里借用一下原图：<br><img src=\"/images/Autowired2.png\"></p>\n<h2 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h2><p>参考BeanFactory接口注释<br><img src=\"/images/Autowired3.png\"></p>\n<h2 id=\"Bean工厂的默认实现\"><a href=\"#Bean工厂的默认实现\" class=\"headerlink\" title=\"Bean工厂的默认实现\"></a>Bean工厂的默认实现</h2><p>Spring对ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现:基于bean定义元数据的成熟bean工厂，可通过后处理器扩展。  </p>\n<h2 id=\"条件断点\"><a href=\"#条件断点\" class=\"headerlink\" title=\"条件断点\"></a>条件断点</h2><p>这里面设置条件断点：<br>DefaultListableBeanFactory.doCreateBean<br>    - createBeanInstance(beanName, mbd, args) &#x2F;&#x2F; 创建Bean<br>    - populateBean(beanName, mbd, instanceWrapper) &#x2F;&#x2F; 填充Bean属性<br>        -  ibp.postProcessProperties  &#x2F;&#x2F; 这一行，注意ibp实现类为AutowiredAnnotationBeanPostProcessor</p>\n<ul>\n<li>metadata.inject(bean, beanName, pvs);<br>内部调用顺序：<br>  InjectionMetadata. inject -&gt; AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject</li>\n</ul>\n<h1 id=\"三-源码Trace\"><a href=\"#三-源码Trace\" class=\"headerlink\" title=\"三 源码Trace\"></a>三 源码Trace</h1><p><em>在实例化和初始化位置打条件断点</em>  </p>\n<p><img src=\"/images/Autowired4.png\">  </p>\n<p><em>在Bean的填充属性位置打条件断点，注意此处处理BP类型</em><br><img src=\"/images/Autowired5.png\"> </p>\n<p><em>获取到需要注入的元数据后，执行注入</em><br><img src=\"/images/Autowired6.png\"> </p>\n<p><em>然后是调用属性类的注入方法</em><br>注意这里是继承内部类后复写的方法 ，OMG</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutowiredFieldElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">InjectionMetadata</span>.<span class=\"title\">InjectedElement</span></span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/Autowired7.png\"> </p>\n<p><em>解决依赖 resolveDependency</em><br><img src=\"/images/Autowired8.png\"></p>\n<p><em>获取实例化对象b后，反射调用set注入</em><br><img src=\"/images/Autowired9.png\"></p>\n<p><em>递归调用b的属性填充</em><br>对于没有下级依赖的属性，在填属性（populateBean）的时候依旧会走到inject方法，但是它的对象是InjectionMetadata.EMPTY ，会直接返回<br><img src=\"/images/Autowired10.png\"></p>\n<h1 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h1><p>Autowired的逻辑主要是在填充属性(populateBean)的时候，doResolveDependency进行处理的。  </p>\n<ol>\n<li>首先会通过findAutowireCandidates查找所有类型匹配的类， 如果找不到直接异常  </li>\n<li>如果有多个候选，那么determineAutowireCandidate会进行决定最终的候选，逻辑：<ol>\n<li>是否有@Primary来赋予bean更高的优先级</li>\n<li>看是否实现了OrderComparator，通过更高优先级来匹配</li>\n<li>通过给定的名称匹配</li>\n</ol>\n</li>\n</ol>\n<hr>\n<p>在熟悉既有逻辑后，不妨思考一下以前学习Autowired自动装配的规则(优先类型匹配，然后名称匹配)：<br>可以将类型变更为接口，或者Object，又或者改下默认的field名称，看是否可以匹配上。对应的源码又是怎么走的。  </p>"},{"title":"Spring源码-@Scheduled注解","date":"2023-10-08T07:22:11.000Z","_content":"\n在熟悉Spring中Bean启动流程后，知晓@Scheduled的原理不难。但是，这次debug并不简单...\n<!--more-->  \n\n# 一 @Scheduled原理\n  \n*古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码*\n---\n\n直接点到`@EnableScheduling`注解里面看  \n``` java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Import(SchedulingConfiguration.class)\n@Documented\npublic @interface EnableScheduling {\n\n}\n```\n其中引入了`SchedulingConfiguration`类，再进\n``` java\n@Configuration(proxyBeanMethods = false)\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\npublic class SchedulingConfiguration {\n\n\t@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() {\n\t\treturn new ScheduledAnnotationBeanPostProcessor();\n\t}\n\n}\n```\n**关键类及关键方法** :  \n\n `ScheduledAnnotationBeanPostProcessor`，显然是一个`BeanPostProcessor`（bean后置处理器，重载方法: `postProcessAfterInitialization`）,同时它实现了`ApplicationListener<ContextRefreshedEvent>`。在SpringContext完成后会有个`onApplicationEvent`回调动作。  \n大概看一下这两个方法`postProcessAfterInitialization`和`onApplicationEvent`。  \n`postProcessAfterInitialization`方法，其实就是在每个Bean初始化阶段，对Bean中方法注解进行扫描，如果有@Scheduled注解，那么就把它封装成一个Runnable注册到一个Set<ScheduledTask>存起来。\n![](/images/spring5-scheduled注册0.png)\n注册方法调用栈:  \n![](/images/spring5-scheduled注册.png)\n而`onApplicationEvent`方法恰恰就是从之前那个Set里面取下一次触发时间和执行方法体作为一个延迟任务丢到线程池中执行：  \n![](/images/schedule执行.png)\n\n# 二 Spring3中@Scheduled注解失效原因\n\n## 2.1 先跟进一下一个正常的单例Bean\n基本和Spring3.2是一致的, 大致是先注册，后执行： \n``` txt\n注册：\ndoCreateBean-> initializeBean -> applyBeanPostProcessorsAfterInitialization\n-> ScheduledAnnotationBeanPostProcessor::postProcessAfterInitialization\n-> processScheduled\n\n\n执行：\nApplicationListener<ContextRefreshedEvent>:: onApplicationEvent \n\t-> ScheduledAnnotationBeanPostProcessor:: onApplicationEvent \n\t-> registrar.afterPropertiesSet()\n\t-> scheduleTasks\n```\n1. Bean初始化的时候进入ScheduledAnnotationBeanPostProcessor\n![](/images/ScheduledAnnotationBeanPostProcessor-单例bean可以注入.png)\n2. 通过Bean后置处理器中的processScheduled完成注册\n![](/images/Scheduled定时任务注册.png)\n\n## 2.2 @Scope(\"prototype\")的Bean\n从任务启动的位置肯定是看不出毛病的。 那么，跟一下用修饰为原型的Bean的注册流程  \n![](/images/ScheduledAnnotationBeanPostProcessor-scope_prototype无法注入定时任务.png)  \n这里，Bean的后置初始化阶段，居然没有关键的`ScheduledAnnotationBeanPostProcessor`。那么肯定是无法像单例Bean一样把任务注册到内部Set的。\n\n\n# 三 总结\n1. ScheduledAnnotationBeanPostProcessor是@Scheduled的核心类，注册任务和执行任务的方法都封装其中\n2. @Scope(\"prototype\")的作用是每次需要Bean都会重新创建，而创建的时候是每次getBean()的时候！！！也就是说，如果这个Bean不会被用到，就根本不会被创建。即使在SpringContext启动后，这个Bean被BeanFactory创建，但是初始化的时候是没有关键的Bean后置处理器ScheduledAnnotationBeanPostProcessor的。这就是@Scheduled不生效的原因。\n3. @Scope(\"prototype\")修饰的Bean[不会纳入Bean的生命周期管理](https://springdoc.cn/spring-bean-scope-guides/)\n\n# 四 暗藏玄机\n*虽然知道注解不生效的原因是ScheduledAnnotationBeanPostProcessor没有被BeanFactory加载，但是我仍不明白为啥在BeanFactory启动的时候，单例Bean可以获取到这个后置处理器，但启动后getBean的时候却没有了*\n\n## 4.1 SpringMVC多上下文\n由于需要跟进BeanPostProcessor的加载，我在AbstractApplicationContext中断点了`registerBeanPostProcessors`方法。  \n却发现它居然进去了两次!!!  \n原来是tomcat中SpringFrameworkServelet还会触发一次refresh，因此，实际上会产生两个Spring容器(上下文): \n![](/images/scheduled_5_1.png)    \n实际debug跟进的时候发现，类型没变，但是BeanFactory的引用变了！！实际引用过程如下：  \n``` log\n1. BeanFactory加载对应BeanPostProcessor\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n2. BeanFactory初始化Bean\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n3. FrameworkServlet触发initWebApplicationContext，再次refresh\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n4. 再次进入Bean初始化\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n5. FrameworkServlet中getBean()(@Scope(\"prototype\")修饰的Bean)\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n```   \n\n在跟进为什么第二次refresh，获取不到关键Bean后置问题的时候，找到了加载关键Bean的位置：\n![](/images/scheduled_5_4.png) \n需要注意的是，关键Bean后置的名称并不是默认的类名首字母小写，而是(如果注意不到这点，很容易判断出错)：  \n`org.springframework.context.annotation.internalScheduledAnnotationProcessor`  \n ![](/images/scheduled_5_3.png)  \n\n这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web.xml中Servelet配置的配置文件确实只有spring-mvc.xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。    \n但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！  \n原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：\n ![](/images/scheduled_5_5.png) \n ---\n 问题既然分析清楚了，那么解决ScheduledAnnotationBeanPostProcessor的办法也很简单：  \n > \n \t1. 将spring-task的配置放到spring-mvc.xml中 \n \t2. 将web.xml配置的第二个上下文的配置文件补充完成，可用类似`classpath:spring-*.xml`\n\n\n\n## 4.2 版本差异\n由于Spring3版本的服务启动实在费时间，很多时候跟进源码都是直接通过新启动的Springboot服务来跟进的。 但是我却发现，Spring5中用@Scope(\"prototype\")的Bean中的@Scheduled注解可以生效!!  \n对比了下ScheduledAnnotationBeanPostProcessor中的后置方法后，发现了Spring3仅仅只是加入到Register的List，而Spring5中却实实在在的将其加入到执行线程池了。  \n![](/images/scheduled_5_2.png)\n因此，即使在Spring3中将ScheduledAnnotationBeanPostProcessor处理器加载到新的Spring上下文中，也是无法让原型Bean的定时任务执行。\n\n\n\n\n\n\n","source":"_posts/Spring源码-Scheduled注解.md","raw":"---\ntitle: Spring源码-@Scheduled注解\ndate: 2023-10-08 15:22:11\ntags:\n- Spring源码\ncategories: Spring+\n---\n\n在熟悉Spring中Bean启动流程后，知晓@Scheduled的原理不难。但是，这次debug并不简单...\n<!--more-->  \n\n# 一 @Scheduled原理\n  \n*古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码*\n---\n\n直接点到`@EnableScheduling`注解里面看  \n``` java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Import(SchedulingConfiguration.class)\n@Documented\npublic @interface EnableScheduling {\n\n}\n```\n其中引入了`SchedulingConfiguration`类，再进\n``` java\n@Configuration(proxyBeanMethods = false)\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\npublic class SchedulingConfiguration {\n\n\t@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() {\n\t\treturn new ScheduledAnnotationBeanPostProcessor();\n\t}\n\n}\n```\n**关键类及关键方法** :  \n\n `ScheduledAnnotationBeanPostProcessor`，显然是一个`BeanPostProcessor`（bean后置处理器，重载方法: `postProcessAfterInitialization`）,同时它实现了`ApplicationListener<ContextRefreshedEvent>`。在SpringContext完成后会有个`onApplicationEvent`回调动作。  \n大概看一下这两个方法`postProcessAfterInitialization`和`onApplicationEvent`。  \n`postProcessAfterInitialization`方法，其实就是在每个Bean初始化阶段，对Bean中方法注解进行扫描，如果有@Scheduled注解，那么就把它封装成一个Runnable注册到一个Set<ScheduledTask>存起来。\n![](/images/spring5-scheduled注册0.png)\n注册方法调用栈:  \n![](/images/spring5-scheduled注册.png)\n而`onApplicationEvent`方法恰恰就是从之前那个Set里面取下一次触发时间和执行方法体作为一个延迟任务丢到线程池中执行：  \n![](/images/schedule执行.png)\n\n# 二 Spring3中@Scheduled注解失效原因\n\n## 2.1 先跟进一下一个正常的单例Bean\n基本和Spring3.2是一致的, 大致是先注册，后执行： \n``` txt\n注册：\ndoCreateBean-> initializeBean -> applyBeanPostProcessorsAfterInitialization\n-> ScheduledAnnotationBeanPostProcessor::postProcessAfterInitialization\n-> processScheduled\n\n\n执行：\nApplicationListener<ContextRefreshedEvent>:: onApplicationEvent \n\t-> ScheduledAnnotationBeanPostProcessor:: onApplicationEvent \n\t-> registrar.afterPropertiesSet()\n\t-> scheduleTasks\n```\n1. Bean初始化的时候进入ScheduledAnnotationBeanPostProcessor\n![](/images/ScheduledAnnotationBeanPostProcessor-单例bean可以注入.png)\n2. 通过Bean后置处理器中的processScheduled完成注册\n![](/images/Scheduled定时任务注册.png)\n\n## 2.2 @Scope(\"prototype\")的Bean\n从任务启动的位置肯定是看不出毛病的。 那么，跟一下用修饰为原型的Bean的注册流程  \n![](/images/ScheduledAnnotationBeanPostProcessor-scope_prototype无法注入定时任务.png)  \n这里，Bean的后置初始化阶段，居然没有关键的`ScheduledAnnotationBeanPostProcessor`。那么肯定是无法像单例Bean一样把任务注册到内部Set的。\n\n\n# 三 总结\n1. ScheduledAnnotationBeanPostProcessor是@Scheduled的核心类，注册任务和执行任务的方法都封装其中\n2. @Scope(\"prototype\")的作用是每次需要Bean都会重新创建，而创建的时候是每次getBean()的时候！！！也就是说，如果这个Bean不会被用到，就根本不会被创建。即使在SpringContext启动后，这个Bean被BeanFactory创建，但是初始化的时候是没有关键的Bean后置处理器ScheduledAnnotationBeanPostProcessor的。这就是@Scheduled不生效的原因。\n3. @Scope(\"prototype\")修饰的Bean[不会纳入Bean的生命周期管理](https://springdoc.cn/spring-bean-scope-guides/)\n\n# 四 暗藏玄机\n*虽然知道注解不生效的原因是ScheduledAnnotationBeanPostProcessor没有被BeanFactory加载，但是我仍不明白为啥在BeanFactory启动的时候，单例Bean可以获取到这个后置处理器，但启动后getBean的时候却没有了*\n\n## 4.1 SpringMVC多上下文\n由于需要跟进BeanPostProcessor的加载，我在AbstractApplicationContext中断点了`registerBeanPostProcessors`方法。  \n却发现它居然进去了两次!!!  \n原来是tomcat中SpringFrameworkServelet还会触发一次refresh，因此，实际上会产生两个Spring容器(上下文): \n![](/images/scheduled_5_1.png)    \n实际debug跟进的时候发现，类型没变，但是BeanFactory的引用变了！！实际引用过程如下：  \n``` log\n1. BeanFactory加载对应BeanPostProcessor\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n2. BeanFactory初始化Bean\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n3. FrameworkServlet触发initWebApplicationContext，再次refresh\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n4. 再次进入Bean初始化\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n5. FrameworkServlet中getBean()(@Scope(\"prototype\")修饰的Bean)\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n```   \n\n在跟进为什么第二次refresh，获取不到关键Bean后置问题的时候，找到了加载关键Bean的位置：\n![](/images/scheduled_5_4.png) \n需要注意的是，关键Bean后置的名称并不是默认的类名首字母小写，而是(如果注意不到这点，很容易判断出错)：  \n`org.springframework.context.annotation.internalScheduledAnnotationProcessor`  \n ![](/images/scheduled_5_3.png)  \n\n这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web.xml中Servelet配置的配置文件确实只有spring-mvc.xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。    \n但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！  \n原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：\n ![](/images/scheduled_5_5.png) \n ---\n 问题既然分析清楚了，那么解决ScheduledAnnotationBeanPostProcessor的办法也很简单：  \n > \n \t1. 将spring-task的配置放到spring-mvc.xml中 \n \t2. 将web.xml配置的第二个上下文的配置文件补充完成，可用类似`classpath:spring-*.xml`\n\n\n\n## 4.2 版本差异\n由于Spring3版本的服务启动实在费时间，很多时候跟进源码都是直接通过新启动的Springboot服务来跟进的。 但是我却发现，Spring5中用@Scope(\"prototype\")的Bean中的@Scheduled注解可以生效!!  \n对比了下ScheduledAnnotationBeanPostProcessor中的后置方法后，发现了Spring3仅仅只是加入到Register的List，而Spring5中却实实在在的将其加入到执行线程池了。  \n![](/images/scheduled_5_2.png)\n因此，即使在Spring3中将ScheduledAnnotationBeanPostProcessor处理器加载到新的Spring上下文中，也是无法让原型Bean的定时任务执行。\n\n\n\n\n\n\n","slug":"Spring源码-Scheduled注解","published":1,"updated":"2024-02-18T08:31:51.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oyz001eqwvd58z0ddan","content":"<p>在熟悉Spring中Bean启动流程后，知晓@Scheduled的原理不难。但是，这次debug并不简单…</p>\n<span id=\"more\"></span>  \n\n<h1 id=\"一-Scheduled原理\"><a href=\"#一-Scheduled原理\" class=\"headerlink\" title=\"一 @Scheduled原理\"></a>一 @Scheduled原理</h1><h2 id=\"古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码\"><a href=\"#古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码\" class=\"headerlink\" title=\"古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码\"></a><em>古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码</em></h2><p>直接点到<code>@EnableScheduling</code>注解里面看  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(SchedulingConfiguration.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableScheduling &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中引入了<code>SchedulingConfiguration</code>类，再进</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SchedulingConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ScheduledAnnotationBeanPostProcessor <span class=\"title\">scheduledAnnotationProcessor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>关键类及关键方法</strong> :  </p>\n<p> <code>ScheduledAnnotationBeanPostProcessor</code>，显然是一个<code>BeanPostProcessor</code>（bean后置处理器，重载方法: <code>postProcessAfterInitialization</code>）,同时它实现了<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>。在SpringContext完成后会有个<code>onApplicationEvent</code>回调动作。<br>大概看一下这两个方法<code>postProcessAfterInitialization</code>和<code>onApplicationEvent</code>。<br><code>postProcessAfterInitialization</code>方法，其实就是在每个Bean初始化阶段，对Bean中方法注解进行扫描，如果有@Scheduled注解，那么就把它封装成一个Runnable注册到一个Set<ScheduledTask>存起来。<br><img src=\"/images/spring5-scheduled%E6%B3%A8%E5%86%8C0.png\"><br>注册方法调用栈:<br><img src=\"/images/spring5-scheduled%E6%B3%A8%E5%86%8C.png\"><br>而<code>onApplicationEvent</code>方法恰恰就是从之前那个Set里面取下一次触发时间和执行方法体作为一个延迟任务丢到线程池中执行：<br><img src=\"/images/schedule%E6%89%A7%E8%A1%8C.png\"></ScheduledTask></p>\n<h1 id=\"二-Spring3中-Scheduled注解失效原因\"><a href=\"#二-Spring3中-Scheduled注解失效原因\" class=\"headerlink\" title=\"二 Spring3中@Scheduled注解失效原因\"></a>二 Spring3中@Scheduled注解失效原因</h1><h2 id=\"2-1-先跟进一下一个正常的单例Bean\"><a href=\"#2-1-先跟进一下一个正常的单例Bean\" class=\"headerlink\" title=\"2.1 先跟进一下一个正常的单例Bean\"></a>2.1 先跟进一下一个正常的单例Bean</h2><p>基本和Spring3.2是一致的, 大致是先注册，后执行： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注册：</span><br><span class=\"line\">doCreateBean-&gt; initializeBean -&gt; applyBeanPostProcessorsAfterInitialization</span><br><span class=\"line\">-&gt; ScheduledAnnotationBeanPostProcessor::postProcessAfterInitialization</span><br><span class=\"line\">-&gt; processScheduled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">执行：</span><br><span class=\"line\">ApplicationListener&lt;ContextRefreshedEvent&gt;:: onApplicationEvent </span><br><span class=\"line\">\t-&gt; ScheduledAnnotationBeanPostProcessor:: onApplicationEvent </span><br><span class=\"line\">\t-&gt; registrar.afterPropertiesSet()</span><br><span class=\"line\">\t-&gt; scheduleTasks</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Bean初始化的时候进入ScheduledAnnotationBeanPostProcessor<br><img src=\"/images/ScheduledAnnotationBeanPostProcessor-%E5%8D%95%E4%BE%8Bbean%E5%8F%AF%E4%BB%A5%E6%B3%A8%E5%85%A5.png\"></li>\n<li>通过Bean后置处理器中的processScheduled完成注册<br><img src=\"/images/Scheduled%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%B3%A8%E5%86%8C.png\"></li>\n</ol>\n<h2 id=\"2-2-Scope-“prototype”-的Bean\"><a href=\"#2-2-Scope-“prototype”-的Bean\" class=\"headerlink\" title=\"2.2 @Scope(“prototype”)的Bean\"></a>2.2 @Scope(“prototype”)的Bean</h2><p>从任务启动的位置肯定是看不出毛病的。 那么，跟一下用修饰为原型的Bean的注册流程<br><img src=\"/images/ScheduledAnnotationBeanPostProcessor-scope_prototype%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png\"><br>这里，Bean的后置初始化阶段，居然没有关键的<code>ScheduledAnnotationBeanPostProcessor</code>。那么肯定是无法像单例Bean一样把任务注册到内部Set的。</p>\n<h1 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h1><ol>\n<li>ScheduledAnnotationBeanPostProcessor是@Scheduled的核心类，注册任务和执行任务的方法都封装其中</li>\n<li>@Scope(“prototype”)的作用是每次需要Bean都会重新创建，而创建的时候是每次getBean()的时候！！！也就是说，如果这个Bean不会被用到，就根本不会被创建。即使在SpringContext启动后，这个Bean被BeanFactory创建，但是初始化的时候是没有关键的Bean后置处理器ScheduledAnnotationBeanPostProcessor的。这就是@Scheduled不生效的原因。</li>\n<li>@Scope(“prototype”)修饰的Bean<a href=\"https://springdoc.cn/spring-bean-scope-guides/\">不会纳入Bean的生命周期管理</a></li>\n</ol>\n<h1 id=\"四-暗藏玄机\"><a href=\"#四-暗藏玄机\" class=\"headerlink\" title=\"四 暗藏玄机\"></a>四 暗藏玄机</h1><p><em>虽然知道注解不生效的原因是ScheduledAnnotationBeanPostProcessor没有被BeanFactory加载，但是我仍不明白为啥在BeanFactory启动的时候，单例Bean可以获取到这个后置处理器，但启动后getBean的时候却没有了</em></p>\n<h2 id=\"4-1-SpringMVC多上下文\"><a href=\"#4-1-SpringMVC多上下文\" class=\"headerlink\" title=\"4.1 SpringMVC多上下文\"></a>4.1 SpringMVC多上下文</h2><p>由于需要跟进BeanPostProcessor的加载，我在AbstractApplicationContext中断点了<code>registerBeanPostProcessors</code>方法。<br>却发现它居然进去了两次!!!<br>原来是tomcat中SpringFrameworkServelet还会触发一次refresh，因此，实际上会产生两个Spring容器(上下文):<br><img src=\"/images/scheduled_5_1.png\"><br>实际debug跟进的时候发现，类型没变，但是BeanFactory的引用变了！！实际引用过程如下：  </p>\n<pre><code class=\"log\">1. BeanFactory加载对应BeanPostProcessor\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n2. BeanFactory初始化Bean\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n3. FrameworkServlet触发initWebApplicationContext，再次refresh\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n4. 再次进入Bean初始化\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n5. FrameworkServlet中getBean()(@Scope(&quot;prototype&quot;)修饰的Bean)\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n</code></pre>\n<p>在跟进为什么第二次refresh，获取不到关键Bean后置问题的时候，找到了加载关键Bean的位置：<br><img src=\"/images/scheduled_5_4.png\"><br>需要注意的是，关键Bean后置的名称并不是默认的类名首字母小写，而是(如果注意不到这点，很容易判断出错)：<br><code>org.springframework.context.annotation.internalScheduledAnnotationProcessor</code><br> <img src=\"/images/scheduled_5_3.png\">  </p>\n<h2 id=\"这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web-xml中Servelet配置的配置文件确实只有spring-mvc-xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：\"><a href=\"#这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web-xml中Servelet配置的配置文件确实只有spring-mvc-xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：\" class=\"headerlink\" title=\"这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web.xml中Servelet配置的配置文件确实只有spring-mvc.xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：  \"></a>这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web.xml中Servelet配置的配置文件确实只有spring-mvc.xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。<br>但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！<br>原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：<br> <img src=\"/images/scheduled_5_5.png\"> </h2><p> 问题既然分析清楚了，那么解决ScheduledAnnotationBeanPostProcessor的办法也很简单：  </p>\n<blockquote>\n</blockquote>\n<pre><code> 1. 将spring-task的配置放到spring-mvc.xml中 \n 2. 将web.xml配置的第二个上下文的配置文件补充完成，可用类似`classpath:spring-*.xml`\n</code></pre>\n<h2 id=\"4-2-版本差异\"><a href=\"#4-2-版本差异\" class=\"headerlink\" title=\"4.2 版本差异\"></a>4.2 版本差异</h2><p>由于Spring3版本的服务启动实在费时间，很多时候跟进源码都是直接通过新启动的Springboot服务来跟进的。 但是我却发现，Spring5中用@Scope(“prototype”)的Bean中的@Scheduled注解可以生效!!<br>对比了下ScheduledAnnotationBeanPostProcessor中的后置方法后，发现了Spring3仅仅只是加入到Register的List，而Spring5中却实实在在的将其加入到执行线程池了。<br><img src=\"/images/scheduled_5_2.png\"><br>因此，即使在Spring3中将ScheduledAnnotationBeanPostProcessor处理器加载到新的Spring上下文中，也是无法让原型Bean的定时任务执行。</p>\n","site":{"data":{}},"excerpt":"<p>在熟悉Spring中Bean启动流程后，知晓@Scheduled的原理不难。但是，这次debug并不简单…</p>","more":"<h1 id=\"一-Scheduled原理\"><a href=\"#一-Scheduled原理\" class=\"headerlink\" title=\"一 @Scheduled原理\"></a>一 @Scheduled原理</h1><h2 id=\"古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码\"><a href=\"#古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码\" class=\"headerlink\" title=\"古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码\"></a><em>古老项目启动很拉胯，速度太慢严重营销效率。直接建一个新项目分析源码</em></h2><p>直接点到<code>@EnableScheduling</code>注解里面看  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(SchedulingConfiguration.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableScheduling &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中引入了<code>SchedulingConfiguration</code>类，再进</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SchedulingConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ScheduledAnnotationBeanPostProcessor <span class=\"title\">scheduledAnnotationProcessor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>关键类及关键方法</strong> :  </p>\n<p> <code>ScheduledAnnotationBeanPostProcessor</code>，显然是一个<code>BeanPostProcessor</code>（bean后置处理器，重载方法: <code>postProcessAfterInitialization</code>）,同时它实现了<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>。在SpringContext完成后会有个<code>onApplicationEvent</code>回调动作。<br>大概看一下这两个方法<code>postProcessAfterInitialization</code>和<code>onApplicationEvent</code>。<br><code>postProcessAfterInitialization</code>方法，其实就是在每个Bean初始化阶段，对Bean中方法注解进行扫描，如果有@Scheduled注解，那么就把它封装成一个Runnable注册到一个Set<ScheduledTask>存起来。<br><img src=\"/images/spring5-scheduled%E6%B3%A8%E5%86%8C0.png\"><br>注册方法调用栈:<br><img src=\"/images/spring5-scheduled%E6%B3%A8%E5%86%8C.png\"><br>而<code>onApplicationEvent</code>方法恰恰就是从之前那个Set里面取下一次触发时间和执行方法体作为一个延迟任务丢到线程池中执行：<br><img src=\"/images/schedule%E6%89%A7%E8%A1%8C.png\"></ScheduledTask></p>\n<h1 id=\"二-Spring3中-Scheduled注解失效原因\"><a href=\"#二-Spring3中-Scheduled注解失效原因\" class=\"headerlink\" title=\"二 Spring3中@Scheduled注解失效原因\"></a>二 Spring3中@Scheduled注解失效原因</h1><h2 id=\"2-1-先跟进一下一个正常的单例Bean\"><a href=\"#2-1-先跟进一下一个正常的单例Bean\" class=\"headerlink\" title=\"2.1 先跟进一下一个正常的单例Bean\"></a>2.1 先跟进一下一个正常的单例Bean</h2><p>基本和Spring3.2是一致的, 大致是先注册，后执行： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注册：</span><br><span class=\"line\">doCreateBean-&gt; initializeBean -&gt; applyBeanPostProcessorsAfterInitialization</span><br><span class=\"line\">-&gt; ScheduledAnnotationBeanPostProcessor::postProcessAfterInitialization</span><br><span class=\"line\">-&gt; processScheduled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">执行：</span><br><span class=\"line\">ApplicationListener&lt;ContextRefreshedEvent&gt;:: onApplicationEvent </span><br><span class=\"line\">\t-&gt; ScheduledAnnotationBeanPostProcessor:: onApplicationEvent </span><br><span class=\"line\">\t-&gt; registrar.afterPropertiesSet()</span><br><span class=\"line\">\t-&gt; scheduleTasks</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Bean初始化的时候进入ScheduledAnnotationBeanPostProcessor<br><img src=\"/images/ScheduledAnnotationBeanPostProcessor-%E5%8D%95%E4%BE%8Bbean%E5%8F%AF%E4%BB%A5%E6%B3%A8%E5%85%A5.png\"></li>\n<li>通过Bean后置处理器中的processScheduled完成注册<br><img src=\"/images/Scheduled%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%B3%A8%E5%86%8C.png\"></li>\n</ol>\n<h2 id=\"2-2-Scope-“prototype”-的Bean\"><a href=\"#2-2-Scope-“prototype”-的Bean\" class=\"headerlink\" title=\"2.2 @Scope(“prototype”)的Bean\"></a>2.2 @Scope(“prototype”)的Bean</h2><p>从任务启动的位置肯定是看不出毛病的。 那么，跟一下用修饰为原型的Bean的注册流程<br><img src=\"/images/ScheduledAnnotationBeanPostProcessor-scope_prototype%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png\"><br>这里，Bean的后置初始化阶段，居然没有关键的<code>ScheduledAnnotationBeanPostProcessor</code>。那么肯定是无法像单例Bean一样把任务注册到内部Set的。</p>\n<h1 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h1><ol>\n<li>ScheduledAnnotationBeanPostProcessor是@Scheduled的核心类，注册任务和执行任务的方法都封装其中</li>\n<li>@Scope(“prototype”)的作用是每次需要Bean都会重新创建，而创建的时候是每次getBean()的时候！！！也就是说，如果这个Bean不会被用到，就根本不会被创建。即使在SpringContext启动后，这个Bean被BeanFactory创建，但是初始化的时候是没有关键的Bean后置处理器ScheduledAnnotationBeanPostProcessor的。这就是@Scheduled不生效的原因。</li>\n<li>@Scope(“prototype”)修饰的Bean<a href=\"https://springdoc.cn/spring-bean-scope-guides/\">不会纳入Bean的生命周期管理</a></li>\n</ol>\n<h1 id=\"四-暗藏玄机\"><a href=\"#四-暗藏玄机\" class=\"headerlink\" title=\"四 暗藏玄机\"></a>四 暗藏玄机</h1><p><em>虽然知道注解不生效的原因是ScheduledAnnotationBeanPostProcessor没有被BeanFactory加载，但是我仍不明白为啥在BeanFactory启动的时候，单例Bean可以获取到这个后置处理器，但启动后getBean的时候却没有了</em></p>\n<h2 id=\"4-1-SpringMVC多上下文\"><a href=\"#4-1-SpringMVC多上下文\" class=\"headerlink\" title=\"4.1 SpringMVC多上下文\"></a>4.1 SpringMVC多上下文</h2><p>由于需要跟进BeanPostProcessor的加载，我在AbstractApplicationContext中断点了<code>registerBeanPostProcessors</code>方法。<br>却发现它居然进去了两次!!!<br>原来是tomcat中SpringFrameworkServelet还会触发一次refresh，因此，实际上会产生两个Spring容器(上下文):<br><img src=\"/images/scheduled_5_1.png\"><br>实际debug跟进的时候发现，类型没变，但是BeanFactory的引用变了！！实际引用过程如下：  </p>\n<pre><code class=\"log\">1. BeanFactory加载对应BeanPostProcessor\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n2. BeanFactory初始化Bean\norg.springframework.beans.factory.support.DefaultListableBeanFactory@28ebddfd: defining beans \n\n3. FrameworkServlet触发initWebApplicationContext，再次refresh\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n4. 再次进入Bean初始化\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n\n5. FrameworkServlet中getBean()(@Scope(&quot;prototype&quot;)修饰的Bean)\norg.springframework.beans.factory.support.DefaultListableBeanFactory@427cfb6a: defining beans \n</code></pre>\n<p>在跟进为什么第二次refresh，获取不到关键Bean后置问题的时候，找到了加载关键Bean的位置：<br><img src=\"/images/scheduled_5_4.png\"><br>需要注意的是，关键Bean后置的名称并不是默认的类名首字母小写，而是(如果注意不到这点，很容易判断出错)：<br><code>org.springframework.context.annotation.internalScheduledAnnotationProcessor</code><br> <img src=\"/images/scheduled_5_3.png\">  </p>\n<h2 id=\"这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web-xml中Servelet配置的配置文件确实只有spring-mvc-xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：\"><a href=\"#这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web-xml中Servelet配置的配置文件确实只有spring-mvc-xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：\" class=\"headerlink\" title=\"这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web.xml中Servelet配置的配置文件确实只有spring-mvc.xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：  \"></a>这里发现：第二次refresh的时候，BeanDefinition中压根就没有关键Bean的信息。到了这里，回溯项目配置文件，spring-task确实是单独出1个xml文件，而web.xml中Servelet配置的配置文件确实只有spring-mvc.xml的。故而，第二次加载，就只有这个xml中配置的Bean的信息。这里捋一下：第一次refresh中有全部Bean的信息，第二次只有部分Bean的信息，故而第二次在Bean初始化的时候没有获取到ScheduledAnnotationBeanPostProcessor。<br>但是！！！我们项目一般会把ApplicationContext注入到一个自定义Bean，为了方便获取BeanFactory里面的Bean。既然二次refresh会导致第二次的ApplicationContext中的Bean信息只有部分，而为什么项目中寻找其他xml中的类没有报错呢？！！<br>原因：由于SpringMvc中多上下文的原因，Bean的加载设计为类似类的双亲加载模式。当前上下文没有的时候，会到父上下文中获取：<br> <img src=\"/images/scheduled_5_5.png\"> </h2><p> 问题既然分析清楚了，那么解决ScheduledAnnotationBeanPostProcessor的办法也很简单：  </p>\n<blockquote>\n</blockquote>\n<pre><code> 1. 将spring-task的配置放到spring-mvc.xml中 \n 2. 将web.xml配置的第二个上下文的配置文件补充完成，可用类似`classpath:spring-*.xml`\n</code></pre>\n<h2 id=\"4-2-版本差异\"><a href=\"#4-2-版本差异\" class=\"headerlink\" title=\"4.2 版本差异\"></a>4.2 版本差异</h2><p>由于Spring3版本的服务启动实在费时间，很多时候跟进源码都是直接通过新启动的Springboot服务来跟进的。 但是我却发现，Spring5中用@Scope(“prototype”)的Bean中的@Scheduled注解可以生效!!<br>对比了下ScheduledAnnotationBeanPostProcessor中的后置方法后，发现了Spring3仅仅只是加入到Register的List，而Spring5中却实实在在的将其加入到执行线程池了。<br><img src=\"/images/scheduled_5_2.png\"><br>因此，即使在Spring3中将ScheduledAnnotationBeanPostProcessor处理器加载到新的Spring上下文中，也是无法让原型Bean的定时任务执行。</p>"},{"title":"TiDB解决事务冲突","date":"2023-10-18T07:43:26.000Z","_content":"TiDB的事务提交是使用二阶段提交实现的。在客户端commit发起后，TiDB会从所有需要写入的Key中选取一个作为Primary Key，然后向所有涉及的TiKV发起prewrite。当发现有其他事务写当前Key，则发生写冲突。  \n<!--more-->\n\n# 一 故障描述\n``` log\nWrite conflict, txnStartTS=445014188662194445 ,conflictStartTS= 445014189016088693 ,conflictCommitTS= 445014189016088709, key={tablelD=5500,indexID=9,indexValues={1851371555435577344,151,}} primary={tablelD=1475,handle=6780523)[try again later]\n```\n# 二 故障分析\n\n## 日志释义\n``` log\nWrite conflict：表示出现了写写冲突\n\ntxnStartTS=445014188662194445 ：表示当前事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间\n\nconflictStartTS=445014189016088693 ：表示冲突事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间\n\nconflictCommitTS=445014189016088709 ：表示冲突事务的 commit_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间\n\nkey={tablelD=5500,indexID=9,indexValues={1851371555435577344,151,}}：表示当前事务中冲突的数据，tableID 表示发生冲突的表的 ID，indexID 表示是索引数据发生了冲突。如果是数据发生了冲突，会打印 handle=x 表示对应哪行数据发生了冲突，indexValues 表示发生冲突的索引数据\n\nprimary={tablelD=1475,handle=6780523)：表示当前事务中的 Primary Key 信息\n```\n\n# 三 故障解决\n\n## 获取冲突的信息\n> 由于没有`pd-ctl`工具，暂时略过时间戳信息  \n\n``` sql\nselect * from information_schema.tables where tidb_table_id in (5500,1475);\n\n# TABLE_NAME\n# erp_employee\n# simple_workflow_record\n\n```\n通过以上sql结果可以获知是`erp_employee`和`simple_workflow_record`表冲突了  \n``` sql\nselect * from information_schema.tidb_indexes WHERE table_name = (select TABLE_NAME from information_schema.tables where tidb_table_id =5500) and index_id = 9;\n\n```    \n\n|KEY_NAME|COLUMN_NAME|\n|--|--|\n|erp_employee_update_date_index|update_date|\n通过以上sql结果可以获知是字段`update_date`冲突了。\n\n``` log\nprimary={tableID=47, indexID=1, indexValues={string, }}\n```\n\n\n\n","source":"_posts/TiDB解决事务冲突.md","raw":"---\ntitle: TiDB解决事务冲突\ndate: 2023-10-18 15:43:26\ntags: Tidb\ncategories: 数据库\n---\nTiDB的事务提交是使用二阶段提交实现的。在客户端commit发起后，TiDB会从所有需要写入的Key中选取一个作为Primary Key，然后向所有涉及的TiKV发起prewrite。当发现有其他事务写当前Key，则发生写冲突。  \n<!--more-->\n\n# 一 故障描述\n``` log\nWrite conflict, txnStartTS=445014188662194445 ,conflictStartTS= 445014189016088693 ,conflictCommitTS= 445014189016088709, key={tablelD=5500,indexID=9,indexValues={1851371555435577344,151,}} primary={tablelD=1475,handle=6780523)[try again later]\n```\n# 二 故障分析\n\n## 日志释义\n``` log\nWrite conflict：表示出现了写写冲突\n\ntxnStartTS=445014188662194445 ：表示当前事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间\n\nconflictStartTS=445014189016088693 ：表示冲突事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间\n\nconflictCommitTS=445014189016088709 ：表示冲突事务的 commit_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间\n\nkey={tablelD=5500,indexID=9,indexValues={1851371555435577344,151,}}：表示当前事务中冲突的数据，tableID 表示发生冲突的表的 ID，indexID 表示是索引数据发生了冲突。如果是数据发生了冲突，会打印 handle=x 表示对应哪行数据发生了冲突，indexValues 表示发生冲突的索引数据\n\nprimary={tablelD=1475,handle=6780523)：表示当前事务中的 Primary Key 信息\n```\n\n# 三 故障解决\n\n## 获取冲突的信息\n> 由于没有`pd-ctl`工具，暂时略过时间戳信息  \n\n``` sql\nselect * from information_schema.tables where tidb_table_id in (5500,1475);\n\n# TABLE_NAME\n# erp_employee\n# simple_workflow_record\n\n```\n通过以上sql结果可以获知是`erp_employee`和`simple_workflow_record`表冲突了  \n``` sql\nselect * from information_schema.tidb_indexes WHERE table_name = (select TABLE_NAME from information_schema.tables where tidb_table_id =5500) and index_id = 9;\n\n```    \n\n|KEY_NAME|COLUMN_NAME|\n|--|--|\n|erp_employee_update_date_index|update_date|\n通过以上sql结果可以获知是字段`update_date`冲突了。\n\n``` log\nprimary={tableID=47, indexID=1, indexValues={string, }}\n```\n\n\n\n","slug":"TiDB解决事务冲突","published":1,"updated":"2024-02-18T08:32:21.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz0001iqwvdbyr64na1","content":"<p>TiDB的事务提交是使用二阶段提交实现的。在客户端commit发起后，TiDB会从所有需要写入的Key中选取一个作为Primary Key，然后向所有涉及的TiKV发起prewrite。当发现有其他事务写当前Key，则发生写冲突。  </p>\n<span id=\"more\"></span>\n\n<h1 id=\"一-故障描述\"><a href=\"#一-故障描述\" class=\"headerlink\" title=\"一 故障描述\"></a>一 故障描述</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Write conflict, txnStartTS=445014188662194445 ,conflictStartTS= 445014189016088693 ,conflictCommitTS= 445014189016088709, key=&#123;tablelD=5500,indexID=9,indexValues=&#123;1851371555435577344,151,&#125;&#125; primary=&#123;tablelD=1475,handle=6780523)[try again later]</span><br></pre></td></tr></table></figure>\n<h1 id=\"二-故障分析\"><a href=\"#二-故障分析\" class=\"headerlink\" title=\"二 故障分析\"></a>二 故障分析</h1><h2 id=\"日志释义\"><a href=\"#日志释义\" class=\"headerlink\" title=\"日志释义\"></a>日志释义</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Write conflict：表示出现了写写冲突</span><br><span class=\"line\"></span><br><span class=\"line\">txnStartTS=445014188662194445 ：表示当前事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间</span><br><span class=\"line\"></span><br><span class=\"line\">conflictStartTS=445014189016088693 ：表示冲突事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间</span><br><span class=\"line\"></span><br><span class=\"line\">conflictCommitTS=445014189016088709 ：表示冲突事务的 commit_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间</span><br><span class=\"line\"></span><br><span class=\"line\">key=&#123;tablelD=5500,indexID=9,indexValues=&#123;1851371555435577344,151,&#125;&#125;：表示当前事务中冲突的数据，tableID 表示发生冲突的表的 ID，indexID 表示是索引数据发生了冲突。如果是数据发生了冲突，会打印 handle=x 表示对应哪行数据发生了冲突，indexValues 表示发生冲突的索引数据</span><br><span class=\"line\"></span><br><span class=\"line\">primary=&#123;tablelD=1475,handle=6780523)：表示当前事务中的 Primary Key 信息</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三-故障解决\"><a href=\"#三-故障解决\" class=\"headerlink\" title=\"三 故障解决\"></a>三 故障解决</h1><h2 id=\"获取冲突的信息\"><a href=\"#获取冲突的信息\" class=\"headerlink\" title=\"获取冲突的信息\"></a>获取冲突的信息</h2><blockquote>\n<p>由于没有<code>pd-ctl</code>工具，暂时略过时间戳信息  </p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> information_schema.tables <span class=\"keyword\">where</span> tidb_table_id <span class=\"keyword\">in</span> (<span class=\"number\">5500</span>,<span class=\"number\">1475</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"># TABLE_NAME</span><br><span class=\"line\"># erp_employee</span><br><span class=\"line\"># simple_workflow_record</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过以上sql结果可以获知是<code>erp_employee</code>和<code>simple_workflow_record</code>表冲突了  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> information_schema.tidb_indexes <span class=\"keyword\">WHERE</span> table_name <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> TABLE_NAME <span class=\"keyword\">from</span> information_schema.tables <span class=\"keyword\">where</span> tidb_table_id <span class=\"operator\">=</span><span class=\"number\">5500</span>) <span class=\"keyword\">and</span> index_id <span class=\"operator\">=</span> <span class=\"number\">9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">```    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">|</span>KEY_NAME<span class=\"operator\">|</span>COLUMN_NAME<span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span><span class=\"comment\">--|--|</span></span><br><span class=\"line\"><span class=\"operator\">|</span>erp_employee_update_date_index<span class=\"operator\">|</span>update_date<span class=\"operator\">|</span></span><br><span class=\"line\">通过以上<span class=\"keyword\">sql</span>结果可以获知是字段`update_date`冲突了。</span><br><span class=\"line\"></span><br><span class=\"line\">``` log</span><br><span class=\"line\"><span class=\"keyword\">primary</span><span class=\"operator\">=</span>&#123;tableID<span class=\"operator\">=</span><span class=\"number\">47</span>, indexID<span class=\"operator\">=</span><span class=\"number\">1</span>, indexValues<span class=\"operator\">=</span>&#123;string, &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>TiDB的事务提交是使用二阶段提交实现的。在客户端commit发起后，TiDB会从所有需要写入的Key中选取一个作为Primary Key，然后向所有涉及的TiKV发起prewrite。当发现有其他事务写当前Key，则发生写冲突。  </p>","more":"<h1 id=\"一-故障描述\"><a href=\"#一-故障描述\" class=\"headerlink\" title=\"一 故障描述\"></a>一 故障描述</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Write conflict, txnStartTS=445014188662194445 ,conflictStartTS= 445014189016088693 ,conflictCommitTS= 445014189016088709, key=&#123;tablelD=5500,indexID=9,indexValues=&#123;1851371555435577344,151,&#125;&#125; primary=&#123;tablelD=1475,handle=6780523)[try again later]</span><br></pre></td></tr></table></figure>\n<h1 id=\"二-故障分析\"><a href=\"#二-故障分析\" class=\"headerlink\" title=\"二 故障分析\"></a>二 故障分析</h1><h2 id=\"日志释义\"><a href=\"#日志释义\" class=\"headerlink\" title=\"日志释义\"></a>日志释义</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Write conflict：表示出现了写写冲突</span><br><span class=\"line\"></span><br><span class=\"line\">txnStartTS=445014188662194445 ：表示当前事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间</span><br><span class=\"line\"></span><br><span class=\"line\">conflictStartTS=445014189016088693 ：表示冲突事务的 start_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间</span><br><span class=\"line\"></span><br><span class=\"line\">conflictCommitTS=445014189016088709 ：表示冲突事务的 commit_ts 时间戳，可以通过 pd-ctl 工具将时间戳转换为具体时间</span><br><span class=\"line\"></span><br><span class=\"line\">key=&#123;tablelD=5500,indexID=9,indexValues=&#123;1851371555435577344,151,&#125;&#125;：表示当前事务中冲突的数据，tableID 表示发生冲突的表的 ID，indexID 表示是索引数据发生了冲突。如果是数据发生了冲突，会打印 handle=x 表示对应哪行数据发生了冲突，indexValues 表示发生冲突的索引数据</span><br><span class=\"line\"></span><br><span class=\"line\">primary=&#123;tablelD=1475,handle=6780523)：表示当前事务中的 Primary Key 信息</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三-故障解决\"><a href=\"#三-故障解决\" class=\"headerlink\" title=\"三 故障解决\"></a>三 故障解决</h1><h2 id=\"获取冲突的信息\"><a href=\"#获取冲突的信息\" class=\"headerlink\" title=\"获取冲突的信息\"></a>获取冲突的信息</h2><blockquote>\n<p>由于没有<code>pd-ctl</code>工具，暂时略过时间戳信息  </p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> information_schema.tables <span class=\"keyword\">where</span> tidb_table_id <span class=\"keyword\">in</span> (<span class=\"number\">5500</span>,<span class=\"number\">1475</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"># TABLE_NAME</span><br><span class=\"line\"># erp_employee</span><br><span class=\"line\"># simple_workflow_record</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过以上sql结果可以获知是<code>erp_employee</code>和<code>simple_workflow_record</code>表冲突了  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> information_schema.tidb_indexes <span class=\"keyword\">WHERE</span> table_name <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> TABLE_NAME <span class=\"keyword\">from</span> information_schema.tables <span class=\"keyword\">where</span> tidb_table_id <span class=\"operator\">=</span><span class=\"number\">5500</span>) <span class=\"keyword\">and</span> index_id <span class=\"operator\">=</span> <span class=\"number\">9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">```    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">|</span>KEY_NAME<span class=\"operator\">|</span>COLUMN_NAME<span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span><span class=\"comment\">--|--|</span></span><br><span class=\"line\"><span class=\"operator\">|</span>erp_employee_update_date_index<span class=\"operator\">|</span>update_date<span class=\"operator\">|</span></span><br><span class=\"line\">通过以上<span class=\"keyword\">sql</span>结果可以获知是字段`update_date`冲突了。</span><br><span class=\"line\"></span><br><span class=\"line\">``` log</span><br><span class=\"line\"><span class=\"keyword\">primary</span><span class=\"operator\">=</span>&#123;tableID<span class=\"operator\">=</span><span class=\"number\">47</span>, indexID<span class=\"operator\">=</span><span class=\"number\">1</span>, indexValues<span class=\"operator\">=</span>&#123;string, &#125;&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Spring-AspectJ织入","date":"2023-04-06T06:05:35.000Z","_content":"最开始用Spring切面的时候听说是基于AspectJ的，便认为SpringAop是依赖AspectJ实现的。其实不然，SpringAop其实不依赖AspectJ，它本身的AOP功能是基于SpringBean管理的，通过动态代理(JDK或CgLib)实现的。然而，这却不是一个完整的AOP解决方案，所以需要引入AspectJ。\n<!--more-->  \n# 一 AOP相关概念  \n- Aspect\t切面\n- Pointcut 切点，织入Advice的触发条件，也称为Joinpoint\n- Advice 增强，切面中切点处的具体行为\n    - Around\t环绕增强，目标方法执行前后分别执行一些代码\n    - AfterReturning\t返回增强，目标方法正常执行完毕时执行\n    - Before\t前置增强，目标方法执行之前执行\n    - AfterThrowing\t异常抛出增强，目标方法发生异常的时候执行\n    - After\t后置增强，不管是抛出异常或者正常退出都会执行  \n- Weaving 织入，在切点处执行增强的过程\n\n# 二 织入时期  \n- Compile-time weaving  \n    > 编译期织入，编译的时候织入代码，运行时直接运行 \n- Post-compile weaving\n    > 编译期后织入，编译后二进制织入，一般此时织入的是已存在的class或者jar\n- Load-time weaving\n    > 加载期织入，也是二进制织入，但此时是加载到JVM之前  \n\n# 三 SpringAOP和AspectJ差异\n通过以上所述，SpringAop是通过动态代理在运行时织入，而AspectJ是通过字节码技术在编译期（或加载期）织入。用代码抽象表述了下，方便理解：  \n``` java\nclass A{\n\tmethodA{\n\t// do some thing\n\t}\n}\n\nclass AProxy-SpringAop{\n\n\tdoMethodA {\n\t\t// advice before\n\t\tmethodA();\n\t\t// advice after\n\t}\n\n\tmethodA{\n\t// do some thing\n\t}\n}\n\nclass AProxy-AspectJ{\n\tmethodA{\n\t// advice before\n\t// do some thing\n\t// advice after\n\t}\n}\n```\n更多关于两者差异和关联可参考：  \nhttps://www.baeldung.com/spring-aop-vs-aspectj  \n\nhttps://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html  \n\n# 四 解决SpringAOP方法内调用失效  \n用SpringAop不论是完成异步调用、事务、缓存操作，都不能避免内部方法调用失效的尴尬。可以参考的解决方案有：  \n- AopContext.currentProxy() 获取当前代理对象再调用目标方法  \n- @Autowired self； 通过注入自身来调用  \n- 把方法2拆分到新的Bean中，避免类方法调用  \n\n# 五 加载时织入(LTW)  \n\n大致方法是将aspectjweaver.jar作为agent传入JVM，在加载时织入相应Advice。下面以SpringCache中使用AspectJ为例（事务和异步都是一样的操作）:  \n1. 新增依赖  \n``` xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-aop</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aspects</artifactId>\n    </dependency>\n``` \n\n2. 修改代理模式  \n``` java\n@EnableCaching(mode = AdviceMode.ASPECTJ)\n``` \n\n3. 传入agent  \n``` bat\n# 启动参数新增agent\n-javaagent:D:\\Tools\\aspectjweaver-1.9.19.jar\n```\n\n更多关于Spring中使用LTW的可以参考：  \nhttps://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw\n\n\n \n","source":"_posts/Spring-AspectJ织入.md","raw":"---\ntitle: Spring-AspectJ织入\ndate: 2023-04-06 14:05:35\ntags:\n- spring-aop\n- AspectJ\ncategories: Spring+\n---\n最开始用Spring切面的时候听说是基于AspectJ的，便认为SpringAop是依赖AspectJ实现的。其实不然，SpringAop其实不依赖AspectJ，它本身的AOP功能是基于SpringBean管理的，通过动态代理(JDK或CgLib)实现的。然而，这却不是一个完整的AOP解决方案，所以需要引入AspectJ。\n<!--more-->  \n# 一 AOP相关概念  \n- Aspect\t切面\n- Pointcut 切点，织入Advice的触发条件，也称为Joinpoint\n- Advice 增强，切面中切点处的具体行为\n    - Around\t环绕增强，目标方法执行前后分别执行一些代码\n    - AfterReturning\t返回增强，目标方法正常执行完毕时执行\n    - Before\t前置增强，目标方法执行之前执行\n    - AfterThrowing\t异常抛出增强，目标方法发生异常的时候执行\n    - After\t后置增强，不管是抛出异常或者正常退出都会执行  \n- Weaving 织入，在切点处执行增强的过程\n\n# 二 织入时期  \n- Compile-time weaving  \n    > 编译期织入，编译的时候织入代码，运行时直接运行 \n- Post-compile weaving\n    > 编译期后织入，编译后二进制织入，一般此时织入的是已存在的class或者jar\n- Load-time weaving\n    > 加载期织入，也是二进制织入，但此时是加载到JVM之前  \n\n# 三 SpringAOP和AspectJ差异\n通过以上所述，SpringAop是通过动态代理在运行时织入，而AspectJ是通过字节码技术在编译期（或加载期）织入。用代码抽象表述了下，方便理解：  \n``` java\nclass A{\n\tmethodA{\n\t// do some thing\n\t}\n}\n\nclass AProxy-SpringAop{\n\n\tdoMethodA {\n\t\t// advice before\n\t\tmethodA();\n\t\t// advice after\n\t}\n\n\tmethodA{\n\t// do some thing\n\t}\n}\n\nclass AProxy-AspectJ{\n\tmethodA{\n\t// advice before\n\t// do some thing\n\t// advice after\n\t}\n}\n```\n更多关于两者差异和关联可参考：  \nhttps://www.baeldung.com/spring-aop-vs-aspectj  \n\nhttps://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html  \n\n# 四 解决SpringAOP方法内调用失效  \n用SpringAop不论是完成异步调用、事务、缓存操作，都不能避免内部方法调用失效的尴尬。可以参考的解决方案有：  \n- AopContext.currentProxy() 获取当前代理对象再调用目标方法  \n- @Autowired self； 通过注入自身来调用  \n- 把方法2拆分到新的Bean中，避免类方法调用  \n\n# 五 加载时织入(LTW)  \n\n大致方法是将aspectjweaver.jar作为agent传入JVM，在加载时织入相应Advice。下面以SpringCache中使用AspectJ为例（事务和异步都是一样的操作）:  \n1. 新增依赖  \n``` xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-aop</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aspects</artifactId>\n    </dependency>\n``` \n\n2. 修改代理模式  \n``` java\n@EnableCaching(mode = AdviceMode.ASPECTJ)\n``` \n\n3. 传入agent  \n``` bat\n# 启动参数新增agent\n-javaagent:D:\\Tools\\aspectjweaver-1.9.19.jar\n```\n\n更多关于Spring中使用LTW的可以参考：  \nhttps://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw\n\n\n \n","slug":"Spring-AspectJ织入","published":1,"updated":"2024-02-18T08:30:47.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz1001lqwvd01wq6ner","content":"<p>最开始用Spring切面的时候听说是基于AspectJ的，便认为SpringAop是依赖AspectJ实现的。其实不然，SpringAop其实不依赖AspectJ，它本身的AOP功能是基于SpringBean管理的，通过动态代理(JDK或CgLib)实现的。然而，这却不是一个完整的AOP解决方案，所以需要引入AspectJ。</p>\n<span id=\"more\"></span>  \n<h1 id=\"一-AOP相关概念\"><a href=\"#一-AOP相关概念\" class=\"headerlink\" title=\"一 AOP相关概念\"></a>一 AOP相关概念</h1><ul>\n<li>Aspect\t切面</li>\n<li>Pointcut 切点，织入Advice的触发条件，也称为Joinpoint</li>\n<li>Advice 增强，切面中切点处的具体行为<ul>\n<li>Around\t环绕增强，目标方法执行前后分别执行一些代码</li>\n<li>AfterReturning\t返回增强，目标方法正常执行完毕时执行</li>\n<li>Before\t前置增强，目标方法执行之前执行</li>\n<li>AfterThrowing\t异常抛出增强，目标方法发生异常的时候执行</li>\n<li>After\t后置增强，不管是抛出异常或者正常退出都会执行</li>\n</ul>\n</li>\n<li>Weaving 织入，在切点处执行增强的过程</li>\n</ul>\n<h1 id=\"二-织入时期\"><a href=\"#二-织入时期\" class=\"headerlink\" title=\"二 织入时期\"></a>二 织入时期</h1><ul>\n<li>Compile-time weaving  <blockquote>\n<p>编译期织入，编译的时候织入代码，运行时直接运行 </p>\n</blockquote>\n</li>\n<li>Post-compile weaving<blockquote>\n<p>编译期后织入，编译后二进制织入，一般此时织入的是已存在的class或者jar</p>\n</blockquote>\n</li>\n<li>Load-time weaving<blockquote>\n<p>加载期织入，也是二进制织入，但此时是加载到JVM之前</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"三-SpringAOP和AspectJ差异\"><a href=\"#三-SpringAOP和AspectJ差异\" class=\"headerlink\" title=\"三 SpringAOP和AspectJ差异\"></a>三 SpringAOP和AspectJ差异</h1><p>通过以上所述，SpringAop是通过动态代理在运行时织入，而AspectJ是通过字节码技术在编译期（或加载期）织入。用代码抽象表述了下，方便理解：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">\tmethodA&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do some thing</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AProxy</span>-<span class=\"title\">SpringAop</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdoMethodA &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// advice before</span></span><br><span class=\"line\">\t\tmethodA();</span><br><span class=\"line\">\t\t<span class=\"comment\">// advice after</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmethodA&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do some thing</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AProxy</span>-<span class=\"title\">AspectJ</span></span>&#123;</span><br><span class=\"line\">\tmethodA&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// advice before</span></span><br><span class=\"line\">\t<span class=\"comment\">// do some thing</span></span><br><span class=\"line\">\t<span class=\"comment\">// advice after</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多关于两者差异和关联可参考：<br><a href=\"https://www.baeldung.com/spring-aop-vs-aspectj\">https://www.baeldung.com/spring-aop-vs-aspectj</a>  </p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html\">https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html</a>  </p>\n<h1 id=\"四-解决SpringAOP方法内调用失效\"><a href=\"#四-解决SpringAOP方法内调用失效\" class=\"headerlink\" title=\"四 解决SpringAOP方法内调用失效\"></a>四 解决SpringAOP方法内调用失效</h1><p>用SpringAop不论是完成异步调用、事务、缓存操作，都不能避免内部方法调用失效的尴尬。可以参考的解决方案有：  </p>\n<ul>\n<li>AopContext.currentProxy() 获取当前代理对象再调用目标方法  </li>\n<li>@Autowired self； 通过注入自身来调用  </li>\n<li>把方法2拆分到新的Bean中，避免类方法调用</li>\n</ul>\n<h1 id=\"五-加载时织入-LTW\"><a href=\"#五-加载时织入-LTW\" class=\"headerlink\" title=\"五 加载时织入(LTW)\"></a>五 加载时织入(LTW)</h1><p>大致方法是将aspectjweaver.jar作为agent传入JVM，在加载时织入相应Advice。下面以SpringCache中使用AspectJ为例（事务和异步都是一样的操作）:  </p>\n<ol>\n<li><p>新增依赖  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aspects<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改代理模式  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableCaching(mode = AdviceMode.ASPECTJ)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入agent  </p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 启动参数新增agent</span><br><span class=\"line\">-javaagent:D:\\Tools\\aspectjweaver-<span class=\"number\">1</span>.<span class=\"number\">9</span>.<span class=\"number\">19</span>.jar</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>更多关于Spring中使用LTW的可以参考：<br><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw\">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw</a></p>\n","site":{"data":{}},"excerpt":"<p>最开始用Spring切面的时候听说是基于AspectJ的，便认为SpringAop是依赖AspectJ实现的。其实不然，SpringAop其实不依赖AspectJ，它本身的AOP功能是基于SpringBean管理的，通过动态代理(JDK或CgLib)实现的。然而，这却不是一个完整的AOP解决方案，所以需要引入AspectJ。</p>","more":"<h1 id=\"一-AOP相关概念\"><a href=\"#一-AOP相关概念\" class=\"headerlink\" title=\"一 AOP相关概念\"></a>一 AOP相关概念</h1><ul>\n<li>Aspect\t切面</li>\n<li>Pointcut 切点，织入Advice的触发条件，也称为Joinpoint</li>\n<li>Advice 增强，切面中切点处的具体行为<ul>\n<li>Around\t环绕增强，目标方法执行前后分别执行一些代码</li>\n<li>AfterReturning\t返回增强，目标方法正常执行完毕时执行</li>\n<li>Before\t前置增强，目标方法执行之前执行</li>\n<li>AfterThrowing\t异常抛出增强，目标方法发生异常的时候执行</li>\n<li>After\t后置增强，不管是抛出异常或者正常退出都会执行</li>\n</ul>\n</li>\n<li>Weaving 织入，在切点处执行增强的过程</li>\n</ul>\n<h1 id=\"二-织入时期\"><a href=\"#二-织入时期\" class=\"headerlink\" title=\"二 织入时期\"></a>二 织入时期</h1><ul>\n<li>Compile-time weaving  <blockquote>\n<p>编译期织入，编译的时候织入代码，运行时直接运行 </p>\n</blockquote>\n</li>\n<li>Post-compile weaving<blockquote>\n<p>编译期后织入，编译后二进制织入，一般此时织入的是已存在的class或者jar</p>\n</blockquote>\n</li>\n<li>Load-time weaving<blockquote>\n<p>加载期织入，也是二进制织入，但此时是加载到JVM之前</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"三-SpringAOP和AspectJ差异\"><a href=\"#三-SpringAOP和AspectJ差异\" class=\"headerlink\" title=\"三 SpringAOP和AspectJ差异\"></a>三 SpringAOP和AspectJ差异</h1><p>通过以上所述，SpringAop是通过动态代理在运行时织入，而AspectJ是通过字节码技术在编译期（或加载期）织入。用代码抽象表述了下，方便理解：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">\tmethodA&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do some thing</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AProxy</span>-<span class=\"title\">SpringAop</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdoMethodA &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// advice before</span></span><br><span class=\"line\">\t\tmethodA();</span><br><span class=\"line\">\t\t<span class=\"comment\">// advice after</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmethodA&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do some thing</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AProxy</span>-<span class=\"title\">AspectJ</span></span>&#123;</span><br><span class=\"line\">\tmethodA&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// advice before</span></span><br><span class=\"line\">\t<span class=\"comment\">// do some thing</span></span><br><span class=\"line\">\t<span class=\"comment\">// advice after</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多关于两者差异和关联可参考：<br><a href=\"https://www.baeldung.com/spring-aop-vs-aspectj\">https://www.baeldung.com/spring-aop-vs-aspectj</a>  </p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html\">https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html</a>  </p>\n<h1 id=\"四-解决SpringAOP方法内调用失效\"><a href=\"#四-解决SpringAOP方法内调用失效\" class=\"headerlink\" title=\"四 解决SpringAOP方法内调用失效\"></a>四 解决SpringAOP方法内调用失效</h1><p>用SpringAop不论是完成异步调用、事务、缓存操作，都不能避免内部方法调用失效的尴尬。可以参考的解决方案有：  </p>\n<ul>\n<li>AopContext.currentProxy() 获取当前代理对象再调用目标方法  </li>\n<li>@Autowired self； 通过注入自身来调用  </li>\n<li>把方法2拆分到新的Bean中，避免类方法调用</li>\n</ul>\n<h1 id=\"五-加载时织入-LTW\"><a href=\"#五-加载时织入-LTW\" class=\"headerlink\" title=\"五 加载时织入(LTW)\"></a>五 加载时织入(LTW)</h1><p>大致方法是将aspectjweaver.jar作为agent传入JVM，在加载时织入相应Advice。下面以SpringCache中使用AspectJ为例（事务和异步都是一样的操作）:  </p>\n<ol>\n<li><p>新增依赖  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aspects<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改代理模式  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableCaching(mode = AdviceMode.ASPECTJ)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入agent  </p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 启动参数新增agent</span><br><span class=\"line\">-javaagent:D:\\Tools\\aspectjweaver-<span class=\"number\">1</span>.<span class=\"number\">9</span>.<span class=\"number\">19</span>.jar</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>更多关于Spring中使用LTW的可以参考：<br><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw\">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw</a></p>"},{"title":"arthas简述","date":"2023-07-07T09:28:08.000Z","_content":"arthas作为一款监控诊断的工具，能实时查看JVM信息，可以对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时等。实乃线上跟踪定位工具的不二之选!\n<!--more-->\n## 1. 查看类及子类信息（包含私有变量）\n``` bash\nsc -d -f com.mxzhang.erp.config.ErpConfig\n```\n![](/images/arthas1.png)\n\n## 2. 调用方法，使用tomcat时使用OGNL需要制定类加载器\n``` bash\nognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader '@com.mxzhang.erp.config.ErpConfig@isRunningBatchTaskEnv()'\n```\n\n### 简单参数\n``` bash\nognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader '@com.mxzhang.erp.config.ErpConfig@getProperty(\"isHK\")' -x 1\n\nognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader '@com.mxzhang.erp.config.ErpConfig@isApiTestDesk(4)' -x 2\n```\n![](/images/arthas2.png)\n\n## 3.调用构造方法执行非静态方法\nNew这个对象，再执行方法即可  \n\n## 4. 调用任意Bean\n基本步骤：  \n    1.找到classLoaderHash  \n    2. ognl通过类加载器调用方法  \n\n``` bash\n[arthas@22714]$ sc -d ApplicationContextUtil\nAffect(row-cnt:0) cost in 16 ms.\n[arthas@22714]$ sc -d *ApplicationContextUtil\n class-info        org.jeecgframework.core.util.ApplicationContextUtil\n code-source       /ayplot/erptomcat8.5/webapps/erp/WEB-INF/classes/\n name              org.jeecgframework.core.util.ApplicationContextUtil\n isInterface       false\n isAnnotation      false\n isEnum            false\n isAnonymousClass  false\n isArray           false\n isLocalClass      false\n isMemberClass     false\n isPrimitive       false\n isSynthetic       false\n simple-name       ApplicationContextUtil\n modifier          public\n annotation\n interfaces        org.springframework.context.ApplicationContextAware\n super-class       +-java.lang.Object\n class-loader      +-ParallelWebappClassLoader\n                       context: erp\n                       delegate: false\n                     ----------> Parent Classloader:\n                     java.net.URLClassLoader@3ac3fd8b\n\n                     +-java.net.URLClassLoader@3ac3fd8b\n                       +-sun.misc.Launcher$AppClassLoader@18b4aac2\n                         +-sun.misc.Launcher$ExtClassLoader@7b7c0aa8\n classLoaderHash   3b165738\n\nAffect(row-cnt:1) cost in 86 ms.\n[arthas@22714]$ ognl -c 3b165738 '@org.jeecgframework.core.util.ApplicationContextUtil@getContext().getBean(\"health\").access()'\n@String[OK]\n```\n\n## 5. 记录每次方法的调用\n``` bash\n//tt -t com.mxzhang.erp.api.actuator.Health  access\n\n[arthas@22714]$ tt -t  com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 503 ms, listenerId: 6\n INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n 1003        2020-12-04 12:44:39            1349.904497     true        false        0x64a3f100             ErpEmployeeController                         datagrid\n 1004        2020-12-04 12:44:46            1526.542767     true        false        0xef690d8              ErpEmployeeController                         datagrid\n 1005        2020-12-04 12:45:09            1268.608223     true        false        0x294385ad             ErpEmployeeController                         datagrid\n\n```\n\n### 查看入参出参详情\n``` bash\n[arthas@22714]$ tt -i 1003\n INDEX          1003\n GMT-CREATE     2020-12-04 12:44:39\n COST(ms)       1349.904497\n OBJECT         0x64a3f100\n CLASS          com.mxzhang.erp.employee.controller.ErpEmployeeController\n METHOD         datagrid\n IS-RETURN      true\n IS-EXCEPTION   false\n PARAMETERS[0]  @ErpEmployeeEntity[\n```\n> 此处参数被封装成引用对象，无法查看\n\n### 重新发起请求\n``` bash\n[arthas@22714]$ tt -t com.mxzhang.erp.api.actuator.Health  access\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 320 ms, listenerId: 7\n INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n 1006        2020-12-04 13:50:49            0.09137         true        false        0x7417c9e4             Health                                        access\n[arthas@22714]$ tt -i 1006 -p\n RE-INDEX      1006\n GMT-REPLAY    2020-12-04 13:51:14\n OBJECT        0x7417c9e4\n CLASS         com.mxzhang.erp.api.actuator.Health\n METHOD        access\n IS-RETURN     true\n IS-EXCEPTION  false\n COST(ms)      0.143933\n RETURN-OBJ    @String[OK]\nTime fragment[1006] successfully replayed 1 times.\n\n```\n> ThreadLocal 信息丢失和引用对象变更会导致无法准确获取，此时需要用到watch  \n\n## 观察每次方法调用\n``` bash\nwatch\nwatch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid '{params,target,returnObj}' -x 3\n\n// 观察具体参数\nwatch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid  'target'\n```\n\n## 7. 追踪方法调用栈\n``` bash\n[arthas@22714]$ trace com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid '#cost > 10'\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 542 ms, listenerId: 15\n`---ts=2020-12-04 15:00:42;thread_name=http-nio-8181-exec-21;id=c0;is_daemon=true;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@3b165738\n    `---[1208.379063ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:datagrid()\n        +---[5.28227ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:createDatagridCriteriaQuery() #675\n        +---[0.021024ms] javax.servlet.http.HttpServletRequest:getParameter() #676\n        +---[0.016183ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() #677\n        +---[0.016176ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() #680\n        +---[0.025832ms] org.hibernate.criterion.Restrictions:disjunction() #681\n        +---[0.015999ms] javax.servlet.http.HttpServletRequest:getParameter() #683\n        +---[0.016274ms] javax.servlet.http.HttpServletRequest:getParameter() #684\n        +---[0.015918ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() #685\n        +---[0.019184ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() #690\n        +---[0.031676ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() #693\n        +---[44.915965ms] com.mxzhang.erp.employee.service.ErpEmployeeServiceI:getDataGridReturn() #694\n        +---[0.031499ms] org.jeecgframework.core.common.model.json.DataGrid:getResults() #695\n        +---[34.233436ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:postProcessEmployeeList() #696\n        `---[1122.992269ms] org.jeecgframework.tag.core.easyui.TagUtil:datagrid() #697\n```\n\n**这个功能在调优的时候非常实用，可以看到每行代码的耗时。这种功能一般只有GW的付费软件才有**  \n\n### 次数限制\n``` bash\ntrace demo.MathGame run -n 1\n```\n这种功能对并发高的函数很有用\n\n### 调用耗时过滤\n``` bash\n$ trace demo.MathGame run '#cost > 10'\n```\n\n### trace多层\ntrace只能1层，因为多层扩展的代价很大。但是trace提供了多个类，可以使用此功能达到类似效果\n``` bash\ntrace -E com.test.ClassA|org.test.ClassB method1|method2|method3\n```\n\n### 排除指定类\n``` bash\ntrace javax.servlet.Filter * --exclude-class-pattern com.demo.TestFilter\n```\n\n\n## 8. 代码热更新\n``` bash\n[arthas@22714]$ redefine /home/deployer/Health.class\nredefine success, size: 1, classes:\ncom.mxzhang.erp.api.actuator.Health\n```\n也可以结合jad和mc命令在服务器上完成操作  \n1. jad反编译\n``` bash\njad --source-only com.mxzhang.erp.api.actuator.Health > /app/Health.java\n```\n2. 修改代码\n3. 生成class\n``` bash\n[arthas@22714]$ sc -d *Health | grep classLoaderHash\n classLoaderHash   3b165738\n[arthas@22714]$ mc -c 3b165738 /app/Health.java\nMemory compiler error, exception message: java.lang.RuntimeException: Wasn't able to open jar:file:/ayplot/erptomcat8.5/webapps/erp/WEB-INF/lib/commons-lang-2.6.jar!/ as a jar file, please check $HOME/logs/arthas/arthas.log for more details.\n// 这里我一直是失败的，不知为何，官网也提示mc经常失败\n```\n4. 热加载\n``` bash\nredefine /home/deployer/Health.class\n```\n\n> **redefine的限制**\n- 不允许新增加field/method\n- 正在跑的函数，没有退出不能生效\n\n**jrebel还是比arthas提供的热更新还是强大很多，但也要注意一点：以后热更新的时候要避免使用功能，防止更新失败**  \n\n> 更复杂姿势参考[ognl表达式](https://commons.apache.org/proper/commons-ognl/language-guide.html)  \n\n","source":"_posts/arthas简述.md","raw":"---\ntitle: arthas简述\ndate: 2023-07-07 17:28:08\ntags:\n- arthas\ncategories: troubleshooting\n---\narthas作为一款监控诊断的工具，能实时查看JVM信息，可以对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时等。实乃线上跟踪定位工具的不二之选!\n<!--more-->\n## 1. 查看类及子类信息（包含私有变量）\n``` bash\nsc -d -f com.mxzhang.erp.config.ErpConfig\n```\n![](/images/arthas1.png)\n\n## 2. 调用方法，使用tomcat时使用OGNL需要制定类加载器\n``` bash\nognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader '@com.mxzhang.erp.config.ErpConfig@isRunningBatchTaskEnv()'\n```\n\n### 简单参数\n``` bash\nognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader '@com.mxzhang.erp.config.ErpConfig@getProperty(\"isHK\")' -x 1\n\nognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader '@com.mxzhang.erp.config.ErpConfig@isApiTestDesk(4)' -x 2\n```\n![](/images/arthas2.png)\n\n## 3.调用构造方法执行非静态方法\nNew这个对象，再执行方法即可  \n\n## 4. 调用任意Bean\n基本步骤：  \n    1.找到classLoaderHash  \n    2. ognl通过类加载器调用方法  \n\n``` bash\n[arthas@22714]$ sc -d ApplicationContextUtil\nAffect(row-cnt:0) cost in 16 ms.\n[arthas@22714]$ sc -d *ApplicationContextUtil\n class-info        org.jeecgframework.core.util.ApplicationContextUtil\n code-source       /ayplot/erptomcat8.5/webapps/erp/WEB-INF/classes/\n name              org.jeecgframework.core.util.ApplicationContextUtil\n isInterface       false\n isAnnotation      false\n isEnum            false\n isAnonymousClass  false\n isArray           false\n isLocalClass      false\n isMemberClass     false\n isPrimitive       false\n isSynthetic       false\n simple-name       ApplicationContextUtil\n modifier          public\n annotation\n interfaces        org.springframework.context.ApplicationContextAware\n super-class       +-java.lang.Object\n class-loader      +-ParallelWebappClassLoader\n                       context: erp\n                       delegate: false\n                     ----------> Parent Classloader:\n                     java.net.URLClassLoader@3ac3fd8b\n\n                     +-java.net.URLClassLoader@3ac3fd8b\n                       +-sun.misc.Launcher$AppClassLoader@18b4aac2\n                         +-sun.misc.Launcher$ExtClassLoader@7b7c0aa8\n classLoaderHash   3b165738\n\nAffect(row-cnt:1) cost in 86 ms.\n[arthas@22714]$ ognl -c 3b165738 '@org.jeecgframework.core.util.ApplicationContextUtil@getContext().getBean(\"health\").access()'\n@String[OK]\n```\n\n## 5. 记录每次方法的调用\n``` bash\n//tt -t com.mxzhang.erp.api.actuator.Health  access\n\n[arthas@22714]$ tt -t  com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 503 ms, listenerId: 6\n INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n 1003        2020-12-04 12:44:39            1349.904497     true        false        0x64a3f100             ErpEmployeeController                         datagrid\n 1004        2020-12-04 12:44:46            1526.542767     true        false        0xef690d8              ErpEmployeeController                         datagrid\n 1005        2020-12-04 12:45:09            1268.608223     true        false        0x294385ad             ErpEmployeeController                         datagrid\n\n```\n\n### 查看入参出参详情\n``` bash\n[arthas@22714]$ tt -i 1003\n INDEX          1003\n GMT-CREATE     2020-12-04 12:44:39\n COST(ms)       1349.904497\n OBJECT         0x64a3f100\n CLASS          com.mxzhang.erp.employee.controller.ErpEmployeeController\n METHOD         datagrid\n IS-RETURN      true\n IS-EXCEPTION   false\n PARAMETERS[0]  @ErpEmployeeEntity[\n```\n> 此处参数被封装成引用对象，无法查看\n\n### 重新发起请求\n``` bash\n[arthas@22714]$ tt -t com.mxzhang.erp.api.actuator.Health  access\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 320 ms, listenerId: 7\n INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n 1006        2020-12-04 13:50:49            0.09137         true        false        0x7417c9e4             Health                                        access\n[arthas@22714]$ tt -i 1006 -p\n RE-INDEX      1006\n GMT-REPLAY    2020-12-04 13:51:14\n OBJECT        0x7417c9e4\n CLASS         com.mxzhang.erp.api.actuator.Health\n METHOD        access\n IS-RETURN     true\n IS-EXCEPTION  false\n COST(ms)      0.143933\n RETURN-OBJ    @String[OK]\nTime fragment[1006] successfully replayed 1 times.\n\n```\n> ThreadLocal 信息丢失和引用对象变更会导致无法准确获取，此时需要用到watch  \n\n## 观察每次方法调用\n``` bash\nwatch\nwatch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid '{params,target,returnObj}' -x 3\n\n// 观察具体参数\nwatch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid  'target'\n```\n\n## 7. 追踪方法调用栈\n``` bash\n[arthas@22714]$ trace com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid '#cost > 10'\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 542 ms, listenerId: 15\n`---ts=2020-12-04 15:00:42;thread_name=http-nio-8181-exec-21;id=c0;is_daemon=true;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@3b165738\n    `---[1208.379063ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:datagrid()\n        +---[5.28227ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:createDatagridCriteriaQuery() #675\n        +---[0.021024ms] javax.servlet.http.HttpServletRequest:getParameter() #676\n        +---[0.016183ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() #677\n        +---[0.016176ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() #680\n        +---[0.025832ms] org.hibernate.criterion.Restrictions:disjunction() #681\n        +---[0.015999ms] javax.servlet.http.HttpServletRequest:getParameter() #683\n        +---[0.016274ms] javax.servlet.http.HttpServletRequest:getParameter() #684\n        +---[0.015918ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() #685\n        +---[0.019184ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() #690\n        +---[0.031676ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() #693\n        +---[44.915965ms] com.mxzhang.erp.employee.service.ErpEmployeeServiceI:getDataGridReturn() #694\n        +---[0.031499ms] org.jeecgframework.core.common.model.json.DataGrid:getResults() #695\n        +---[34.233436ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:postProcessEmployeeList() #696\n        `---[1122.992269ms] org.jeecgframework.tag.core.easyui.TagUtil:datagrid() #697\n```\n\n**这个功能在调优的时候非常实用，可以看到每行代码的耗时。这种功能一般只有GW的付费软件才有**  \n\n### 次数限制\n``` bash\ntrace demo.MathGame run -n 1\n```\n这种功能对并发高的函数很有用\n\n### 调用耗时过滤\n``` bash\n$ trace demo.MathGame run '#cost > 10'\n```\n\n### trace多层\ntrace只能1层，因为多层扩展的代价很大。但是trace提供了多个类，可以使用此功能达到类似效果\n``` bash\ntrace -E com.test.ClassA|org.test.ClassB method1|method2|method3\n```\n\n### 排除指定类\n``` bash\ntrace javax.servlet.Filter * --exclude-class-pattern com.demo.TestFilter\n```\n\n\n## 8. 代码热更新\n``` bash\n[arthas@22714]$ redefine /home/deployer/Health.class\nredefine success, size: 1, classes:\ncom.mxzhang.erp.api.actuator.Health\n```\n也可以结合jad和mc命令在服务器上完成操作  \n1. jad反编译\n``` bash\njad --source-only com.mxzhang.erp.api.actuator.Health > /app/Health.java\n```\n2. 修改代码\n3. 生成class\n``` bash\n[arthas@22714]$ sc -d *Health | grep classLoaderHash\n classLoaderHash   3b165738\n[arthas@22714]$ mc -c 3b165738 /app/Health.java\nMemory compiler error, exception message: java.lang.RuntimeException: Wasn't able to open jar:file:/ayplot/erptomcat8.5/webapps/erp/WEB-INF/lib/commons-lang-2.6.jar!/ as a jar file, please check $HOME/logs/arthas/arthas.log for more details.\n// 这里我一直是失败的，不知为何，官网也提示mc经常失败\n```\n4. 热加载\n``` bash\nredefine /home/deployer/Health.class\n```\n\n> **redefine的限制**\n- 不允许新增加field/method\n- 正在跑的函数，没有退出不能生效\n\n**jrebel还是比arthas提供的热更新还是强大很多，但也要注意一点：以后热更新的时候要避免使用功能，防止更新失败**  \n\n> 更复杂姿势参考[ognl表达式](https://commons.apache.org/proper/commons-ognl/language-guide.html)  \n\n","slug":"arthas简述","published":1,"updated":"2024-04-11T03:38:07.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz2001pqwvd6k4uful5","content":"<p>arthas作为一款监控诊断的工具，能实时查看JVM信息，可以对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时等。实乃线上跟踪定位工具的不二之选!</p>\n<span id=\"more\"></span>\n<h2 id=\"1-查看类及子类信息（包含私有变量）\"><a href=\"#1-查看类及子类信息（包含私有变量）\" class=\"headerlink\" title=\"1. 查看类及子类信息（包含私有变量）\"></a>1. 查看类及子类信息（包含私有变量）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc -d -f com.mxzhang.erp.config.ErpConfig</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/arthas1.png\"></p>\n<h2 id=\"2-调用方法，使用tomcat时使用OGNL需要制定类加载器\"><a href=\"#2-调用方法，使用tomcat时使用OGNL需要制定类加载器\" class=\"headerlink\" title=\"2. 调用方法，使用tomcat时使用OGNL需要制定类加载器\"></a>2. 调用方法，使用tomcat时使用OGNL需要制定类加载器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader <span class=\"string\">&#x27;@com.mxzhang.erp.config.ErpConfig@isRunningBatchTaskEnv()&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单参数\"><a href=\"#简单参数\" class=\"headerlink\" title=\"简单参数\"></a>简单参数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader <span class=\"string\">&#x27;@com.mxzhang.erp.config.ErpConfig@getProperty(&quot;isHK&quot;)&#x27;</span> -x 1</span><br><span class=\"line\"></span><br><span class=\"line\">ognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader <span class=\"string\">&#x27;@com.mxzhang.erp.config.ErpConfig@isApiTestDesk(4)&#x27;</span> -x 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/arthas2.png\"></p>\n<h2 id=\"3-调用构造方法执行非静态方法\"><a href=\"#3-调用构造方法执行非静态方法\" class=\"headerlink\" title=\"3.调用构造方法执行非静态方法\"></a>3.调用构造方法执行非静态方法</h2><p>New这个对象，再执行方法即可  </p>\n<h2 id=\"4-调用任意Bean\"><a href=\"#4-调用任意Bean\" class=\"headerlink\" title=\"4. 调用任意Bean\"></a>4. 调用任意Bean</h2><p>基本步骤：<br>    1.找到classLoaderHash<br>    2. ognl通过类加载器调用方法  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ sc -d ApplicationContextUtil</span><br><span class=\"line\">Affect(row-cnt:0) cost <span class=\"keyword\">in</span> 16 ms.</span><br><span class=\"line\">[arthas@22714]$ sc -d *ApplicationContextUtil</span><br><span class=\"line\"> class-info        org.jeecgframework.core.util.ApplicationContextUtil</span><br><span class=\"line\"> code-source       /ayplot/erptomcat8.5/webapps/erp/WEB-INF/classes/</span><br><span class=\"line\"> name              org.jeecgframework.core.util.ApplicationContextUtil</span><br><span class=\"line\"> isInterface       <span class=\"literal\">false</span></span><br><span class=\"line\"> isAnnotation      <span class=\"literal\">false</span></span><br><span class=\"line\"> isEnum            <span class=\"literal\">false</span></span><br><span class=\"line\"> isAnonymousClass  <span class=\"literal\">false</span></span><br><span class=\"line\"> isArray           <span class=\"literal\">false</span></span><br><span class=\"line\"> isLocalClass      <span class=\"literal\">false</span></span><br><span class=\"line\"> isMemberClass     <span class=\"literal\">false</span></span><br><span class=\"line\"> isPrimitive       <span class=\"literal\">false</span></span><br><span class=\"line\"> isSynthetic       <span class=\"literal\">false</span></span><br><span class=\"line\"> simple-name       ApplicationContextUtil</span><br><span class=\"line\"> modifier          public</span><br><span class=\"line\"> annotation</span><br><span class=\"line\"> interfaces        org.springframework.context.ApplicationContextAware</span><br><span class=\"line\"> super-class       +-java.lang.Object</span><br><span class=\"line\"> class-loader      +-ParallelWebappClassLoader</span><br><span class=\"line\">                       context: erp</span><br><span class=\"line\">                       delegate: <span class=\"literal\">false</span></span><br><span class=\"line\">                     ----------&gt; Parent Classloader:</span><br><span class=\"line\">                     java.net.URLClassLoader@3ac3fd8b</span><br><span class=\"line\"></span><br><span class=\"line\">                     +-java.net.URLClassLoader@3ac3fd8b</span><br><span class=\"line\">                       +-sun.misc.Launcher<span class=\"variable\">$AppClassLoader</span>@18b4aac2</span><br><span class=\"line\">                         +-sun.misc.Launcher<span class=\"variable\">$ExtClassLoader</span>@7b7c0aa8</span><br><span class=\"line\"> classLoaderHash   3b165738</span><br><span class=\"line\"></span><br><span class=\"line\">Affect(row-cnt:1) cost <span class=\"keyword\">in</span> 86 ms.</span><br><span class=\"line\">[arthas@22714]$ ognl -c 3b165738 <span class=\"string\">&#x27;@org.jeecgframework.core.util.ApplicationContextUtil@getContext().getBean(&quot;health&quot;).access()&#x27;</span></span><br><span class=\"line\">@String[OK]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-记录每次方法的调用\"><a href=\"#5-记录每次方法的调用\" class=\"headerlink\" title=\"5. 记录每次方法的调用\"></a>5. 记录每次方法的调用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//tt -t com.mxzhang.erp.api.actuator.Health  access</span><br><span class=\"line\"></span><br><span class=\"line\">[arthas@22714]$ tt -t  com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid</span><br><span class=\"line\">Press Q or Ctrl+C to abort.</span><br><span class=\"line\">Affect(class count: 1 , method count: 1) cost <span class=\"keyword\">in</span> 503 ms, listenerId: 6</span><br><span class=\"line\"> INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD</span><br><span class=\"line\">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\"> 1003        2020-12-04 12:44:39            1349.904497     <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0x64a3f100             ErpEmployeeController                         datagrid</span><br><span class=\"line\"> 1004        2020-12-04 12:44:46            1526.542767     <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0xef690d8              ErpEmployeeController                         datagrid</span><br><span class=\"line\"> 1005        2020-12-04 12:45:09            1268.608223     <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0x294385ad             ErpEmployeeController                         datagrid</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看入参出参详情\"><a href=\"#查看入参出参详情\" class=\"headerlink\" title=\"查看入参出参详情\"></a>查看入参出参详情</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ tt -i 1003</span><br><span class=\"line\"> INDEX          1003</span><br><span class=\"line\"> GMT-CREATE     2020-12-04 12:44:39</span><br><span class=\"line\"> COST(ms)       1349.904497</span><br><span class=\"line\"> OBJECT         0x64a3f100</span><br><span class=\"line\"> CLASS          com.mxzhang.erp.employee.controller.ErpEmployeeController</span><br><span class=\"line\"> METHOD         datagrid</span><br><span class=\"line\"> IS-RETURN      <span class=\"literal\">true</span></span><br><span class=\"line\"> IS-EXCEPTION   <span class=\"literal\">false</span></span><br><span class=\"line\"> PARAMETERS[0]  @ErpEmployeeEntity[</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此处参数被封装成引用对象，无法查看</p>\n</blockquote>\n<h3 id=\"重新发起请求\"><a href=\"#重新发起请求\" class=\"headerlink\" title=\"重新发起请求\"></a>重新发起请求</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ tt -t com.mxzhang.erp.api.actuator.Health  access</span><br><span class=\"line\">Press Q or Ctrl+C to abort.</span><br><span class=\"line\">Affect(class count: 1 , method count: 1) cost <span class=\"keyword\">in</span> 320 ms, listenerId: 7</span><br><span class=\"line\"> INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD</span><br><span class=\"line\">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\"> 1006        2020-12-04 13:50:49            0.09137         <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0x7417c9e4             Health                                        access</span><br><span class=\"line\">[arthas@22714]$ tt -i 1006 -p</span><br><span class=\"line\"> RE-INDEX      1006</span><br><span class=\"line\"> GMT-REPLAY    2020-12-04 13:51:14</span><br><span class=\"line\"> OBJECT        0x7417c9e4</span><br><span class=\"line\"> CLASS         com.mxzhang.erp.api.actuator.Health</span><br><span class=\"line\"> METHOD        access</span><br><span class=\"line\"> IS-RETURN     <span class=\"literal\">true</span></span><br><span class=\"line\"> IS-EXCEPTION  <span class=\"literal\">false</span></span><br><span class=\"line\"> COST(ms)      0.143933</span><br><span class=\"line\"> RETURN-OBJ    @String[OK]</span><br><span class=\"line\">Time fragment[1006] successfully replayed 1 <span class=\"built_in\">times</span>.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ThreadLocal 信息丢失和引用对象变更会导致无法准确获取，此时需要用到watch  </p>\n</blockquote>\n<h2 id=\"观察每次方法调用\"><a href=\"#观察每次方法调用\" class=\"headerlink\" title=\"观察每次方法调用\"></a>观察每次方法调用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch</span><br><span class=\"line\">watch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid <span class=\"string\">&#x27;&#123;params,target,returnObj&#125;&#x27;</span> -x 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 观察具体参数</span><br><span class=\"line\">watch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid  <span class=\"string\">&#x27;target&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-追踪方法调用栈\"><a href=\"#7-追踪方法调用栈\" class=\"headerlink\" title=\"7. 追踪方法调用栈\"></a>7. 追踪方法调用栈</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ trace com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid <span class=\"string\">&#x27;#cost &gt; 10&#x27;</span></span><br><span class=\"line\">Press Q or Ctrl+C to abort.</span><br><span class=\"line\">Affect(class count: 1 , method count: 1) cost <span class=\"keyword\">in</span> 542 ms, listenerId: 15</span><br><span class=\"line\">`---ts=2020-12-04 15:00:42;thread_name=http-nio-8181-exec-21;id=c0;is_daemon=<span class=\"literal\">true</span>;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@3b165738</span><br><span class=\"line\">    `---[1208.379063ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:datagrid()</span><br><span class=\"line\">        +---[5.28227ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:createDatagridCriteriaQuery() <span class=\"comment\">#675</span></span><br><span class=\"line\">        +---[0.021024ms] javax.servlet.http.HttpServletRequest:getParameter() <span class=\"comment\">#676</span></span><br><span class=\"line\">        +---[0.016183ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() <span class=\"comment\">#677</span></span><br><span class=\"line\">        +---[0.016176ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() <span class=\"comment\">#680</span></span><br><span class=\"line\">        +---[0.025832ms] org.hibernate.criterion.Restrictions:disjunction() <span class=\"comment\">#681</span></span><br><span class=\"line\">        +---[0.015999ms] javax.servlet.http.HttpServletRequest:getParameter() <span class=\"comment\">#683</span></span><br><span class=\"line\">        +---[0.016274ms] javax.servlet.http.HttpServletRequest:getParameter() <span class=\"comment\">#684</span></span><br><span class=\"line\">        +---[0.015918ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() <span class=\"comment\">#685</span></span><br><span class=\"line\">        +---[0.019184ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() <span class=\"comment\">#690</span></span><br><span class=\"line\">        +---[0.031676ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() <span class=\"comment\">#693</span></span><br><span class=\"line\">        +---[44.915965ms] com.mxzhang.erp.employee.service.ErpEmployeeServiceI:getDataGridReturn() <span class=\"comment\">#694</span></span><br><span class=\"line\">        +---[0.031499ms] org.jeecgframework.core.common.model.json.DataGrid:getResults() <span class=\"comment\">#695</span></span><br><span class=\"line\">        +---[34.233436ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:postProcessEmployeeList() <span class=\"comment\">#696</span></span><br><span class=\"line\">        `---[1122.992269ms] org.jeecgframework.tag.core.easyui.TagUtil:datagrid() <span class=\"comment\">#697</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>这个功能在调优的时候非常实用，可以看到每行代码的耗时。这种功能一般只有GW的付费软件才有</strong>  </p>\n<h3 id=\"次数限制\"><a href=\"#次数限制\" class=\"headerlink\" title=\"次数限制\"></a>次数限制</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trace demo.MathGame run -n 1</span><br></pre></td></tr></table></figure>\n<p>这种功能对并发高的函数很有用</p>\n<h3 id=\"调用耗时过滤\"><a href=\"#调用耗时过滤\" class=\"headerlink\" title=\"调用耗时过滤\"></a>调用耗时过滤</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ trace demo.MathGame run <span class=\"string\">&#x27;#cost &gt; 10&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"trace多层\"><a href=\"#trace多层\" class=\"headerlink\" title=\"trace多层\"></a>trace多层</h3><p>trace只能1层，因为多层扩展的代价很大。但是trace提供了多个类，可以使用此功能达到类似效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trace -E com.test.ClassA|org.test.ClassB method1|method2|method3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排除指定类\"><a href=\"#排除指定类\" class=\"headerlink\" title=\"排除指定类\"></a>排除指定类</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trace javax.servlet.Filter * --exclude-class-pattern com.demo.TestFilter</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"8-代码热更新\"><a href=\"#8-代码热更新\" class=\"headerlink\" title=\"8. 代码热更新\"></a>8. 代码热更新</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ redefine /home/deployer/Health.class</span><br><span class=\"line\">redefine success, size: 1, classes:</span><br><span class=\"line\">com.mxzhang.erp.api.actuator.Health</span><br></pre></td></tr></table></figure>\n<p>也可以结合jad和mc命令在服务器上完成操作  </p>\n<ol>\n<li>jad反编译<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jad --source-only com.mxzhang.erp.api.actuator.Health &gt; /app/Health.java</span><br></pre></td></tr></table></figure></li>\n<li>修改代码</li>\n<li>生成class<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ sc -d *Health | grep classLoaderHash</span><br><span class=\"line\"> classLoaderHash   3b165738</span><br><span class=\"line\">[arthas@22714]$ mc -c 3b165738 /app/Health.java</span><br><span class=\"line\">Memory compiler error, exception message: java.lang.RuntimeException: Wasn<span class=\"string\">&#x27;t able to open jar:file:/ayplot/erptomcat8.5/webapps/erp/WEB-INF/lib/commons-lang-2.6.jar!/ as a jar file, please check $HOME/logs/arthas/arthas.log for more details.</span></span><br><span class=\"line\"><span class=\"string\">// 这里我一直是失败的，不知为何，官网也提示mc经常失败</span></span><br></pre></td></tr></table></figure></li>\n<li>热加载<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redefine /home/deployer/Health.class</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><strong>redefine的限制</strong></p>\n</blockquote>\n<ul>\n<li>不允许新增加field&#x2F;method</li>\n<li>正在跑的函数，没有退出不能生效</li>\n</ul>\n<p><strong>jrebel还是比arthas提供的热更新还是强大很多，但也要注意一点：以后热更新的时候要避免使用功能，防止更新失败</strong>  </p>\n<blockquote>\n<p>更复杂姿势参考<a href=\"https://commons.apache.org/proper/commons-ognl/language-guide.html\">ognl表达式</a>  </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>arthas作为一款监控诊断的工具，能实时查看JVM信息，可以对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时等。实乃线上跟踪定位工具的不二之选!</p>","more":"<h2 id=\"1-查看类及子类信息（包含私有变量）\"><a href=\"#1-查看类及子类信息（包含私有变量）\" class=\"headerlink\" title=\"1. 查看类及子类信息（包含私有变量）\"></a>1. 查看类及子类信息（包含私有变量）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc -d -f com.mxzhang.erp.config.ErpConfig</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/arthas1.png\"></p>\n<h2 id=\"2-调用方法，使用tomcat时使用OGNL需要制定类加载器\"><a href=\"#2-调用方法，使用tomcat时使用OGNL需要制定类加载器\" class=\"headerlink\" title=\"2. 调用方法，使用tomcat时使用OGNL需要制定类加载器\"></a>2. 调用方法，使用tomcat时使用OGNL需要制定类加载器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader <span class=\"string\">&#x27;@com.mxzhang.erp.config.ErpConfig@isRunningBatchTaskEnv()&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单参数\"><a href=\"#简单参数\" class=\"headerlink\" title=\"简单参数\"></a>简单参数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader <span class=\"string\">&#x27;@com.mxzhang.erp.config.ErpConfig@getProperty(&quot;isHK&quot;)&#x27;</span> -x 1</span><br><span class=\"line\"></span><br><span class=\"line\">ognl --classLoaderClass org.apache.catalina.loader.ParallelWebappClassLoader <span class=\"string\">&#x27;@com.mxzhang.erp.config.ErpConfig@isApiTestDesk(4)&#x27;</span> -x 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/arthas2.png\"></p>\n<h2 id=\"3-调用构造方法执行非静态方法\"><a href=\"#3-调用构造方法执行非静态方法\" class=\"headerlink\" title=\"3.调用构造方法执行非静态方法\"></a>3.调用构造方法执行非静态方法</h2><p>New这个对象，再执行方法即可  </p>\n<h2 id=\"4-调用任意Bean\"><a href=\"#4-调用任意Bean\" class=\"headerlink\" title=\"4. 调用任意Bean\"></a>4. 调用任意Bean</h2><p>基本步骤：<br>    1.找到classLoaderHash<br>    2. ognl通过类加载器调用方法  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ sc -d ApplicationContextUtil</span><br><span class=\"line\">Affect(row-cnt:0) cost <span class=\"keyword\">in</span> 16 ms.</span><br><span class=\"line\">[arthas@22714]$ sc -d *ApplicationContextUtil</span><br><span class=\"line\"> class-info        org.jeecgframework.core.util.ApplicationContextUtil</span><br><span class=\"line\"> code-source       /ayplot/erptomcat8.5/webapps/erp/WEB-INF/classes/</span><br><span class=\"line\"> name              org.jeecgframework.core.util.ApplicationContextUtil</span><br><span class=\"line\"> isInterface       <span class=\"literal\">false</span></span><br><span class=\"line\"> isAnnotation      <span class=\"literal\">false</span></span><br><span class=\"line\"> isEnum            <span class=\"literal\">false</span></span><br><span class=\"line\"> isAnonymousClass  <span class=\"literal\">false</span></span><br><span class=\"line\"> isArray           <span class=\"literal\">false</span></span><br><span class=\"line\"> isLocalClass      <span class=\"literal\">false</span></span><br><span class=\"line\"> isMemberClass     <span class=\"literal\">false</span></span><br><span class=\"line\"> isPrimitive       <span class=\"literal\">false</span></span><br><span class=\"line\"> isSynthetic       <span class=\"literal\">false</span></span><br><span class=\"line\"> simple-name       ApplicationContextUtil</span><br><span class=\"line\"> modifier          public</span><br><span class=\"line\"> annotation</span><br><span class=\"line\"> interfaces        org.springframework.context.ApplicationContextAware</span><br><span class=\"line\"> super-class       +-java.lang.Object</span><br><span class=\"line\"> class-loader      +-ParallelWebappClassLoader</span><br><span class=\"line\">                       context: erp</span><br><span class=\"line\">                       delegate: <span class=\"literal\">false</span></span><br><span class=\"line\">                     ----------&gt; Parent Classloader:</span><br><span class=\"line\">                     java.net.URLClassLoader@3ac3fd8b</span><br><span class=\"line\"></span><br><span class=\"line\">                     +-java.net.URLClassLoader@3ac3fd8b</span><br><span class=\"line\">                       +-sun.misc.Launcher<span class=\"variable\">$AppClassLoader</span>@18b4aac2</span><br><span class=\"line\">                         +-sun.misc.Launcher<span class=\"variable\">$ExtClassLoader</span>@7b7c0aa8</span><br><span class=\"line\"> classLoaderHash   3b165738</span><br><span class=\"line\"></span><br><span class=\"line\">Affect(row-cnt:1) cost <span class=\"keyword\">in</span> 86 ms.</span><br><span class=\"line\">[arthas@22714]$ ognl -c 3b165738 <span class=\"string\">&#x27;@org.jeecgframework.core.util.ApplicationContextUtil@getContext().getBean(&quot;health&quot;).access()&#x27;</span></span><br><span class=\"line\">@String[OK]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-记录每次方法的调用\"><a href=\"#5-记录每次方法的调用\" class=\"headerlink\" title=\"5. 记录每次方法的调用\"></a>5. 记录每次方法的调用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//tt -t com.mxzhang.erp.api.actuator.Health  access</span><br><span class=\"line\"></span><br><span class=\"line\">[arthas@22714]$ tt -t  com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid</span><br><span class=\"line\">Press Q or Ctrl+C to abort.</span><br><span class=\"line\">Affect(class count: 1 , method count: 1) cost <span class=\"keyword\">in</span> 503 ms, listenerId: 6</span><br><span class=\"line\"> INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD</span><br><span class=\"line\">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\"> 1003        2020-12-04 12:44:39            1349.904497     <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0x64a3f100             ErpEmployeeController                         datagrid</span><br><span class=\"line\"> 1004        2020-12-04 12:44:46            1526.542767     <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0xef690d8              ErpEmployeeController                         datagrid</span><br><span class=\"line\"> 1005        2020-12-04 12:45:09            1268.608223     <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0x294385ad             ErpEmployeeController                         datagrid</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看入参出参详情\"><a href=\"#查看入参出参详情\" class=\"headerlink\" title=\"查看入参出参详情\"></a>查看入参出参详情</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ tt -i 1003</span><br><span class=\"line\"> INDEX          1003</span><br><span class=\"line\"> GMT-CREATE     2020-12-04 12:44:39</span><br><span class=\"line\"> COST(ms)       1349.904497</span><br><span class=\"line\"> OBJECT         0x64a3f100</span><br><span class=\"line\"> CLASS          com.mxzhang.erp.employee.controller.ErpEmployeeController</span><br><span class=\"line\"> METHOD         datagrid</span><br><span class=\"line\"> IS-RETURN      <span class=\"literal\">true</span></span><br><span class=\"line\"> IS-EXCEPTION   <span class=\"literal\">false</span></span><br><span class=\"line\"> PARAMETERS[0]  @ErpEmployeeEntity[</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此处参数被封装成引用对象，无法查看</p>\n</blockquote>\n<h3 id=\"重新发起请求\"><a href=\"#重新发起请求\" class=\"headerlink\" title=\"重新发起请求\"></a>重新发起请求</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ tt -t com.mxzhang.erp.api.actuator.Health  access</span><br><span class=\"line\">Press Q or Ctrl+C to abort.</span><br><span class=\"line\">Affect(class count: 1 , method count: 1) cost <span class=\"keyword\">in</span> 320 ms, listenerId: 7</span><br><span class=\"line\"> INDEX       TIMESTAMP                      COST(ms)        IS-RET      IS-EXP       OBJECT                 CLASS                                         METHOD</span><br><span class=\"line\">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\"> 1006        2020-12-04 13:50:49            0.09137         <span class=\"literal\">true</span>        <span class=\"literal\">false</span>        0x7417c9e4             Health                                        access</span><br><span class=\"line\">[arthas@22714]$ tt -i 1006 -p</span><br><span class=\"line\"> RE-INDEX      1006</span><br><span class=\"line\"> GMT-REPLAY    2020-12-04 13:51:14</span><br><span class=\"line\"> OBJECT        0x7417c9e4</span><br><span class=\"line\"> CLASS         com.mxzhang.erp.api.actuator.Health</span><br><span class=\"line\"> METHOD        access</span><br><span class=\"line\"> IS-RETURN     <span class=\"literal\">true</span></span><br><span class=\"line\"> IS-EXCEPTION  <span class=\"literal\">false</span></span><br><span class=\"line\"> COST(ms)      0.143933</span><br><span class=\"line\"> RETURN-OBJ    @String[OK]</span><br><span class=\"line\">Time fragment[1006] successfully replayed 1 <span class=\"built_in\">times</span>.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ThreadLocal 信息丢失和引用对象变更会导致无法准确获取，此时需要用到watch  </p>\n</blockquote>\n<h2 id=\"观察每次方法调用\"><a href=\"#观察每次方法调用\" class=\"headerlink\" title=\"观察每次方法调用\"></a>观察每次方法调用</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch</span><br><span class=\"line\">watch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid <span class=\"string\">&#x27;&#123;params,target,returnObj&#125;&#x27;</span> -x 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 观察具体参数</span><br><span class=\"line\">watch com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid  <span class=\"string\">&#x27;target&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-追踪方法调用栈\"><a href=\"#7-追踪方法调用栈\" class=\"headerlink\" title=\"7. 追踪方法调用栈\"></a>7. 追踪方法调用栈</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ trace com.mxzhang.erp.employee.controller.ErpEmployeeController datagrid <span class=\"string\">&#x27;#cost &gt; 10&#x27;</span></span><br><span class=\"line\">Press Q or Ctrl+C to abort.</span><br><span class=\"line\">Affect(class count: 1 , method count: 1) cost <span class=\"keyword\">in</span> 542 ms, listenerId: 15</span><br><span class=\"line\">`---ts=2020-12-04 15:00:42;thread_name=http-nio-8181-exec-21;id=c0;is_daemon=<span class=\"literal\">true</span>;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@3b165738</span><br><span class=\"line\">    `---[1208.379063ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:datagrid()</span><br><span class=\"line\">        +---[5.28227ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:createDatagridCriteriaQuery() <span class=\"comment\">#675</span></span><br><span class=\"line\">        +---[0.021024ms] javax.servlet.http.HttpServletRequest:getParameter() <span class=\"comment\">#676</span></span><br><span class=\"line\">        +---[0.016183ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() <span class=\"comment\">#677</span></span><br><span class=\"line\">        +---[0.016176ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() <span class=\"comment\">#680</span></span><br><span class=\"line\">        +---[0.025832ms] org.hibernate.criterion.Restrictions:disjunction() <span class=\"comment\">#681</span></span><br><span class=\"line\">        +---[0.015999ms] javax.servlet.http.HttpServletRequest:getParameter() <span class=\"comment\">#683</span></span><br><span class=\"line\">        +---[0.016274ms] javax.servlet.http.HttpServletRequest:getParameter() <span class=\"comment\">#684</span></span><br><span class=\"line\">        +---[0.015918ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() <span class=\"comment\">#685</span></span><br><span class=\"line\">        +---[0.019184ms] com.mxzhang.erp.utils.StringUtils:isNotEmpty() <span class=\"comment\">#690</span></span><br><span class=\"line\">        +---[0.031676ms] org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery:add() <span class=\"comment\">#693</span></span><br><span class=\"line\">        +---[44.915965ms] com.mxzhang.erp.employee.service.ErpEmployeeServiceI:getDataGridReturn() <span class=\"comment\">#694</span></span><br><span class=\"line\">        +---[0.031499ms] org.jeecgframework.core.common.model.json.DataGrid:getResults() <span class=\"comment\">#695</span></span><br><span class=\"line\">        +---[34.233436ms] com.mxzhang.erp.employee.controller.ErpEmployeeController:postProcessEmployeeList() <span class=\"comment\">#696</span></span><br><span class=\"line\">        `---[1122.992269ms] org.jeecgframework.tag.core.easyui.TagUtil:datagrid() <span class=\"comment\">#697</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>这个功能在调优的时候非常实用，可以看到每行代码的耗时。这种功能一般只有GW的付费软件才有</strong>  </p>\n<h3 id=\"次数限制\"><a href=\"#次数限制\" class=\"headerlink\" title=\"次数限制\"></a>次数限制</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trace demo.MathGame run -n 1</span><br></pre></td></tr></table></figure>\n<p>这种功能对并发高的函数很有用</p>\n<h3 id=\"调用耗时过滤\"><a href=\"#调用耗时过滤\" class=\"headerlink\" title=\"调用耗时过滤\"></a>调用耗时过滤</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ trace demo.MathGame run <span class=\"string\">&#x27;#cost &gt; 10&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"trace多层\"><a href=\"#trace多层\" class=\"headerlink\" title=\"trace多层\"></a>trace多层</h3><p>trace只能1层，因为多层扩展的代价很大。但是trace提供了多个类，可以使用此功能达到类似效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trace -E com.test.ClassA|org.test.ClassB method1|method2|method3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排除指定类\"><a href=\"#排除指定类\" class=\"headerlink\" title=\"排除指定类\"></a>排除指定类</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trace javax.servlet.Filter * --exclude-class-pattern com.demo.TestFilter</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"8-代码热更新\"><a href=\"#8-代码热更新\" class=\"headerlink\" title=\"8. 代码热更新\"></a>8. 代码热更新</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ redefine /home/deployer/Health.class</span><br><span class=\"line\">redefine success, size: 1, classes:</span><br><span class=\"line\">com.mxzhang.erp.api.actuator.Health</span><br></pre></td></tr></table></figure>\n<p>也可以结合jad和mc命令在服务器上完成操作  </p>\n<ol>\n<li>jad反编译<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jad --source-only com.mxzhang.erp.api.actuator.Health &gt; /app/Health.java</span><br></pre></td></tr></table></figure></li>\n<li>修改代码</li>\n<li>生成class<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arthas@22714]$ sc -d *Health | grep classLoaderHash</span><br><span class=\"line\"> classLoaderHash   3b165738</span><br><span class=\"line\">[arthas@22714]$ mc -c 3b165738 /app/Health.java</span><br><span class=\"line\">Memory compiler error, exception message: java.lang.RuntimeException: Wasn<span class=\"string\">&#x27;t able to open jar:file:/ayplot/erptomcat8.5/webapps/erp/WEB-INF/lib/commons-lang-2.6.jar!/ as a jar file, please check $HOME/logs/arthas/arthas.log for more details.</span></span><br><span class=\"line\"><span class=\"string\">// 这里我一直是失败的，不知为何，官网也提示mc经常失败</span></span><br></pre></td></tr></table></figure></li>\n<li>热加载<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redefine /home/deployer/Health.class</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><strong>redefine的限制</strong></p>\n</blockquote>\n<ul>\n<li>不允许新增加field&#x2F;method</li>\n<li>正在跑的函数，没有退出不能生效</li>\n</ul>\n<p><strong>jrebel还是比arthas提供的热更新还是强大很多，但也要注意一点：以后热更新的时候要避免使用功能，防止更新失败</strong>  </p>\n<blockquote>\n<p>更复杂姿势参考<a href=\"https://commons.apache.org/proper/commons-ognl/language-guide.html\">ognl表达式</a>  </p>\n</blockquote>"},{"title":"TiDB执行计划","date":"2023-09-13T07:47:10.000Z","_content":"Tidb中想知道SQL在数据库中是怎么执行的，可以和Mysql中一样，使用 EXPLAIN 关键字。\n<!--more-->\n和Mysql不一样的是，Tidb早期版本宣传支持的Mysql版本是5.7（Tidb7.4以后正式支持Mysql8.0）。  \n但是Mysql8.0中的 EXPLAIN ANALYZE关键字，在TIdb的早期版本中也时支持的。与`EXPLAIN`​不会执行SQL不同，`EXPLAIN ANALYZE`​会执行对应的 SQL 语句，记录其运行时信息，和执行计划一并返回出来。它的输出格式和Mysql8.0中差异较大。  \n实际应用中，我们一般使用`EXPLAIN ANALYZE`​显示更多的物理执行信息来优化SQL。\n\n### 一 EXPLAIN ANALYZE列含义\n\n‍\n\n​`EXPLAIN ANALYZE`​查询执行计划列含义：\n\n|属性名|含义|\n| :------------------| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n|id|算子名，或执行 SQL 语句需要执行的子任务|\n|estRows|iDB 预计会处理的行数|\n|task|算子位置，cop(TiKV或TiFlash)和 root (Tidb)|\n|access-object|显示被访问的表、分区和索引|\n|operator info|列可显示诸如条件下推等信息|\n|actRows|算子实际输出的数据条数。|\n|execution info|算子的实际执行信息。time 表示从进入算子到离开算子的全部 wall time，包括所有子算子操作的全部执行时间。如果该算子被父算子多次调用 (loops)，这个时间就是累积的时间。loops 是当前算子被父算子调用的次数。|\n|memory|算子占用内存空间的大小。|\n|disk|算子占用磁盘空间的大小。|\n\n‍\n\n### 二 常用SQL优化技巧\n\n* 索引优化，如果使用记录数较多的表的列，那么就要考虑在列上建索引\n* 避免全表扫描（Full Table Scan）\n* 优化查询条件，避免在列上进行函数操作\n* 使用覆盖索引，不用回表，减少IO操作\n\n‍\n\n### 三 分析优化举例\n\n由于使用hibernate，在享受遍历性的同时，部分SQL常常被拼接的过于臃肿。下面这个SQL就是这样，其中查询字段重复包含了9个表的全部字段，大概有400多个，用省略号代替。\n\n```sql\nexplain analyze\n    SELECT this_.ID AS ID1_879_8_ ...\nFROM simple_workflow_record this_\n\tLEFT JOIN erp_employee erpemploye3_ ON this_.EMPLOYEEID = erpemploye3_.ID\n\tLEFT JOIN erp_job_record erpjobreco4_ ON erpemploye3_.LAST_JOB_REC_ID = erpjobreco4_.ID\n\tLEFT JOIN erp_job_record erpjobreco5_ ON erpemploye3_.LAST_WORK_REC_ID = erpjobreco5_.ID\n\tLEFT JOIN erp_employee erpemploye6_ ON erpemploye3_.RELATIVES_EMPLOYEE_ID = erpemploye6_.ID\n\tLEFT JOIN erp_job_record erpjobreco7_ ON this_.JOB_RECORD_ID = erpjobreco7_.ID\n\tLEFT JOIN t_s_depart tsdepart8_ ON erpjobreco7_.DPT_ID = tsdepart8_.ID\n\tLEFT JOIN erp_job erpjobenti9_ ON erpjobreco7_.JOB_ID = erpjobenti9_.ID\n\tINNER JOIN simple_workflow workflow1_ ON this_.WORKFLOW_ID = workflow1_.ID\nWHERE this_.EMPLOYEEID = '20190401003'\n\tOR this_.PROCESS_EMPLOYEE_IDS LIKE '%20190401003%'\n\tOR this_.CC_EMPLOYEE_IDS LIKE '%20190401003%'\n\tAND workflow1_.MATCH_KEYWORD <> 'ErpSubsidyConfirmRecordEntity'\nORDER BY this_.UPDATE_DATE DESC, this_.CREATE_DATE DESC\nLIMIT 20;\n```\n\n大致优化分析及优化思路：\n\n>  检查条件列是否建立索引，对于不能使用索引的，是否可以使用Tiflash优化（实际结果：非大表，非聚合而使用列取，优化不明显，大概在几十ms内）\n\n* 首次优化，大概从7s到2.5s，执行计划如下：\n\n​![image](/images/assets/image-20240511180118-9ol9gj4.png)​\n\n上面提到Hibernate的ENtity拼接导致了很多冗余字段，在执行计划中也展示出来： 只是抓取20条记录，实际却要处理300多M数据。因此，可以\n\n1. 优化业务关联，省略无效JOIN\n2. 根据业务情况，使用同名简短Entity（省去无效JOIN，省去冗余字段）\n\n优化后SQL为：\n\n```sql\nFROM simple_workflow_record this_\n\tLEFT JOIN erp_employee erpemploye3_ ON this_.EMPLOYEEID = erpemploye3_.ID\n\tLEFT JOIN erp_job_record erpjobreco4_ ON erpemploye3_.LAST_JOB_REC_ID = erpjobreco4_.ID\n\tINNER JOIN simple_workflow workflow1_ ON this_.WORKFLOW_ID = workflow1_.ID\nWHERE this_.EMPLOYEEID = ?\n\tOR this_.PROCESS_EMPLOYEE_IDS LIKE ?\n\tOR this_.CC_EMPLOYEE_IDS LIKE ?\n\tAND workflow1_.MATCH_KEYWORD <> ?\nORDER BY this_.UPDATE_DATE DESC, this_.CREATE_DATE DESC\nLIMIT ?;\n```\n\n最终优化后执行耗时460ms，执行计划如下：\n\n​![image](/images/assets/image-20240513172430-zijsvdp.png)​\n\n‍\n\n* ANALYZE TABLE\n\nANALYZE 语句用于更新 TiDB 在表和索引上留下的统计信息。执行大批量更新或导入记录后，或查询执行计划不是最佳时，建议运行 ANALYZE。  \n当 TiDB 逐渐发现这些统计数据与预估不一致时，也会自动更新其统计数据。\n\n‍\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Tidb执行计划.md","raw":"---\ntitle: TiDB执行计划\ndate: 2023-09-13 15:47:10\ntags: Tidb\ncategories: 数据库\n---\nTidb中想知道SQL在数据库中是怎么执行的，可以和Mysql中一样，使用 EXPLAIN 关键字。\n<!--more-->\n和Mysql不一样的是，Tidb早期版本宣传支持的Mysql版本是5.7（Tidb7.4以后正式支持Mysql8.0）。  \n但是Mysql8.0中的 EXPLAIN ANALYZE关键字，在TIdb的早期版本中也时支持的。与`EXPLAIN`​不会执行SQL不同，`EXPLAIN ANALYZE`​会执行对应的 SQL 语句，记录其运行时信息，和执行计划一并返回出来。它的输出格式和Mysql8.0中差异较大。  \n实际应用中，我们一般使用`EXPLAIN ANALYZE`​显示更多的物理执行信息来优化SQL。\n\n### 一 EXPLAIN ANALYZE列含义\n\n‍\n\n​`EXPLAIN ANALYZE`​查询执行计划列含义：\n\n|属性名|含义|\n| :------------------| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n|id|算子名，或执行 SQL 语句需要执行的子任务|\n|estRows|iDB 预计会处理的行数|\n|task|算子位置，cop(TiKV或TiFlash)和 root (Tidb)|\n|access-object|显示被访问的表、分区和索引|\n|operator info|列可显示诸如条件下推等信息|\n|actRows|算子实际输出的数据条数。|\n|execution info|算子的实际执行信息。time 表示从进入算子到离开算子的全部 wall time，包括所有子算子操作的全部执行时间。如果该算子被父算子多次调用 (loops)，这个时间就是累积的时间。loops 是当前算子被父算子调用的次数。|\n|memory|算子占用内存空间的大小。|\n|disk|算子占用磁盘空间的大小。|\n\n‍\n\n### 二 常用SQL优化技巧\n\n* 索引优化，如果使用记录数较多的表的列，那么就要考虑在列上建索引\n* 避免全表扫描（Full Table Scan）\n* 优化查询条件，避免在列上进行函数操作\n* 使用覆盖索引，不用回表，减少IO操作\n\n‍\n\n### 三 分析优化举例\n\n由于使用hibernate，在享受遍历性的同时，部分SQL常常被拼接的过于臃肿。下面这个SQL就是这样，其中查询字段重复包含了9个表的全部字段，大概有400多个，用省略号代替。\n\n```sql\nexplain analyze\n    SELECT this_.ID AS ID1_879_8_ ...\nFROM simple_workflow_record this_\n\tLEFT JOIN erp_employee erpemploye3_ ON this_.EMPLOYEEID = erpemploye3_.ID\n\tLEFT JOIN erp_job_record erpjobreco4_ ON erpemploye3_.LAST_JOB_REC_ID = erpjobreco4_.ID\n\tLEFT JOIN erp_job_record erpjobreco5_ ON erpemploye3_.LAST_WORK_REC_ID = erpjobreco5_.ID\n\tLEFT JOIN erp_employee erpemploye6_ ON erpemploye3_.RELATIVES_EMPLOYEE_ID = erpemploye6_.ID\n\tLEFT JOIN erp_job_record erpjobreco7_ ON this_.JOB_RECORD_ID = erpjobreco7_.ID\n\tLEFT JOIN t_s_depart tsdepart8_ ON erpjobreco7_.DPT_ID = tsdepart8_.ID\n\tLEFT JOIN erp_job erpjobenti9_ ON erpjobreco7_.JOB_ID = erpjobenti9_.ID\n\tINNER JOIN simple_workflow workflow1_ ON this_.WORKFLOW_ID = workflow1_.ID\nWHERE this_.EMPLOYEEID = '20190401003'\n\tOR this_.PROCESS_EMPLOYEE_IDS LIKE '%20190401003%'\n\tOR this_.CC_EMPLOYEE_IDS LIKE '%20190401003%'\n\tAND workflow1_.MATCH_KEYWORD <> 'ErpSubsidyConfirmRecordEntity'\nORDER BY this_.UPDATE_DATE DESC, this_.CREATE_DATE DESC\nLIMIT 20;\n```\n\n大致优化分析及优化思路：\n\n>  检查条件列是否建立索引，对于不能使用索引的，是否可以使用Tiflash优化（实际结果：非大表，非聚合而使用列取，优化不明显，大概在几十ms内）\n\n* 首次优化，大概从7s到2.5s，执行计划如下：\n\n​![image](/images/assets/image-20240511180118-9ol9gj4.png)​\n\n上面提到Hibernate的ENtity拼接导致了很多冗余字段，在执行计划中也展示出来： 只是抓取20条记录，实际却要处理300多M数据。因此，可以\n\n1. 优化业务关联，省略无效JOIN\n2. 根据业务情况，使用同名简短Entity（省去无效JOIN，省去冗余字段）\n\n优化后SQL为：\n\n```sql\nFROM simple_workflow_record this_\n\tLEFT JOIN erp_employee erpemploye3_ ON this_.EMPLOYEEID = erpemploye3_.ID\n\tLEFT JOIN erp_job_record erpjobreco4_ ON erpemploye3_.LAST_JOB_REC_ID = erpjobreco4_.ID\n\tINNER JOIN simple_workflow workflow1_ ON this_.WORKFLOW_ID = workflow1_.ID\nWHERE this_.EMPLOYEEID = ?\n\tOR this_.PROCESS_EMPLOYEE_IDS LIKE ?\n\tOR this_.CC_EMPLOYEE_IDS LIKE ?\n\tAND workflow1_.MATCH_KEYWORD <> ?\nORDER BY this_.UPDATE_DATE DESC, this_.CREATE_DATE DESC\nLIMIT ?;\n```\n\n最终优化后执行耗时460ms，执行计划如下：\n\n​![image](/images/assets/image-20240513172430-zijsvdp.png)​\n\n‍\n\n* ANALYZE TABLE\n\nANALYZE 语句用于更新 TiDB 在表和索引上留下的统计信息。执行大批量更新或导入记录后，或查询执行计划不是最佳时，建议运行 ANALYZE。  \n当 TiDB 逐渐发现这些统计数据与预估不一致时，也会自动更新其统计数据。\n\n‍\n\n\n\n\n\n\n\n\n\n\n","slug":"Tidb执行计划","published":1,"updated":"2024-05-14T02:07:14.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz2001rqwvdhkyl1c9a","content":"<p>Tidb中想知道SQL在数据库中是怎么执行的，可以和Mysql中一样，使用 EXPLAIN 关键字。</p>\n<span id=\"more\"></span>\n<p>和Mysql不一样的是，Tidb早期版本宣传支持的Mysql版本是5.7（Tidb7.4以后正式支持Mysql8.0）。<br>但是Mysql8.0中的 EXPLAIN ANALYZE关键字，在TIdb的早期版本中也时支持的。与<code>EXPLAIN</code>​不会执行SQL不同，<code>EXPLAIN ANALYZE</code>​会执行对应的 SQL 语句，记录其运行时信息，和执行计划一并返回出来。它的输出格式和Mysql8.0中差异较大。<br>实际应用中，我们一般使用<code>EXPLAIN ANALYZE</code>​显示更多的物理执行信息来优化SQL。</p>\n<h3 id=\"一-EXPLAIN-ANALYZE列含义\"><a href=\"#一-EXPLAIN-ANALYZE列含义\" class=\"headerlink\" title=\"一 EXPLAIN ANALYZE列含义\"></a>一 EXPLAIN ANALYZE列含义</h3><p>‍</p>\n<p>​<code>EXPLAIN ANALYZE</code>​查询执行计划列含义：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性名</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">id</td>\n<td align=\"left\">算子名，或执行 SQL 语句需要执行的子任务</td>\n</tr>\n<tr>\n<td align=\"left\">estRows</td>\n<td align=\"left\">iDB 预计会处理的行数</td>\n</tr>\n<tr>\n<td align=\"left\">task</td>\n<td align=\"left\">算子位置，cop(TiKV或TiFlash)和 root (Tidb)</td>\n</tr>\n<tr>\n<td align=\"left\">access-object</td>\n<td align=\"left\">显示被访问的表、分区和索引</td>\n</tr>\n<tr>\n<td align=\"left\">operator info</td>\n<td align=\"left\">列可显示诸如条件下推等信息</td>\n</tr>\n<tr>\n<td align=\"left\">actRows</td>\n<td align=\"left\">算子实际输出的数据条数。</td>\n</tr>\n<tr>\n<td align=\"left\">execution info</td>\n<td align=\"left\">算子的实际执行信息。time 表示从进入算子到离开算子的全部 wall time，包括所有子算子操作的全部执行时间。如果该算子被父算子多次调用 (loops)，这个时间就是累积的时间。loops 是当前算子被父算子调用的次数。</td>\n</tr>\n<tr>\n<td align=\"left\">memory</td>\n<td align=\"left\">算子占用内存空间的大小。</td>\n</tr>\n<tr>\n<td align=\"left\">disk</td>\n<td align=\"left\">算子占用磁盘空间的大小。</td>\n</tr>\n</tbody></table>\n<p>‍</p>\n<h3 id=\"二-常用SQL优化技巧\"><a href=\"#二-常用SQL优化技巧\" class=\"headerlink\" title=\"二 常用SQL优化技巧\"></a>二 常用SQL优化技巧</h3><ul>\n<li>索引优化，如果使用记录数较多的表的列，那么就要考虑在列上建索引</li>\n<li>避免全表扫描（Full Table Scan）</li>\n<li>优化查询条件，避免在列上进行函数操作</li>\n<li>使用覆盖索引，不用回表，减少IO操作</li>\n</ul>\n<p>‍</p>\n<h3 id=\"三-分析优化举例\"><a href=\"#三-分析优化举例\" class=\"headerlink\" title=\"三 分析优化举例\"></a>三 分析优化举例</h3><p>由于使用hibernate，在享受遍历性的同时，部分SQL常常被拼接的过于臃肿。下面这个SQL就是这样，其中查询字段重复包含了9个表的全部字段，大概有400多个，用省略号代替。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain analyze</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> this_.ID <span class=\"keyword\">AS</span> ID1_879_8_ ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> simple_workflow_record this_</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_employee erpemploye3_ <span class=\"keyword\">ON</span> this_.EMPLOYEEID <span class=\"operator\">=</span> erpemploye3_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco4_ <span class=\"keyword\">ON</span> erpemploye3_.LAST_JOB_REC_ID <span class=\"operator\">=</span> erpjobreco4_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco5_ <span class=\"keyword\">ON</span> erpemploye3_.LAST_WORK_REC_ID <span class=\"operator\">=</span> erpjobreco5_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_employee erpemploye6_ <span class=\"keyword\">ON</span> erpemploye3_.RELATIVES_EMPLOYEE_ID <span class=\"operator\">=</span> erpemploye6_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco7_ <span class=\"keyword\">ON</span> this_.JOB_RECORD_ID <span class=\"operator\">=</span> erpjobreco7_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> t_s_depart tsdepart8_ <span class=\"keyword\">ON</span> erpjobreco7_.DPT_ID <span class=\"operator\">=</span> tsdepart8_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job erpjobenti9_ <span class=\"keyword\">ON</span> erpjobreco7_.JOB_ID <span class=\"operator\">=</span> erpjobenti9_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> simple_workflow workflow1_ <span class=\"keyword\">ON</span> this_.WORKFLOW_ID <span class=\"operator\">=</span> workflow1_.ID</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> this_.EMPLOYEEID <span class=\"operator\">=</span> <span class=\"string\">&#x27;20190401003&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.PROCESS_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%20190401003%&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.CC_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%20190401003%&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> workflow1_.MATCH_KEYWORD <span class=\"operator\">&lt;&gt;</span> <span class=\"string\">&#x27;ErpSubsidyConfirmRecordEntity&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> this_.UPDATE_DATE <span class=\"keyword\">DESC</span>, this_.CREATE_DATE <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<p>大致优化分析及优化思路：</p>\n<blockquote>\n<p> 检查条件列是否建立索引，对于不能使用索引的，是否可以使用Tiflash优化（实际结果：非大表，非聚合而使用列取，优化不明显，大概在几十ms内）</p>\n</blockquote>\n<ul>\n<li>首次优化，大概从7s到2.5s，执行计划如下：</li>\n</ul>\n<p>​<img src=\"/images/assets/image-20240511180118-9ol9gj4.png\" alt=\"image\">​</p>\n<p>上面提到Hibernate的ENtity拼接导致了很多冗余字段，在执行计划中也展示出来： 只是抓取20条记录，实际却要处理300多M数据。因此，可以</p>\n<ol>\n<li>优化业务关联，省略无效JOIN</li>\n<li>根据业务情况，使用同名简短Entity（省去无效JOIN，省去冗余字段）</li>\n</ol>\n<p>优化后SQL为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> simple_workflow_record this_</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_employee erpemploye3_ <span class=\"keyword\">ON</span> this_.EMPLOYEEID <span class=\"operator\">=</span> erpemploye3_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco4_ <span class=\"keyword\">ON</span> erpemploye3_.LAST_JOB_REC_ID <span class=\"operator\">=</span> erpjobreco4_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> simple_workflow workflow1_ <span class=\"keyword\">ON</span> this_.WORKFLOW_ID <span class=\"operator\">=</span> workflow1_.ID</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> this_.EMPLOYEEID <span class=\"operator\">=</span> ?</span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.PROCESS_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> ?</span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.CC_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> ?</span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> workflow1_.MATCH_KEYWORD <span class=\"operator\">&lt;&gt;</span> ?</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> this_.UPDATE_DATE <span class=\"keyword\">DESC</span>, this_.CREATE_DATE <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT ?;</span><br></pre></td></tr></table></figure>\n\n<p>最终优化后执行耗时460ms，执行计划如下：</p>\n<p>​<img src=\"/images/assets/image-20240513172430-zijsvdp.png\" alt=\"image\">​</p>\n<p>‍</p>\n<ul>\n<li>ANALYZE TABLE</li>\n</ul>\n<p>ANALYZE 语句用于更新 TiDB 在表和索引上留下的统计信息。执行大批量更新或导入记录后，或查询执行计划不是最佳时，建议运行 ANALYZE。<br>当 TiDB 逐渐发现这些统计数据与预估不一致时，也会自动更新其统计数据。</p>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>Tidb中想知道SQL在数据库中是怎么执行的，可以和Mysql中一样，使用 EXPLAIN 关键字。</p>","more":"<p>和Mysql不一样的是，Tidb早期版本宣传支持的Mysql版本是5.7（Tidb7.4以后正式支持Mysql8.0）。<br>但是Mysql8.0中的 EXPLAIN ANALYZE关键字，在TIdb的早期版本中也时支持的。与<code>EXPLAIN</code>​不会执行SQL不同，<code>EXPLAIN ANALYZE</code>​会执行对应的 SQL 语句，记录其运行时信息，和执行计划一并返回出来。它的输出格式和Mysql8.0中差异较大。<br>实际应用中，我们一般使用<code>EXPLAIN ANALYZE</code>​显示更多的物理执行信息来优化SQL。</p>\n<h3 id=\"一-EXPLAIN-ANALYZE列含义\"><a href=\"#一-EXPLAIN-ANALYZE列含义\" class=\"headerlink\" title=\"一 EXPLAIN ANALYZE列含义\"></a>一 EXPLAIN ANALYZE列含义</h3><p>‍</p>\n<p>​<code>EXPLAIN ANALYZE</code>​查询执行计划列含义：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性名</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">id</td>\n<td align=\"left\">算子名，或执行 SQL 语句需要执行的子任务</td>\n</tr>\n<tr>\n<td align=\"left\">estRows</td>\n<td align=\"left\">iDB 预计会处理的行数</td>\n</tr>\n<tr>\n<td align=\"left\">task</td>\n<td align=\"left\">算子位置，cop(TiKV或TiFlash)和 root (Tidb)</td>\n</tr>\n<tr>\n<td align=\"left\">access-object</td>\n<td align=\"left\">显示被访问的表、分区和索引</td>\n</tr>\n<tr>\n<td align=\"left\">operator info</td>\n<td align=\"left\">列可显示诸如条件下推等信息</td>\n</tr>\n<tr>\n<td align=\"left\">actRows</td>\n<td align=\"left\">算子实际输出的数据条数。</td>\n</tr>\n<tr>\n<td align=\"left\">execution info</td>\n<td align=\"left\">算子的实际执行信息。time 表示从进入算子到离开算子的全部 wall time，包括所有子算子操作的全部执行时间。如果该算子被父算子多次调用 (loops)，这个时间就是累积的时间。loops 是当前算子被父算子调用的次数。</td>\n</tr>\n<tr>\n<td align=\"left\">memory</td>\n<td align=\"left\">算子占用内存空间的大小。</td>\n</tr>\n<tr>\n<td align=\"left\">disk</td>\n<td align=\"left\">算子占用磁盘空间的大小。</td>\n</tr>\n</tbody></table>\n<p>‍</p>\n<h3 id=\"二-常用SQL优化技巧\"><a href=\"#二-常用SQL优化技巧\" class=\"headerlink\" title=\"二 常用SQL优化技巧\"></a>二 常用SQL优化技巧</h3><ul>\n<li>索引优化，如果使用记录数较多的表的列，那么就要考虑在列上建索引</li>\n<li>避免全表扫描（Full Table Scan）</li>\n<li>优化查询条件，避免在列上进行函数操作</li>\n<li>使用覆盖索引，不用回表，减少IO操作</li>\n</ul>\n<p>‍</p>\n<h3 id=\"三-分析优化举例\"><a href=\"#三-分析优化举例\" class=\"headerlink\" title=\"三 分析优化举例\"></a>三 分析优化举例</h3><p>由于使用hibernate，在享受遍历性的同时，部分SQL常常被拼接的过于臃肿。下面这个SQL就是这样，其中查询字段重复包含了9个表的全部字段，大概有400多个，用省略号代替。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain analyze</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> this_.ID <span class=\"keyword\">AS</span> ID1_879_8_ ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> simple_workflow_record this_</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_employee erpemploye3_ <span class=\"keyword\">ON</span> this_.EMPLOYEEID <span class=\"operator\">=</span> erpemploye3_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco4_ <span class=\"keyword\">ON</span> erpemploye3_.LAST_JOB_REC_ID <span class=\"operator\">=</span> erpjobreco4_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco5_ <span class=\"keyword\">ON</span> erpemploye3_.LAST_WORK_REC_ID <span class=\"operator\">=</span> erpjobreco5_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_employee erpemploye6_ <span class=\"keyword\">ON</span> erpemploye3_.RELATIVES_EMPLOYEE_ID <span class=\"operator\">=</span> erpemploye6_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco7_ <span class=\"keyword\">ON</span> this_.JOB_RECORD_ID <span class=\"operator\">=</span> erpjobreco7_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> t_s_depart tsdepart8_ <span class=\"keyword\">ON</span> erpjobreco7_.DPT_ID <span class=\"operator\">=</span> tsdepart8_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job erpjobenti9_ <span class=\"keyword\">ON</span> erpjobreco7_.JOB_ID <span class=\"operator\">=</span> erpjobenti9_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> simple_workflow workflow1_ <span class=\"keyword\">ON</span> this_.WORKFLOW_ID <span class=\"operator\">=</span> workflow1_.ID</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> this_.EMPLOYEEID <span class=\"operator\">=</span> <span class=\"string\">&#x27;20190401003&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.PROCESS_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%20190401003%&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.CC_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%20190401003%&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> workflow1_.MATCH_KEYWORD <span class=\"operator\">&lt;&gt;</span> <span class=\"string\">&#x27;ErpSubsidyConfirmRecordEntity&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> this_.UPDATE_DATE <span class=\"keyword\">DESC</span>, this_.CREATE_DATE <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<p>大致优化分析及优化思路：</p>\n<blockquote>\n<p> 检查条件列是否建立索引，对于不能使用索引的，是否可以使用Tiflash优化（实际结果：非大表，非聚合而使用列取，优化不明显，大概在几十ms内）</p>\n</blockquote>\n<ul>\n<li>首次优化，大概从7s到2.5s，执行计划如下：</li>\n</ul>\n<p>​<img src=\"/images/assets/image-20240511180118-9ol9gj4.png\" alt=\"image\">​</p>\n<p>上面提到Hibernate的ENtity拼接导致了很多冗余字段，在执行计划中也展示出来： 只是抓取20条记录，实际却要处理300多M数据。因此，可以</p>\n<ol>\n<li>优化业务关联，省略无效JOIN</li>\n<li>根据业务情况，使用同名简短Entity（省去无效JOIN，省去冗余字段）</li>\n</ol>\n<p>优化后SQL为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> simple_workflow_record this_</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_employee erpemploye3_ <span class=\"keyword\">ON</span> this_.EMPLOYEEID <span class=\"operator\">=</span> erpemploye3_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> erp_job_record erpjobreco4_ <span class=\"keyword\">ON</span> erpemploye3_.LAST_JOB_REC_ID <span class=\"operator\">=</span> erpjobreco4_.ID</span><br><span class=\"line\">\t<span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> simple_workflow workflow1_ <span class=\"keyword\">ON</span> this_.WORKFLOW_ID <span class=\"operator\">=</span> workflow1_.ID</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> this_.EMPLOYEEID <span class=\"operator\">=</span> ?</span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.PROCESS_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> ?</span><br><span class=\"line\">\t<span class=\"keyword\">OR</span> this_.CC_EMPLOYEE_IDS <span class=\"keyword\">LIKE</span> ?</span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> workflow1_.MATCH_KEYWORD <span class=\"operator\">&lt;&gt;</span> ?</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> this_.UPDATE_DATE <span class=\"keyword\">DESC</span>, this_.CREATE_DATE <span class=\"keyword\">DESC</span></span><br><span class=\"line\">LIMIT ?;</span><br></pre></td></tr></table></figure>\n\n<p>最终优化后执行耗时460ms，执行计划如下：</p>\n<p>​<img src=\"/images/assets/image-20240513172430-zijsvdp.png\" alt=\"image\">​</p>\n<p>‍</p>\n<ul>\n<li>ANALYZE TABLE</li>\n</ul>\n<p>ANALYZE 语句用于更新 TiDB 在表和索引上留下的统计信息。执行大批量更新或导入记录后，或查询执行计划不是最佳时，建议运行 ANALYZE。<br>当 TiDB 逐渐发现这些统计数据与预估不一致时，也会自动更新其统计数据。</p>\n<p>‍</p>"},{"title":"SpringEvent应用","date":"2024-04-29T02:32:14.000Z","_content":"让复杂业务解耦，让代码同时保持健壮与优雅是每个coder不懈的追求。或许你会直接上消息队列，可是\n<!--more-->\n\n# Spring event\n\n# 一  使用\n\n基本使用很简单，定义事件A，注册一个对A的监听器，然后发布这个事件。示意图如下：\n\n​![image](/images/assets/image-20240430164433-bng4qnr.png)​\n\n具体代码和步骤：\n\n1. 定义事件\n\n    ```java\n    import org.springframework.context.ApplicationEvent;\n    public class MyEvent extends ApplicationEvent {\n        private String name;\n\n        public MyEvent(Object source, String name) {\n            super(source);\n            this.name = name;\n        }\n    }\n    ```\n2. 注册一个监听器\n\n    ```java\n    @Component\n    public class MyEventListener implements ApplicationListener<MyEvent> {\n        @Override\n        public void onApplicationEvent(MyEvent event) {\n            System.out.println(\"event = \" + event);\n        }\n    }\n    ```\n3. 定义自己的上下文\n\n    ```java\n    import org.springframework.beans.BeansException;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.ApplicationContextAware;\n    import org.springframework.stereotype.Component;\n\n    @Component\n    public class ApplicationContextProvider implements ApplicationContextAware {\n\n        private static ApplicationContext context;\n\n        @Override\n        public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n            context = applicationContext;\n        }\n\n        public static ApplicationContext getContext() {\n            return context;\n        }\n    }\n    ```\n\n4. 发布事件\n\n    ```java\n    // 在需要调用的地方\n     ApplicationContextProvider.getApplicationContext().publishEvent(new MyEvent(\"Source\", \"enventName\"));\n    ```\n\n# 二 源码分析\n\nspringEvent使用基本可以两步， 注册 + 发布，核心代码其实都在 ApplicationEventMulticaster 类\n\n关键类：\n\n1. ApplicationListener （监听）\n2. ApplicationEventPublisher （发布）\n3. ApplicationEventMulticaster （管理）\n\n‍\n\n### 注册\n\n基本有两种便利的实现方式：1，实现实现ApplicationListener接口 ； 2，定义Bean中的方法，并使用EventListener注解\n\n* 实现ApplicationListener方式注册\n\n  ```java\n  // org.springframework.context.support.ApplicationListenerDetector#postProcessAfterInitialization\n  // 后置处理所有的ApplicationListener\n  \t@Override\n  \tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n  \t\tif (bean instanceof ApplicationListener) {\n  \t\t\tBoolean flag = this.singletonNames.get(beanName);\n  \t\t\tif (Boolean.TRUE.equals(flag)) {\n  \t\t\t\t// 注册，最终调用是 this.applicationEventMulticaster.addApplicationListener(listener)\n  \t\t\t\t// ApplicationEventMulticaster是SpringEvent的管理类\n  \t\t\t\tthis.applicationContext.addApplicationListener((ApplicationListener<?>) bean);\n  \t\t\t}\n  \t\t\telse if (Boolean.FALSE.equals(flag)) {\n  \t\t\t\t// 不支持非单例Bean\n  \t\t\t}\n  \t\t}\n  \t\treturn bean;\n  \t}\n  ```\n\n‍\n\n* 基于注解@EventListener的注册\n\n  ```java\n\n  // org.springframework.context.event.EventListenerMethodProcessor#processBean\n\n  \tprivate void processBean(final String beanName, final Class<?> targetType) {\n  \t\t// 获取有EventListener注解的方法\n  \t\tMap<Method, EventListener> annotatedMethods = MethodIntrospector.selectMethods(targetType,\n  \t\t(MethodIntrospector.MetadataLookup<EventListener>) method -> AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));\n  \t\tConfigurableApplicationContext context = this.applicationContext;\n  \t\t// 所有\n  \t\tList<EventListenerFactory> factories = this.eventListenerFactories;\n  \t\tfor (Method method : annotatedMethods.keySet()) {\n  \t\t\tfor (EventListenerFactory factory : factories) {\n  \t\t\t\tif (factory.supportsMethod(method)) {\n  \t\t\t\t\tMethod methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));\n  \t\t\t\t\t// 将方法封装成ApplicationListenerMethodAdapter\n  \t\t\t\t\tApplicationListener<?> applicationListener =\n  \t\t\t\t\t\t\tfactory.createApplicationListener(beanName, targetType, methodToUse);\n  \t\t\t\t\tif (applicationListener instanceof ApplicationListenerMethodAdapter) {\n  \t\t\t\t\t\t((ApplicationListenerMethodAdapter) applicationListener).init(context, this.evaluator);\n  \t\t\t\t\t}\n  \t\t\t\t\t// 注册到ApplicationContext，同上面使用方法注解一致\n  \t\t\t\t\tcontext.addApplicationListener(applicationListener);\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  ```\n\n‍\n\n### 发布\n\n```java\n// 发布调用\n// org.springframework.context.support.AbstractApplicationContext#publishEvent(java.lang.Object, org.springframework.core.ResolvableType)\n\t// 核心是调用ApplicationEventMulticaster的多播方法\n\tgetApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);\n\n// org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)\n\n\t@Override\n\tpublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {\n\t\t// 事件类型转换为ResolvableType \n\t\tResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n\t\t// 如果不指定执行器，那么就是顺序执行，可能会阻塞\n\t\t// 可以自定义SimpleApplicationEventMulticaster，通过线程池来异步执行\n\t\tExecutor executor = getTaskExecutor();\n\t\t// 通过事件类型寻找监听器，有缓存优化\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.execute(() -> invokeListener(listener, event));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinvokeListener(listener, event);\n\t\t\t}\n\t\t}\n\t}\n\n\n```\n\n‍\n\n# 三、注意事项\n\n1. 可以从源码看到，SpringEvent是依赖SpringIOC的，在启动（init）和关闭（destroy）阶段，不要使用\n2. 如果不指定事件类型，会接受都爱全部事件。SpringBoot中自有事件依照启动顺序依次有：\n\n    1. ServletWebServerInitializedEvent\n    2. ContextRefreshedEvent\n    3. ApplicationStartedEvent\n    4. AvailabilityChangeEvent\n    5. ApplicationReadyEvent\n3. SpringEvent默认顺序执行，如果外层有事务，Event中异常可能会导致事务回滚。因此建议使用线程池来异步执行事件。自定义线程池方法：\n\n    ```java\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.event.SimpleApplicationEventMulticaster;\n    import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\n    @Configuration\n    public class EventConfig {\n        @Bean\n        SimpleApplicationEventMulticaster applicationEventMulticaster() {\n            SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();\n            ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n            //核心线程池数量\n            executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());\n            //最大线程数量\n            executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 5);\n            //线程池的队列容量\n            executor.setQueueCapacity(Runtime.getRuntime().availableProcessors() * 2);\n            //线程名称的前缀\n            executor.setThreadNamePrefix(\"springEvent-executor-\");\n            executor.initialize();\n            multicaster.setTaskExecutor(executor);\n            return multicaster;\n        }\n    }\n    ```\n\n4. SpringEvent适用于最终一致性，如果需要重试，推荐[Spring-retry](https://springdoc.cn/spring-retry-guide/)\n\n‍","source":"_posts/SpringEvent应用.md","raw":"---\ntitle: SpringEvent应用\ndate: 2024-04-29 10:32:14\ntags: spring event\ncategories: Spring+\n---\n让复杂业务解耦，让代码同时保持健壮与优雅是每个coder不懈的追求。或许你会直接上消息队列，可是\n<!--more-->\n\n# Spring event\n\n# 一  使用\n\n基本使用很简单，定义事件A，注册一个对A的监听器，然后发布这个事件。示意图如下：\n\n​![image](/images/assets/image-20240430164433-bng4qnr.png)​\n\n具体代码和步骤：\n\n1. 定义事件\n\n    ```java\n    import org.springframework.context.ApplicationEvent;\n    public class MyEvent extends ApplicationEvent {\n        private String name;\n\n        public MyEvent(Object source, String name) {\n            super(source);\n            this.name = name;\n        }\n    }\n    ```\n2. 注册一个监听器\n\n    ```java\n    @Component\n    public class MyEventListener implements ApplicationListener<MyEvent> {\n        @Override\n        public void onApplicationEvent(MyEvent event) {\n            System.out.println(\"event = \" + event);\n        }\n    }\n    ```\n3. 定义自己的上下文\n\n    ```java\n    import org.springframework.beans.BeansException;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.ApplicationContextAware;\n    import org.springframework.stereotype.Component;\n\n    @Component\n    public class ApplicationContextProvider implements ApplicationContextAware {\n\n        private static ApplicationContext context;\n\n        @Override\n        public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n            context = applicationContext;\n        }\n\n        public static ApplicationContext getContext() {\n            return context;\n        }\n    }\n    ```\n\n4. 发布事件\n\n    ```java\n    // 在需要调用的地方\n     ApplicationContextProvider.getApplicationContext().publishEvent(new MyEvent(\"Source\", \"enventName\"));\n    ```\n\n# 二 源码分析\n\nspringEvent使用基本可以两步， 注册 + 发布，核心代码其实都在 ApplicationEventMulticaster 类\n\n关键类：\n\n1. ApplicationListener （监听）\n2. ApplicationEventPublisher （发布）\n3. ApplicationEventMulticaster （管理）\n\n‍\n\n### 注册\n\n基本有两种便利的实现方式：1，实现实现ApplicationListener接口 ； 2，定义Bean中的方法，并使用EventListener注解\n\n* 实现ApplicationListener方式注册\n\n  ```java\n  // org.springframework.context.support.ApplicationListenerDetector#postProcessAfterInitialization\n  // 后置处理所有的ApplicationListener\n  \t@Override\n  \tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n  \t\tif (bean instanceof ApplicationListener) {\n  \t\t\tBoolean flag = this.singletonNames.get(beanName);\n  \t\t\tif (Boolean.TRUE.equals(flag)) {\n  \t\t\t\t// 注册，最终调用是 this.applicationEventMulticaster.addApplicationListener(listener)\n  \t\t\t\t// ApplicationEventMulticaster是SpringEvent的管理类\n  \t\t\t\tthis.applicationContext.addApplicationListener((ApplicationListener<?>) bean);\n  \t\t\t}\n  \t\t\telse if (Boolean.FALSE.equals(flag)) {\n  \t\t\t\t// 不支持非单例Bean\n  \t\t\t}\n  \t\t}\n  \t\treturn bean;\n  \t}\n  ```\n\n‍\n\n* 基于注解@EventListener的注册\n\n  ```java\n\n  // org.springframework.context.event.EventListenerMethodProcessor#processBean\n\n  \tprivate void processBean(final String beanName, final Class<?> targetType) {\n  \t\t// 获取有EventListener注解的方法\n  \t\tMap<Method, EventListener> annotatedMethods = MethodIntrospector.selectMethods(targetType,\n  \t\t(MethodIntrospector.MetadataLookup<EventListener>) method -> AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));\n  \t\tConfigurableApplicationContext context = this.applicationContext;\n  \t\t// 所有\n  \t\tList<EventListenerFactory> factories = this.eventListenerFactories;\n  \t\tfor (Method method : annotatedMethods.keySet()) {\n  \t\t\tfor (EventListenerFactory factory : factories) {\n  \t\t\t\tif (factory.supportsMethod(method)) {\n  \t\t\t\t\tMethod methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));\n  \t\t\t\t\t// 将方法封装成ApplicationListenerMethodAdapter\n  \t\t\t\t\tApplicationListener<?> applicationListener =\n  \t\t\t\t\t\t\tfactory.createApplicationListener(beanName, targetType, methodToUse);\n  \t\t\t\t\tif (applicationListener instanceof ApplicationListenerMethodAdapter) {\n  \t\t\t\t\t\t((ApplicationListenerMethodAdapter) applicationListener).init(context, this.evaluator);\n  \t\t\t\t\t}\n  \t\t\t\t\t// 注册到ApplicationContext，同上面使用方法注解一致\n  \t\t\t\t\tcontext.addApplicationListener(applicationListener);\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  ```\n\n‍\n\n### 发布\n\n```java\n// 发布调用\n// org.springframework.context.support.AbstractApplicationContext#publishEvent(java.lang.Object, org.springframework.core.ResolvableType)\n\t// 核心是调用ApplicationEventMulticaster的多播方法\n\tgetApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);\n\n// org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)\n\n\t@Override\n\tpublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {\n\t\t// 事件类型转换为ResolvableType \n\t\tResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n\t\t// 如果不指定执行器，那么就是顺序执行，可能会阻塞\n\t\t// 可以自定义SimpleApplicationEventMulticaster，通过线程池来异步执行\n\t\tExecutor executor = getTaskExecutor();\n\t\t// 通过事件类型寻找监听器，有缓存优化\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.execute(() -> invokeListener(listener, event));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinvokeListener(listener, event);\n\t\t\t}\n\t\t}\n\t}\n\n\n```\n\n‍\n\n# 三、注意事项\n\n1. 可以从源码看到，SpringEvent是依赖SpringIOC的，在启动（init）和关闭（destroy）阶段，不要使用\n2. 如果不指定事件类型，会接受都爱全部事件。SpringBoot中自有事件依照启动顺序依次有：\n\n    1. ServletWebServerInitializedEvent\n    2. ContextRefreshedEvent\n    3. ApplicationStartedEvent\n    4. AvailabilityChangeEvent\n    5. ApplicationReadyEvent\n3. SpringEvent默认顺序执行，如果外层有事务，Event中异常可能会导致事务回滚。因此建议使用线程池来异步执行事件。自定义线程池方法：\n\n    ```java\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.event.SimpleApplicationEventMulticaster;\n    import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\n    @Configuration\n    public class EventConfig {\n        @Bean\n        SimpleApplicationEventMulticaster applicationEventMulticaster() {\n            SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();\n            ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n            //核心线程池数量\n            executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());\n            //最大线程数量\n            executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 5);\n            //线程池的队列容量\n            executor.setQueueCapacity(Runtime.getRuntime().availableProcessors() * 2);\n            //线程名称的前缀\n            executor.setThreadNamePrefix(\"springEvent-executor-\");\n            executor.initialize();\n            multicaster.setTaskExecutor(executor);\n            return multicaster;\n        }\n    }\n    ```\n\n4. SpringEvent适用于最终一致性，如果需要重试，推荐[Spring-retry](https://springdoc.cn/spring-retry-guide/)\n\n‍","slug":"SpringEvent应用","published":1,"updated":"2024-05-07T07:04:00.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz3001tqwvd64aohyrr","content":"<p>让复杂业务解耦，让代码同时保持健壮与优雅是每个coder不懈的追求。或许你会直接上消息队列，可是</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Spring-event\"><a href=\"#Spring-event\" class=\"headerlink\" title=\"Spring event\"></a>Spring event</h1><h1 id=\"一-使用\"><a href=\"#一-使用\" class=\"headerlink\" title=\"一  使用\"></a>一  使用</h1><p>基本使用很简单，定义事件A，注册一个对A的监听器，然后发布这个事件。示意图如下：</p>\n<p>​<img src=\"/images/assets/image-20240430164433-bng4qnr.png\" alt=\"image\">​</p>\n<p>具体代码和步骤：</p>\n<ol>\n<li><p>定义事件</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationEvent;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEvent</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationEvent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyEvent</span><span class=\"params\">(Object source, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(source);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>注册一个监听器</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEventListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">MyEvent</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(MyEvent event)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;event = &quot;</span> + event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>定义自己的上下文</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextProvider</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">        context = applicationContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布事件</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在需要调用的地方</span></span><br><span class=\"line\"> ApplicationContextProvider.getApplicationContext().publishEvent(<span class=\"keyword\">new</span> MyEvent(<span class=\"string\">&quot;Source&quot;</span>, <span class=\"string\">&quot;enventName&quot;</span>));</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"二-源码分析\"><a href=\"#二-源码分析\" class=\"headerlink\" title=\"二 源码分析\"></a>二 源码分析</h1><p>springEvent使用基本可以两步， 注册 + 发布，核心代码其实都在 ApplicationEventMulticaster 类</p>\n<p>关键类：</p>\n<ol>\n<li>ApplicationListener （监听）</li>\n<li>ApplicationEventPublisher （发布）</li>\n<li>ApplicationEventMulticaster （管理）</li>\n</ol>\n<p>‍</p>\n<h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>基本有两种便利的实现方式：1，实现实现ApplicationListener接口 ； 2，定义Bean中的方法，并使用EventListener注解</p>\n<ul>\n<li><p>实现ApplicationListener方式注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.springframework.context.support.ApplicationListenerDetector#postProcessAfterInitialization</span></span><br><span class=\"line\"><span class=\"comment\">// 后置处理所有的ApplicationListener</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> ApplicationListener) &#123;</span><br><span class=\"line\">\t\t\tBoolean flag = <span class=\"keyword\">this</span>.singletonNames.get(beanName);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (Boolean.TRUE.equals(flag)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 注册，最终调用是 this.applicationEventMulticaster.addApplicationListener(listener)</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// ApplicationEventMulticaster是SpringEvent的管理类</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Boolean.FALSE.equals(flag)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 不支持非单例Bean</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>‍</p>\n<ul>\n<li><p>基于注解@EventListener的注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.springframework.context.event.EventListenerMethodProcessor#processBean</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processBean</span><span class=\"params\">(<span class=\"keyword\">final</span> String beanName, <span class=\"keyword\">final</span> Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取有EventListener注解的方法</span></span><br><span class=\"line\">\t\tMap&lt;Method, EventListener&gt; annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class=\"line\">\t\t(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class=\"line\">\t\tConfigurableApplicationContext context = <span class=\"keyword\">this</span>.applicationContext;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 所有</span></span><br><span class=\"line\">\t\tList&lt;EventListenerFactory&gt; factories = <span class=\"keyword\">this</span>.eventListenerFactories;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class=\"line\">\t\t\t\t\tMethod methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将方法封装成ApplicationListenerMethodAdapter</span></span><br><span class=\"line\">\t\t\t\t\tApplicationListener&lt;?&gt; applicationListener =</span><br><span class=\"line\">\t\t\t\t\t\t\tfactory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (applicationListener <span class=\"keyword\">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class=\"keyword\">this</span>.evaluator);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 注册到ApplicationContext，同上面使用方法注解一致</span></span><br><span class=\"line\">\t\t\t\t\tcontext.addApplicationListener(applicationListener);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>‍</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发布调用</span></span><br><span class=\"line\"><span class=\"comment\">// org.springframework.context.support.AbstractApplicationContext#publishEvent(java.lang.Object, org.springframework.core.ResolvableType)</span></span><br><span class=\"line\">\t<span class=\"comment\">// 核心是调用ApplicationEventMulticaster的多播方法</span></span><br><span class=\"line\">\tgetApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">multicastEvent</span><span class=\"params\">(<span class=\"keyword\">final</span> ApplicationEvent event, <span class=\"meta\">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 事件类型转换为ResolvableType </span></span><br><span class=\"line\">\t\tResolvableType type = (eventType != <span class=\"keyword\">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果不指定执行器，那么就是顺序执行，可能会阻塞</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 可以自定义SimpleApplicationEventMulticaster，通过线程池来异步执行</span></span><br><span class=\"line\">\t\tExecutor executor = getTaskExecutor();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过事件类型寻找监听器，有缓存优化</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (executor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\texecutor.execute(() -&gt; invokeListener(listener, event));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tinvokeListener(listener, event);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h1 id=\"三、注意事项\"><a href=\"#三、注意事项\" class=\"headerlink\" title=\"三、注意事项\"></a>三、注意事项</h1><ol>\n<li><p>可以从源码看到，SpringEvent是依赖SpringIOC的，在启动（init）和关闭（destroy）阶段，不要使用</p>\n</li>\n<li><p>如果不指定事件类型，会接受都爱全部事件。SpringBoot中自有事件依照启动顺序依次有：</p>\n<ol>\n<li>ServletWebServerInitializedEvent</li>\n<li>ContextRefreshedEvent</li>\n<li>ApplicationStartedEvent</li>\n<li>AvailabilityChangeEvent</li>\n<li>ApplicationReadyEvent</li>\n</ol>\n</li>\n<li><p>SpringEvent默认顺序执行，如果外层有事务，Event中异常可能会导致事务回滚。因此建议使用线程池来异步执行事件。自定义线程池方法：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.event.SimpleApplicationEventMulticaster;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">SimpleApplicationEventMulticaster <span class=\"title\">applicationEventMulticaster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SimpleApplicationEventMulticaster multicaster = <span class=\"keyword\">new</span> SimpleApplicationEventMulticaster();</span><br><span class=\"line\">        ThreadPoolTaskExecutor executor = <span class=\"keyword\">new</span> ThreadPoolTaskExecutor();</span><br><span class=\"line\">        <span class=\"comment\">//核心线程池数量</span></span><br><span class=\"line\">        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        <span class=\"comment\">//最大线程数量</span></span><br><span class=\"line\">        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//线程池的队列容量</span></span><br><span class=\"line\">        executor.setQueueCapacity(Runtime.getRuntime().availableProcessors() * <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//线程名称的前缀</span></span><br><span class=\"line\">        executor.setThreadNamePrefix(<span class=\"string\">&quot;springEvent-executor-&quot;</span>);</span><br><span class=\"line\">        executor.initialize();</span><br><span class=\"line\">        multicaster.setTaskExecutor(executor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> multicaster;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SpringEvent适用于最终一致性，如果需要重试，推荐<a href=\"https://springdoc.cn/spring-retry-guide/\">Spring-retry</a></p>\n</li>\n</ol>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>让复杂业务解耦，让代码同时保持健壮与优雅是每个coder不懈的追求。或许你会直接上消息队列，可是</p>","more":"<h1 id=\"Spring-event\"><a href=\"#Spring-event\" class=\"headerlink\" title=\"Spring event\"></a>Spring event</h1><h1 id=\"一-使用\"><a href=\"#一-使用\" class=\"headerlink\" title=\"一  使用\"></a>一  使用</h1><p>基本使用很简单，定义事件A，注册一个对A的监听器，然后发布这个事件。示意图如下：</p>\n<p>​<img src=\"/images/assets/image-20240430164433-bng4qnr.png\" alt=\"image\">​</p>\n<p>具体代码和步骤：</p>\n<ol>\n<li><p>定义事件</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationEvent;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEvent</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationEvent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyEvent</span><span class=\"params\">(Object source, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(source);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>注册一个监听器</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEventListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">MyEvent</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(MyEvent event)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;event = &quot;</span> + event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>定义自己的上下文</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationContextProvider</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ApplicationContext context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">        context = applicationContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ApplicationContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布事件</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在需要调用的地方</span></span><br><span class=\"line\"> ApplicationContextProvider.getApplicationContext().publishEvent(<span class=\"keyword\">new</span> MyEvent(<span class=\"string\">&quot;Source&quot;</span>, <span class=\"string\">&quot;enventName&quot;</span>));</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"二-源码分析\"><a href=\"#二-源码分析\" class=\"headerlink\" title=\"二 源码分析\"></a>二 源码分析</h1><p>springEvent使用基本可以两步， 注册 + 发布，核心代码其实都在 ApplicationEventMulticaster 类</p>\n<p>关键类：</p>\n<ol>\n<li>ApplicationListener （监听）</li>\n<li>ApplicationEventPublisher （发布）</li>\n<li>ApplicationEventMulticaster （管理）</li>\n</ol>\n<p>‍</p>\n<h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>基本有两种便利的实现方式：1，实现实现ApplicationListener接口 ； 2，定义Bean中的方法，并使用EventListener注解</p>\n<ul>\n<li><p>实现ApplicationListener方式注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.springframework.context.support.ApplicationListenerDetector#postProcessAfterInitialization</span></span><br><span class=\"line\"><span class=\"comment\">// 后置处理所有的ApplicationListener</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> ApplicationListener) &#123;</span><br><span class=\"line\">\t\t\tBoolean flag = <span class=\"keyword\">this</span>.singletonNames.get(beanName);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (Boolean.TRUE.equals(flag)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 注册，最终调用是 this.applicationEventMulticaster.addApplicationListener(listener)</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// ApplicationEventMulticaster是SpringEvent的管理类</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Boolean.FALSE.equals(flag)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 不支持非单例Bean</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>‍</p>\n<ul>\n<li><p>基于注解@EventListener的注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.springframework.context.event.EventListenerMethodProcessor#processBean</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processBean</span><span class=\"params\">(<span class=\"keyword\">final</span> String beanName, <span class=\"keyword\">final</span> Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取有EventListener注解的方法</span></span><br><span class=\"line\">\t\tMap&lt;Method, EventListener&gt; annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class=\"line\">\t\t(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class=\"line\">\t\tConfigurableApplicationContext context = <span class=\"keyword\">this</span>.applicationContext;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 所有</span></span><br><span class=\"line\">\t\tList&lt;EventListenerFactory&gt; factories = <span class=\"keyword\">this</span>.eventListenerFactories;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class=\"line\">\t\t\t\t\tMethod methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将方法封装成ApplicationListenerMethodAdapter</span></span><br><span class=\"line\">\t\t\t\t\tApplicationListener&lt;?&gt; applicationListener =</span><br><span class=\"line\">\t\t\t\t\t\t\tfactory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (applicationListener <span class=\"keyword\">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class=\"keyword\">this</span>.evaluator);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 注册到ApplicationContext，同上面使用方法注解一致</span></span><br><span class=\"line\">\t\t\t\t\tcontext.addApplicationListener(applicationListener);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>‍</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发布调用</span></span><br><span class=\"line\"><span class=\"comment\">// org.springframework.context.support.AbstractApplicationContext#publishEvent(java.lang.Object, org.springframework.core.ResolvableType)</span></span><br><span class=\"line\">\t<span class=\"comment\">// 核心是调用ApplicationEventMulticaster的多播方法</span></span><br><span class=\"line\">\tgetApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">multicastEvent</span><span class=\"params\">(<span class=\"keyword\">final</span> ApplicationEvent event, <span class=\"meta\">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 事件类型转换为ResolvableType </span></span><br><span class=\"line\">\t\tResolvableType type = (eventType != <span class=\"keyword\">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果不指定执行器，那么就是顺序执行，可能会阻塞</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 可以自定义SimpleApplicationEventMulticaster，通过线程池来异步执行</span></span><br><span class=\"line\">\t\tExecutor executor = getTaskExecutor();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过事件类型寻找监听器，有缓存优化</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (executor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\texecutor.execute(() -&gt; invokeListener(listener, event));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tinvokeListener(listener, event);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h1 id=\"三、注意事项\"><a href=\"#三、注意事项\" class=\"headerlink\" title=\"三、注意事项\"></a>三、注意事项</h1><ol>\n<li><p>可以从源码看到，SpringEvent是依赖SpringIOC的，在启动（init）和关闭（destroy）阶段，不要使用</p>\n</li>\n<li><p>如果不指定事件类型，会接受都爱全部事件。SpringBoot中自有事件依照启动顺序依次有：</p>\n<ol>\n<li>ServletWebServerInitializedEvent</li>\n<li>ContextRefreshedEvent</li>\n<li>ApplicationStartedEvent</li>\n<li>AvailabilityChangeEvent</li>\n<li>ApplicationReadyEvent</li>\n</ol>\n</li>\n<li><p>SpringEvent默认顺序执行，如果外层有事务，Event中异常可能会导致事务回滚。因此建议使用线程池来异步执行事件。自定义线程池方法：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.event.SimpleApplicationEventMulticaster;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">SimpleApplicationEventMulticaster <span class=\"title\">applicationEventMulticaster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SimpleApplicationEventMulticaster multicaster = <span class=\"keyword\">new</span> SimpleApplicationEventMulticaster();</span><br><span class=\"line\">        ThreadPoolTaskExecutor executor = <span class=\"keyword\">new</span> ThreadPoolTaskExecutor();</span><br><span class=\"line\">        <span class=\"comment\">//核心线程池数量</span></span><br><span class=\"line\">        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        <span class=\"comment\">//最大线程数量</span></span><br><span class=\"line\">        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//线程池的队列容量</span></span><br><span class=\"line\">        executor.setQueueCapacity(Runtime.getRuntime().availableProcessors() * <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//线程名称的前缀</span></span><br><span class=\"line\">        executor.setThreadNamePrefix(<span class=\"string\">&quot;springEvent-executor-&quot;</span>);</span><br><span class=\"line\">        executor.initialize();</span><br><span class=\"line\">        multicaster.setTaskExecutor(executor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> multicaster;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SpringEvent适用于最终一致性，如果需要重试，推荐<a href=\"https://springdoc.cn/spring-retry-guide/\">Spring-retry</a></p>\n</li>\n</ol>\n<p>‍</p>"},{"title":"dataX-异构数据离线同步","date":"2023-12-19T06:30:00.000Z","_content":"如果要实现不同数据库之前的数据同步，应该怎么做？直接执行sql文件，如果语法不兼容呢？dataX是一个阿里开源的，被广泛使用的离线数据同步的工具，通过各类插件的reader/writer兼容了各类数据的整合。可实现自定义全量/增量的数据同步。\n<!--more-->\n用一个示意图来理解dataX干的事情，就是  \n![](https://cloud.githubusercontent.com/assets/1067175/17879841/93b7fc1c-6927-11e6-8cda-7cf8420fc65f.png)\n\n> （百度到的一般都是阿里的商业版，而且也都是界面操作的文档。如果是开源版使用的话， 还是自行 quickStart 吧）  \nhttps://github.com/alibaba/DataX/blob/master/userGuid.md\n\n\n## 1. quickStart\n以下以Mysql同步到postgresql为例说明。\n\n### 检查环境配置\n``` \nJDK1.8+\nPython\nMaven3\n```\n\n### 编辑Job配置\n```\n{\n  \"job\": {\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"connection\": [\n              {\n                \"jdbcUrl\": [\"jdbc:mysql://xxxx/xxx\"],\n\t\t\t\t\"querySql\": [\n\t\t\t\"select ...;\"\n\t\t\t\t]\n              }\n            ],\n            \"password\": \"xxxxx\",\n            \"username\": \"xxxxx\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"mysqlwriter\",\n          \"parameter\": {\n\t\t    \"column\": [\n\t\t\t \"id\",\n\t\t\t \"coupon_id\",\n\t\t\t \"coupon_seq\",\n\t\t\t \"value\",\n\t\t\t \"use_date\",\n\t\t\t \"crt_date\",\n\t\t\t \"update_date\",\n\t\t\t \"platform\",\n\t\t\t \"member_id\",\n\t\t\t \"coupon_act_id\",\n\t\t\t \"end_time\",\n\t\t\t \"begin_time\",\n\t\t\t \"del_flag\"\n\t\t\t],\n            \"connection\": [\n              {\n                \"jdbcUrl\": \"jdbc:mysql://localhost:3306/erp\",\n                \"table\": [\"erp_coupon_list\"]\n              }\n            ],\n            \"password\": \"123456\",\n            \"preSql\": [],\n            \"session\": [],\n            \"username\": \"root\",\n            \"writeMode\": \"insert\"\n          }\n        }\n      }\n    ],\n    \"setting\": {\n      \"speed\": {\n        \"channel\": \"5\"\n      }\n    }\n  }\n}\n```\n\n### 运行\n``` python\npython bin/datax.py job/job.json\n```\n> 如果是windows下执行会中文乱码，可以在窗口中执行`chcp 65001`, 临时变更编码格式为UTF-8。切勿去改注册表。  \n\n运行结果1：\n![](images/datax1.png)\n这个是之前的测试实验。700w 数据，需要 3h 左右同步完成。我以为是网络问题导致，实则不然。\n\n## 2.batchInsert \n\n上述实验结果居然性能太差，再来仔细看看文档[mysqlWriter](https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md)的介绍:  \n> 出于性能考虑，采用了 PreparedStatement + Batch，并且设置了：rewriteBatchedStatements=true，将数据缓冲到线程上下文 Buffer 中，当 Buffer 累计到预定阈值时，才发起写入请求。  \n- jdbcUrl:\n```\n作业运行时，DataX 会在你提供的 jdbcUrl 后面追加如下属性：yearIsDateType=false&zeroDateTimeBehavior=convertToNull&rewriteBatchedStatements=true\n```\n- batchSize:\n```\n一次性批量提交的记录数大小，该值可以极大减少DataX与Mysql的网络交互次数，并提升整体吞吐量。但是该值设置过大可能会造成DataX运行进程OOM情况。默认值：1024\n```\n以上，我用本地mysql做了下实验，batchSize设置为5120，channel设置为5。430w的数据，近5分钟完成，大约1.4w行/s。虽然跟官网的测试（4条channel，4000的batchSize）速度8w/s来说，差距不小，但速度已然是飞一般的提升了。  \n如果需要写入的数据库是PGSQL，那么重写批量插入的参数应该是在URL后面加上 `reWriteBatchedInserts=true`, 驱动版本号需要`>=42.2.2`  \n\n\n> 需要注意的是：  \n1. 分布式数据库的写入速度肯定会比单机慢，要有心理预期\n2. dataX同步的数据不保证在同一个事务内完成。因此如果同步任务复杂， 需要考虑失败的情况。可以通过pre任务来清理脏数据，通过post任务来做一下校验。\n\n\n\n\n\n\n\n\n\n","source":"_posts/dataX-异构数据离线同步.md","raw":"---\ntitle: dataX-异构数据离线同步\ndate: 2023-12-19 14:30:00\ntags:\n- dataX\ncategories: 数据库\n---\n如果要实现不同数据库之前的数据同步，应该怎么做？直接执行sql文件，如果语法不兼容呢？dataX是一个阿里开源的，被广泛使用的离线数据同步的工具，通过各类插件的reader/writer兼容了各类数据的整合。可实现自定义全量/增量的数据同步。\n<!--more-->\n用一个示意图来理解dataX干的事情，就是  \n![](https://cloud.githubusercontent.com/assets/1067175/17879841/93b7fc1c-6927-11e6-8cda-7cf8420fc65f.png)\n\n> （百度到的一般都是阿里的商业版，而且也都是界面操作的文档。如果是开源版使用的话， 还是自行 quickStart 吧）  \nhttps://github.com/alibaba/DataX/blob/master/userGuid.md\n\n\n## 1. quickStart\n以下以Mysql同步到postgresql为例说明。\n\n### 检查环境配置\n``` \nJDK1.8+\nPython\nMaven3\n```\n\n### 编辑Job配置\n```\n{\n  \"job\": {\n    \"content\": [\n      {\n        \"reader\": {\n          \"name\": \"mysqlreader\",\n          \"parameter\": {\n            \"connection\": [\n              {\n                \"jdbcUrl\": [\"jdbc:mysql://xxxx/xxx\"],\n\t\t\t\t\"querySql\": [\n\t\t\t\"select ...;\"\n\t\t\t\t]\n              }\n            ],\n            \"password\": \"xxxxx\",\n            \"username\": \"xxxxx\"\n          }\n        },\n        \"writer\": {\n          \"name\": \"mysqlwriter\",\n          \"parameter\": {\n\t\t    \"column\": [\n\t\t\t \"id\",\n\t\t\t \"coupon_id\",\n\t\t\t \"coupon_seq\",\n\t\t\t \"value\",\n\t\t\t \"use_date\",\n\t\t\t \"crt_date\",\n\t\t\t \"update_date\",\n\t\t\t \"platform\",\n\t\t\t \"member_id\",\n\t\t\t \"coupon_act_id\",\n\t\t\t \"end_time\",\n\t\t\t \"begin_time\",\n\t\t\t \"del_flag\"\n\t\t\t],\n            \"connection\": [\n              {\n                \"jdbcUrl\": \"jdbc:mysql://localhost:3306/erp\",\n                \"table\": [\"erp_coupon_list\"]\n              }\n            ],\n            \"password\": \"123456\",\n            \"preSql\": [],\n            \"session\": [],\n            \"username\": \"root\",\n            \"writeMode\": \"insert\"\n          }\n        }\n      }\n    ],\n    \"setting\": {\n      \"speed\": {\n        \"channel\": \"5\"\n      }\n    }\n  }\n}\n```\n\n### 运行\n``` python\npython bin/datax.py job/job.json\n```\n> 如果是windows下执行会中文乱码，可以在窗口中执行`chcp 65001`, 临时变更编码格式为UTF-8。切勿去改注册表。  \n\n运行结果1：\n![](images/datax1.png)\n这个是之前的测试实验。700w 数据，需要 3h 左右同步完成。我以为是网络问题导致，实则不然。\n\n## 2.batchInsert \n\n上述实验结果居然性能太差，再来仔细看看文档[mysqlWriter](https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md)的介绍:  \n> 出于性能考虑，采用了 PreparedStatement + Batch，并且设置了：rewriteBatchedStatements=true，将数据缓冲到线程上下文 Buffer 中，当 Buffer 累计到预定阈值时，才发起写入请求。  \n- jdbcUrl:\n```\n作业运行时，DataX 会在你提供的 jdbcUrl 后面追加如下属性：yearIsDateType=false&zeroDateTimeBehavior=convertToNull&rewriteBatchedStatements=true\n```\n- batchSize:\n```\n一次性批量提交的记录数大小，该值可以极大减少DataX与Mysql的网络交互次数，并提升整体吞吐量。但是该值设置过大可能会造成DataX运行进程OOM情况。默认值：1024\n```\n以上，我用本地mysql做了下实验，batchSize设置为5120，channel设置为5。430w的数据，近5分钟完成，大约1.4w行/s。虽然跟官网的测试（4条channel，4000的batchSize）速度8w/s来说，差距不小，但速度已然是飞一般的提升了。  \n如果需要写入的数据库是PGSQL，那么重写批量插入的参数应该是在URL后面加上 `reWriteBatchedInserts=true`, 驱动版本号需要`>=42.2.2`  \n\n\n> 需要注意的是：  \n1. 分布式数据库的写入速度肯定会比单机慢，要有心理预期\n2. dataX同步的数据不保证在同一个事务内完成。因此如果同步任务复杂， 需要考虑失败的情况。可以通过pre任务来清理脏数据，通过post任务来做一下校验。\n\n\n\n\n\n\n\n\n\n","slug":"dataX-异构数据离线同步","published":1,"updated":"2024-04-11T03:38:42.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz4001yqwvdfcm1c9d3","content":"<p>如果要实现不同数据库之前的数据同步，应该怎么做？直接执行sql文件，如果语法不兼容呢？dataX是一个阿里开源的，被广泛使用的离线数据同步的工具，通过各类插件的reader&#x2F;writer兼容了各类数据的整合。可实现自定义全量&#x2F;增量的数据同步。</p>\n<span id=\"more\"></span>\n<p>用一个示意图来理解dataX干的事情，就是<br><img src=\"https://cloud.githubusercontent.com/assets/1067175/17879841/93b7fc1c-6927-11e6-8cda-7cf8420fc65f.png\"></p>\n<blockquote>\n<p>（百度到的一般都是阿里的商业版，而且也都是界面操作的文档。如果是开源版使用的话， 还是自行 quickStart 吧）<br><a href=\"https://github.com/alibaba/DataX/blob/master/userGuid.md\">https://github.com/alibaba/DataX/blob/master/userGuid.md</a></p>\n</blockquote>\n<h2 id=\"1-quickStart\"><a href=\"#1-quickStart\" class=\"headerlink\" title=\"1. quickStart\"></a>1. quickStart</h2><p>以下以Mysql同步到postgresql为例说明。</p>\n<h3 id=\"检查环境配置\"><a href=\"#检查环境配置\" class=\"headerlink\" title=\"检查环境配置\"></a>检查环境配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK1.8+</span><br><span class=\"line\">Python</span><br><span class=\"line\">Maven3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编辑Job配置\"><a href=\"#编辑Job配置\" class=\"headerlink\" title=\"编辑Job配置\"></a>编辑Job配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;job&quot;: &#123;</span><br><span class=\"line\">    &quot;content&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;reader&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;mysqlreader&quot;,</span><br><span class=\"line\">          &quot;parameter&quot;: &#123;</span><br><span class=\"line\">            &quot;connection&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;jdbcUrl&quot;: [&quot;jdbc:mysql://xxxx/xxx&quot;],</span><br><span class=\"line\">\t\t\t\t&quot;querySql&quot;: [</span><br><span class=\"line\">\t\t\t&quot;select ...;&quot;</span><br><span class=\"line\">\t\t\t\t]</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            &quot;password&quot;: &quot;xxxxx&quot;,</span><br><span class=\"line\">            &quot;username&quot;: &quot;xxxxx&quot;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;writer&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;mysqlwriter&quot;,</span><br><span class=\"line\">          &quot;parameter&quot;: &#123;</span><br><span class=\"line\">\t\t    &quot;column&quot;: [</span><br><span class=\"line\">\t\t\t &quot;id&quot;,</span><br><span class=\"line\">\t\t\t &quot;coupon_id&quot;,</span><br><span class=\"line\">\t\t\t &quot;coupon_seq&quot;,</span><br><span class=\"line\">\t\t\t &quot;value&quot;,</span><br><span class=\"line\">\t\t\t &quot;use_date&quot;,</span><br><span class=\"line\">\t\t\t &quot;crt_date&quot;,</span><br><span class=\"line\">\t\t\t &quot;update_date&quot;,</span><br><span class=\"line\">\t\t\t &quot;platform&quot;,</span><br><span class=\"line\">\t\t\t &quot;member_id&quot;,</span><br><span class=\"line\">\t\t\t &quot;coupon_act_id&quot;,</span><br><span class=\"line\">\t\t\t &quot;end_time&quot;,</span><br><span class=\"line\">\t\t\t &quot;begin_time&quot;,</span><br><span class=\"line\">\t\t\t &quot;del_flag&quot;</span><br><span class=\"line\">\t\t\t],</span><br><span class=\"line\">            &quot;connection&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;jdbcUrl&quot;: &quot;jdbc:mysql://localhost:3306/erp&quot;,</span><br><span class=\"line\">                &quot;table&quot;: [&quot;erp_coupon_list&quot;]</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            &quot;password&quot;: &quot;123456&quot;,</span><br><span class=\"line\">            &quot;preSql&quot;: [],</span><br><span class=\"line\">            &quot;session&quot;: [],</span><br><span class=\"line\">            &quot;username&quot;: &quot;root&quot;,</span><br><span class=\"line\">            &quot;writeMode&quot;: &quot;insert&quot;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;setting&quot;: &#123;</span><br><span class=\"line\">      &quot;speed&quot;: &#123;</span><br><span class=\"line\">        &quot;channel&quot;: &quot;5&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python <span class=\"built_in\">bin</span>/datax.py job/job.json</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果是windows下执行会中文乱码，可以在窗口中执行<code>chcp 65001</code>, 临时变更编码格式为UTF-8。切勿去改注册表。  </p>\n</blockquote>\n<p>运行结果1：<br><img src=\"/images/datax1.png\"><br>这个是之前的测试实验。700w 数据，需要 3h 左右同步完成。我以为是网络问题导致，实则不然。</p>\n<h2 id=\"2-batchInsert\"><a href=\"#2-batchInsert\" class=\"headerlink\" title=\"2.batchInsert\"></a>2.batchInsert</h2><p>上述实验结果居然性能太差，再来仔细看看文档<a href=\"https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md\">mysqlWriter</a>的介绍:  </p>\n<blockquote>\n<p>出于性能考虑，采用了 PreparedStatement + Batch，并且设置了：rewriteBatchedStatements&#x3D;true，将数据缓冲到线程上下文 Buffer 中，当 Buffer 累计到预定阈值时，才发起写入请求。  </p>\n</blockquote>\n<ul>\n<li>jdbcUrl:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作业运行时，DataX 会在你提供的 jdbcUrl 后面追加如下属性：yearIsDateType=false&amp;zeroDateTimeBehavior=convertToNull&amp;rewriteBatchedStatements=true</span><br></pre></td></tr></table></figure></li>\n<li>batchSize:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一次性批量提交的记录数大小，该值可以极大减少DataX与Mysql的网络交互次数，并提升整体吞吐量。但是该值设置过大可能会造成DataX运行进程OOM情况。默认值：1024</span><br></pre></td></tr></table></figure>\n以上，我用本地mysql做了下实验，batchSize设置为5120，channel设置为5。430w的数据，近5分钟完成，大约1.4w行&#x2F;s。虽然跟官网的测试（4条channel，4000的batchSize）速度8w&#x2F;s来说，差距不小，但速度已然是飞一般的提升了。<br>如果需要写入的数据库是PGSQL，那么重写批量插入的参数应该是在URL后面加上 <code>reWriteBatchedInserts=true</code>, 驱动版本号需要<code>&gt;=42.2.2</code></li>\n</ul>\n<blockquote>\n<p>需要注意的是：  </p>\n</blockquote>\n<ol>\n<li>分布式数据库的写入速度肯定会比单机慢，要有心理预期</li>\n<li>dataX同步的数据不保证在同一个事务内完成。因此如果同步任务复杂， 需要考虑失败的情况。可以通过pre任务来清理脏数据，通过post任务来做一下校验。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>如果要实现不同数据库之前的数据同步，应该怎么做？直接执行sql文件，如果语法不兼容呢？dataX是一个阿里开源的，被广泛使用的离线数据同步的工具，通过各类插件的reader&#x2F;writer兼容了各类数据的整合。可实现自定义全量&#x2F;增量的数据同步。</p>","more":"<p>用一个示意图来理解dataX干的事情，就是<br><img src=\"https://cloud.githubusercontent.com/assets/1067175/17879841/93b7fc1c-6927-11e6-8cda-7cf8420fc65f.png\"></p>\n<blockquote>\n<p>（百度到的一般都是阿里的商业版，而且也都是界面操作的文档。如果是开源版使用的话， 还是自行 quickStart 吧）<br><a href=\"https://github.com/alibaba/DataX/blob/master/userGuid.md\">https://github.com/alibaba/DataX/blob/master/userGuid.md</a></p>\n</blockquote>\n<h2 id=\"1-quickStart\"><a href=\"#1-quickStart\" class=\"headerlink\" title=\"1. quickStart\"></a>1. quickStart</h2><p>以下以Mysql同步到postgresql为例说明。</p>\n<h3 id=\"检查环境配置\"><a href=\"#检查环境配置\" class=\"headerlink\" title=\"检查环境配置\"></a>检查环境配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK1.8+</span><br><span class=\"line\">Python</span><br><span class=\"line\">Maven3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编辑Job配置\"><a href=\"#编辑Job配置\" class=\"headerlink\" title=\"编辑Job配置\"></a>编辑Job配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;job&quot;: &#123;</span><br><span class=\"line\">    &quot;content&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;reader&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;mysqlreader&quot;,</span><br><span class=\"line\">          &quot;parameter&quot;: &#123;</span><br><span class=\"line\">            &quot;connection&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;jdbcUrl&quot;: [&quot;jdbc:mysql://xxxx/xxx&quot;],</span><br><span class=\"line\">\t\t\t\t&quot;querySql&quot;: [</span><br><span class=\"line\">\t\t\t&quot;select ...;&quot;</span><br><span class=\"line\">\t\t\t\t]</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            &quot;password&quot;: &quot;xxxxx&quot;,</span><br><span class=\"line\">            &quot;username&quot;: &quot;xxxxx&quot;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;writer&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;mysqlwriter&quot;,</span><br><span class=\"line\">          &quot;parameter&quot;: &#123;</span><br><span class=\"line\">\t\t    &quot;column&quot;: [</span><br><span class=\"line\">\t\t\t &quot;id&quot;,</span><br><span class=\"line\">\t\t\t &quot;coupon_id&quot;,</span><br><span class=\"line\">\t\t\t &quot;coupon_seq&quot;,</span><br><span class=\"line\">\t\t\t &quot;value&quot;,</span><br><span class=\"line\">\t\t\t &quot;use_date&quot;,</span><br><span class=\"line\">\t\t\t &quot;crt_date&quot;,</span><br><span class=\"line\">\t\t\t &quot;update_date&quot;,</span><br><span class=\"line\">\t\t\t &quot;platform&quot;,</span><br><span class=\"line\">\t\t\t &quot;member_id&quot;,</span><br><span class=\"line\">\t\t\t &quot;coupon_act_id&quot;,</span><br><span class=\"line\">\t\t\t &quot;end_time&quot;,</span><br><span class=\"line\">\t\t\t &quot;begin_time&quot;,</span><br><span class=\"line\">\t\t\t &quot;del_flag&quot;</span><br><span class=\"line\">\t\t\t],</span><br><span class=\"line\">            &quot;connection&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;jdbcUrl&quot;: &quot;jdbc:mysql://localhost:3306/erp&quot;,</span><br><span class=\"line\">                &quot;table&quot;: [&quot;erp_coupon_list&quot;]</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            &quot;password&quot;: &quot;123456&quot;,</span><br><span class=\"line\">            &quot;preSql&quot;: [],</span><br><span class=\"line\">            &quot;session&quot;: [],</span><br><span class=\"line\">            &quot;username&quot;: &quot;root&quot;,</span><br><span class=\"line\">            &quot;writeMode&quot;: &quot;insert&quot;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;setting&quot;: &#123;</span><br><span class=\"line\">      &quot;speed&quot;: &#123;</span><br><span class=\"line\">        &quot;channel&quot;: &quot;5&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python <span class=\"built_in\">bin</span>/datax.py job/job.json</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果是windows下执行会中文乱码，可以在窗口中执行<code>chcp 65001</code>, 临时变更编码格式为UTF-8。切勿去改注册表。  </p>\n</blockquote>\n<p>运行结果1：<br><img src=\"/images/datax1.png\"><br>这个是之前的测试实验。700w 数据，需要 3h 左右同步完成。我以为是网络问题导致，实则不然。</p>\n<h2 id=\"2-batchInsert\"><a href=\"#2-batchInsert\" class=\"headerlink\" title=\"2.batchInsert\"></a>2.batchInsert</h2><p>上述实验结果居然性能太差，再来仔细看看文档<a href=\"https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md\">mysqlWriter</a>的介绍:  </p>\n<blockquote>\n<p>出于性能考虑，采用了 PreparedStatement + Batch，并且设置了：rewriteBatchedStatements&#x3D;true，将数据缓冲到线程上下文 Buffer 中，当 Buffer 累计到预定阈值时，才发起写入请求。  </p>\n</blockquote>\n<ul>\n<li>jdbcUrl:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作业运行时，DataX 会在你提供的 jdbcUrl 后面追加如下属性：yearIsDateType=false&amp;zeroDateTimeBehavior=convertToNull&amp;rewriteBatchedStatements=true</span><br></pre></td></tr></table></figure></li>\n<li>batchSize:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一次性批量提交的记录数大小，该值可以极大减少DataX与Mysql的网络交互次数，并提升整体吞吐量。但是该值设置过大可能会造成DataX运行进程OOM情况。默认值：1024</span><br></pre></td></tr></table></figure>\n以上，我用本地mysql做了下实验，batchSize设置为5120，channel设置为5。430w的数据，近5分钟完成，大约1.4w行&#x2F;s。虽然跟官网的测试（4条channel，4000的batchSize）速度8w&#x2F;s来说，差距不小，但速度已然是飞一般的提升了。<br>如果需要写入的数据库是PGSQL，那么重写批量插入的参数应该是在URL后面加上 <code>reWriteBatchedInserts=true</code>, 驱动版本号需要<code>&gt;=42.2.2</code></li>\n</ul>\n<blockquote>\n<p>需要注意的是：  </p>\n</blockquote>\n<ol>\n<li>分布式数据库的写入速度肯定会比单机慢，要有心理预期</li>\n<li>dataX同步的数据不保证在同一个事务内完成。因此如果同步任务复杂， 需要考虑失败的情况。可以通过pre任务来清理脏数据，通过post任务来做一下校验。</li>\n</ol>"},{"title":"grpc","date":"2023-03-19T03:48:58.000Z","_content":"\ngRPC是Google开源的一种高性能远程调用框架，它能高效地连接服务，支持负载均衡、跟踪、健康检查和身份验证，也能用于各移动端和浏览器对后端服务端连接。  \n它使用[Protocol Buffers](https://protobuf.dev/)作为二进制序列化，使用HTTP/2进行数据传输。\n<!--more-->  \n\n![](https://grpc.io/img/landing-2.svg)\n\n\n## grpc-demo-run\n通过官网的demo，理解grpc的Server和Client\nhttps://grpc.io/docs/languages/java/quickstart/  \n建议使用使用提供的gradlew命令，遇到问题请参考[demo-run问题](#遇到的问题)  \n\n## code解析  \n\n### 1. sayHello  \nGreeterGrpc.GreeterImplBase中\n``` java\n    @Override\n    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      HelloReply reply = HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build();\n      responseObserver.onNext(reply);\n      responseObserver.onCompleted();\n    }\n```\n\n### 2. 服务端  \n``` java\nint port = 50051;\n    server = ServerBuilder.forPort(port)\n        .addService(new GreeterImpl())\n        .build()\n        .start();\n```\n\n### 3. 客户端\n\n1) 通过地址创建channel  \n``` java\nManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:50051\")\n        // 使用明文避免需要证书\n        .usePlaintext().build();\n```\n2) 通过channel创建stub\n``` java\nHelloGrpc.HelloBlockingStub blockingStub = HelloGrpc.newBlockingStub(channel);\n```\n3) 创建request并设置参数  \n``` java\nHelloRequest request = HelloRequest.newBuilder().setName(name).build();\n4) 通过stub发送request\n    HelloReply response response = blockingStub.sayHello(request);\n```\n## 遇到的问题\n1. 开始参考quick start跑demo的时候，maven提示找不到jar包，然后我果断切换到一个2021年的分支。但还是报找不到jar报, 在maven仓库中搜索了下确实找不到`grpc-stub 1.33.2-SNAPSHOT`,果断替换成`1.33.1`  \n2. maven编译成功后，IDEA中始终会显示包没引用正确的报错标记。但其实这只是IDEA的显示问题，不影响run，前提是无法通过界面运行Client和Server的Main方法了。  \n> 在IDEA显示问题上追究很浪费时间，别忘记要学习的内容   \n> 这里需要一下mvn的知识:  \n> `run server`\n> ``` bash\n> mvn  -Dexec.mainClass=io.grpc.examples.helloworld.> > > HelloWorldServer exec:java\n> ```\n> `run client`\n> ``` bash\n> mvn -Dexec.mainClass=io.grpc.examples.helloworld.> HelloWorldClient exec:java\n> ```\n> 3. 本来还很奇怪grpc官网连jdk7都可以支持，怎么mvn编译demo的>方式也不提供下。用过之后，只想说 [真香!] --> [安装使用gradle](#安装使用gradle)  \n> 4. 注意生成的代码在`target`或`build`目录  \n> 其他demo参考\nhttps://www.cnblogs.com/zhongyuanzhao000/p/13783165.html  \n\n\n\n","source":"_posts/gprc.md","raw":"---\ntitle: grpc\ndate: 2023-03-19 11:48:58\ntags: grpc\ncategories: Spring+\n#description: gRPC是Google开源的一种高性能远程调用框架，它能高效地连接服务，支持负载均衡、跟踪、健康检查和身份验证。\n---\n\ngRPC是Google开源的一种高性能远程调用框架，它能高效地连接服务，支持负载均衡、跟踪、健康检查和身份验证，也能用于各移动端和浏览器对后端服务端连接。  \n它使用[Protocol Buffers](https://protobuf.dev/)作为二进制序列化，使用HTTP/2进行数据传输。\n<!--more-->  \n\n![](https://grpc.io/img/landing-2.svg)\n\n\n## grpc-demo-run\n通过官网的demo，理解grpc的Server和Client\nhttps://grpc.io/docs/languages/java/quickstart/  \n建议使用使用提供的gradlew命令，遇到问题请参考[demo-run问题](#遇到的问题)  \n\n## code解析  \n\n### 1. sayHello  \nGreeterGrpc.GreeterImplBase中\n``` java\n    @Override\n    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      HelloReply reply = HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build();\n      responseObserver.onNext(reply);\n      responseObserver.onCompleted();\n    }\n```\n\n### 2. 服务端  \n``` java\nint port = 50051;\n    server = ServerBuilder.forPort(port)\n        .addService(new GreeterImpl())\n        .build()\n        .start();\n```\n\n### 3. 客户端\n\n1) 通过地址创建channel  \n``` java\nManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:50051\")\n        // 使用明文避免需要证书\n        .usePlaintext().build();\n```\n2) 通过channel创建stub\n``` java\nHelloGrpc.HelloBlockingStub blockingStub = HelloGrpc.newBlockingStub(channel);\n```\n3) 创建request并设置参数  \n``` java\nHelloRequest request = HelloRequest.newBuilder().setName(name).build();\n4) 通过stub发送request\n    HelloReply response response = blockingStub.sayHello(request);\n```\n## 遇到的问题\n1. 开始参考quick start跑demo的时候，maven提示找不到jar包，然后我果断切换到一个2021年的分支。但还是报找不到jar报, 在maven仓库中搜索了下确实找不到`grpc-stub 1.33.2-SNAPSHOT`,果断替换成`1.33.1`  \n2. maven编译成功后，IDEA中始终会显示包没引用正确的报错标记。但其实这只是IDEA的显示问题，不影响run，前提是无法通过界面运行Client和Server的Main方法了。  \n> 在IDEA显示问题上追究很浪费时间，别忘记要学习的内容   \n> 这里需要一下mvn的知识:  \n> `run server`\n> ``` bash\n> mvn  -Dexec.mainClass=io.grpc.examples.helloworld.> > > HelloWorldServer exec:java\n> ```\n> `run client`\n> ``` bash\n> mvn -Dexec.mainClass=io.grpc.examples.helloworld.> HelloWorldClient exec:java\n> ```\n> 3. 本来还很奇怪grpc官网连jdk7都可以支持，怎么mvn编译demo的>方式也不提供下。用过之后，只想说 [真香!] --> [安装使用gradle](#安装使用gradle)  \n> 4. 注意生成的代码在`target`或`build`目录  \n> 其他demo参考\nhttps://www.cnblogs.com/zhongyuanzhao000/p/13783165.html  \n\n\n\n","slug":"gprc","published":1,"updated":"2024-02-18T08:21:59.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz40021qwvdgeireref","content":"<p>gRPC是Google开源的一种高性能远程调用框架，它能高效地连接服务，支持负载均衡、跟踪、健康检查和身份验证，也能用于各移动端和浏览器对后端服务端连接。<br>它使用<a href=\"https://protobuf.dev/\">Protocol Buffers</a>作为二进制序列化，使用HTTP&#x2F;2进行数据传输。</p>\n<span id=\"more\"></span>  \n\n<p><img src=\"https://grpc.io/img/landing-2.svg\"></p>\n<h2 id=\"grpc-demo-run\"><a href=\"#grpc-demo-run\" class=\"headerlink\" title=\"grpc-demo-run\"></a>grpc-demo-run</h2><p>通过官网的demo，理解grpc的Server和Client<br><a href=\"https://grpc.io/docs/languages/java/quickstart/\">https://grpc.io/docs/languages/java/quickstart/</a><br>建议使用使用提供的gradlew命令，遇到问题请参考<a href=\"#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">demo-run问题</a>  </p>\n<h2 id=\"code解析\"><a href=\"#code解析\" class=\"headerlink\" title=\"code解析\"></a>code解析</h2><h3 id=\"1-sayHello\"><a href=\"#1-sayHello\" class=\"headerlink\" title=\"1. sayHello\"></a>1. sayHello</h3><p>GreeterGrpc.GreeterImplBase中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>&#123;</span><br><span class=\"line\">  HelloReply reply = HelloReply.newBuilder().setMessage(<span class=\"string\">&quot;Hello &quot;</span> + req.getName()).build();</span><br><span class=\"line\">  responseObserver.onNext(reply);</span><br><span class=\"line\">  responseObserver.onCompleted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-服务端\"><a href=\"#2-服务端\" class=\"headerlink\" title=\"2. 服务端\"></a>2. 服务端</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> port = <span class=\"number\">50051</span>;</span><br><span class=\"line\">    server = ServerBuilder.forPort(port)</span><br><span class=\"line\">        .addService(<span class=\"keyword\">new</span> GreeterImpl())</span><br><span class=\"line\">        .build()</span><br><span class=\"line\">        .start();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-客户端\"><a href=\"#3-客户端\" class=\"headerlink\" title=\"3. 客户端\"></a>3. 客户端</h3><ol>\n<li>通过地址创建channel  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ManagedChannel channel = ManagedChannelBuilder.forTarget(<span class=\"string\">&quot;localhost:50051&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 使用明文避免需要证书</span></span><br><span class=\"line\">        .usePlaintext().build();</span><br></pre></td></tr></table></figure></li>\n<li>通过channel创建stub<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloGrpc.HelloBlockingStub blockingStub = HelloGrpc.newBlockingStub(channel);</span><br></pre></td></tr></table></figure></li>\n<li>创建request并设置参数  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloRequest request = HelloRequest.newBuilder().setName(name).build();</span><br><span class=\"line\"><span class=\"number\">4</span>) 通过stub发送request</span><br><span class=\"line\">    HelloReply response response = blockingStub.sayHello(request);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>开始参考quick start跑demo的时候，maven提示找不到jar包，然后我果断切换到一个2021年的分支。但还是报找不到jar报, 在maven仓库中搜索了下确实找不到<code>grpc-stub 1.33.2-SNAPSHOT</code>,果断替换成<code>1.33.1</code>  </li>\n<li>maven编译成功后，IDEA中始终会显示包没引用正确的报错标记。但其实这只是IDEA的显示问题，不影响run，前提是无法通过界面运行Client和Server的Main方法了。  <blockquote>\n<p>在IDEA显示问题上追究很浪费时间，别忘记要学习的内容<br>这里需要一下mvn的知识:<br><code>run server</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn  -Dexec.mainClass=io.grpc.examples.helloworld.&gt; &gt; &gt; HelloWorldServer <span class=\"built_in\">exec</span>:java</span><br></pre></td></tr></table></figure>\n<p><code>run client</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -Dexec.mainClass=io.grpc.examples.helloworld.&gt; HelloWorldClient <span class=\"built_in\">exec</span>:java</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>本来还很奇怪grpc官网连jdk7都可以支持，怎么mvn编译demo的&gt;方式也不提供下。用过之后，只想说 [真香!] –&gt; <a href=\"#%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gradle\">安装使用gradle</a>  </li>\n<li>注意生成的代码在<code>target</code>或<code>build</code>目录<br>其他demo参考<br><a href=\"https://www.cnblogs.com/zhongyuanzhao000/p/13783165.html\">https://www.cnblogs.com/zhongyuanzhao000/p/13783165.html</a></li>\n</ol>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>gRPC是Google开源的一种高性能远程调用框架，它能高效地连接服务，支持负载均衡、跟踪、健康检查和身份验证，也能用于各移动端和浏览器对后端服务端连接。<br>它使用<a href=\"https://protobuf.dev/\">Protocol Buffers</a>作为二进制序列化，使用HTTP&#x2F;2进行数据传输。</p>","more":"<p><img src=\"https://grpc.io/img/landing-2.svg\"></p>\n<h2 id=\"grpc-demo-run\"><a href=\"#grpc-demo-run\" class=\"headerlink\" title=\"grpc-demo-run\"></a>grpc-demo-run</h2><p>通过官网的demo，理解grpc的Server和Client<br><a href=\"https://grpc.io/docs/languages/java/quickstart/\">https://grpc.io/docs/languages/java/quickstart/</a><br>建议使用使用提供的gradlew命令，遇到问题请参考<a href=\"#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">demo-run问题</a>  </p>\n<h2 id=\"code解析\"><a href=\"#code解析\" class=\"headerlink\" title=\"code解析\"></a>code解析</h2><h3 id=\"1-sayHello\"><a href=\"#1-sayHello\" class=\"headerlink\" title=\"1. sayHello\"></a>1. sayHello</h3><p>GreeterGrpc.GreeterImplBase中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>&#123;</span><br><span class=\"line\">  HelloReply reply = HelloReply.newBuilder().setMessage(<span class=\"string\">&quot;Hello &quot;</span> + req.getName()).build();</span><br><span class=\"line\">  responseObserver.onNext(reply);</span><br><span class=\"line\">  responseObserver.onCompleted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-服务端\"><a href=\"#2-服务端\" class=\"headerlink\" title=\"2. 服务端\"></a>2. 服务端</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> port = <span class=\"number\">50051</span>;</span><br><span class=\"line\">    server = ServerBuilder.forPort(port)</span><br><span class=\"line\">        .addService(<span class=\"keyword\">new</span> GreeterImpl())</span><br><span class=\"line\">        .build()</span><br><span class=\"line\">        .start();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-客户端\"><a href=\"#3-客户端\" class=\"headerlink\" title=\"3. 客户端\"></a>3. 客户端</h3><ol>\n<li>通过地址创建channel  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ManagedChannel channel = ManagedChannelBuilder.forTarget(<span class=\"string\">&quot;localhost:50051&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 使用明文避免需要证书</span></span><br><span class=\"line\">        .usePlaintext().build();</span><br></pre></td></tr></table></figure></li>\n<li>通过channel创建stub<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloGrpc.HelloBlockingStub blockingStub = HelloGrpc.newBlockingStub(channel);</span><br></pre></td></tr></table></figure></li>\n<li>创建request并设置参数  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HelloRequest request = HelloRequest.newBuilder().setName(name).build();</span><br><span class=\"line\"><span class=\"number\">4</span>) 通过stub发送request</span><br><span class=\"line\">    HelloReply response response = blockingStub.sayHello(request);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>开始参考quick start跑demo的时候，maven提示找不到jar包，然后我果断切换到一个2021年的分支。但还是报找不到jar报, 在maven仓库中搜索了下确实找不到<code>grpc-stub 1.33.2-SNAPSHOT</code>,果断替换成<code>1.33.1</code>  </li>\n<li>maven编译成功后，IDEA中始终会显示包没引用正确的报错标记。但其实这只是IDEA的显示问题，不影响run，前提是无法通过界面运行Client和Server的Main方法了。  <blockquote>\n<p>在IDEA显示问题上追究很浪费时间，别忘记要学习的内容<br>这里需要一下mvn的知识:<br><code>run server</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn  -Dexec.mainClass=io.grpc.examples.helloworld.&gt; &gt; &gt; HelloWorldServer <span class=\"built_in\">exec</span>:java</span><br></pre></td></tr></table></figure>\n<p><code>run client</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -Dexec.mainClass=io.grpc.examples.helloworld.&gt; HelloWorldClient <span class=\"built_in\">exec</span>:java</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>本来还很奇怪grpc官网连jdk7都可以支持，怎么mvn编译demo的&gt;方式也不提供下。用过之后，只想说 [真香!] –&gt; <a href=\"#%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gradle\">安装使用gradle</a>  </li>\n<li>注意生成的代码在<code>target</code>或<code>build</code>目录<br>其他demo参考<br><a href=\"https://www.cnblogs.com/zhongyuanzhao000/p/13783165.html\">https://www.cnblogs.com/zhongyuanzhao000/p/13783165.html</a></li>\n</ol>\n</blockquote>\n</li>\n</ol>"},{"title":"jdbc处理大数据时的坑","date":"2023-12-20T11:44:09.000Z","_content":"作为有点经验的java coder，使用jdbc或者mybatis的时候有没有发现一点问题？插入大量数据怎么这么慢！查询大量结果，怎么一下就OOM了！！\n<!--more-->\n\n## 先说结论 \n1. jdbc默认只会一条条执行insert，即使你调用的是batch\n2. jdbc默认一次性将全部结果拉取到客户端，数据量一大极容易OOM\n\n### 解决方案：\n1. url加上参数`rewriteBatchedStatements=true`,其作用是改写你的sql为多行insert/update\n2. url加上参数`defaultfetchsize=-214783648`,并使用`StreamingResult`\n\n### 实验准备\n不动手试试，总是无法辨明真伪的。  \n自行建一个有jdbc的项目，通过junit单元测试验证。\n - maven依赖:  \n``` xml\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.47</version>\n    </dependency>    \n\n        <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n```\n- jvm参数  \n不设置最大内存的话，特别是大量拉取的时候对比不了效果。我设置的最大堆内存是5m。  \n`-Xmx5m -Xms5m`  \n为方便，顺便打印下相关参数：  \n``` java\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n        runtimeMxBean.getInputArguments().stream().forEach(System.out::println);\n    }\n```\n\n## 批量插入\n```\n   /**\n     * 插入本地10w条数据，实验结果：\n     * 真批量：1s\n     * 假批量：超过6min，差别远不止别人测试几十倍。这个差距应该是随着数据量不断放大的\n     */\n    @Test\n    public void test2() {\n        String url = \"jdbc:mysql://localhost:3306/benchtest\";\n//        String url = \"jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true\";\n        Connection connection = null;\n        try {\n            long start = System.currentTimeMillis();\n            connection = DriverManager.getConnection(url, username, password);\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO user (email, pass, name) VALUES (?, ?, ?)\");\n            for (int i = 0; i < 100000; i++) {\n                statement.setString(1, \"email\"+i);\n                statement.setString(2, \"pass\"+i);\n                statement.setString(3, \"name\"+i);\n                statement.addBatch();\n            }\n            int[] updateCounts = statement.executeBatch();\n            connection.close();\n            long end = System.currentTimeMillis();\n            System.out.println(\"updateCounts=\" + updateCounts.length + \" cost=\" + (end-start)/1000);\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        }\n    }\n```\n\n### 批量插入可能存在的问题\n一般创建的连接都是自动commit的，无法针对异常rollback。也就是说，你批量插入一堆数据，保不齐什么时候异常了，只插入了一半。至于说插入了多少数据，那不知道（自动commit的时机应该是客户端根据缓存自行确定的）。\n\n#### 测试实验\n这里我准备插入50w，所以让它在45w的时候异常，测试一下实际插入情况。  \n``` sql\n# 清空表\ntruncate user;\n# 构造1个唯一索引\ncreate unique index user_email_uindex\n\ton user (email);\n# 插入一条冲突数据（）\nINSERT INTO benchtest.user (id, name, sno, email, pass, source) VALUES (1, DEFAULT, null, 'email450000', '', '');\n```\n实验结果： 表中存在356961条数据\n> 说明：之前测试插入5w数据，想着4w5的时候异常，结果直接提交成功了。\n\n#### 批量插入优化\n既然知道问题是自动提交引发的，那么改成手动提交就可以了。  \n``` java\n   @Test\n    public void test2() throws SQLException {\n        String url = \"jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true\";\n        Connection connection = null;\n        try {\n            long start = System.currentTimeMillis();\n            connection = DriverManager.getConnection(url, username, password);\n            connection.setAutoCommit(false);\n            System.out.println(\"AutoCommit=\" + connection.getAutoCommit());\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO user (email, pass, name) VALUES (?, ?, ?)\");\n            for (int i = 0; i < 500000; i++) {\n                statement.setString(1, \"email\"+i);\n                statement.setString(2, \"pass\"+i);\n                statement.setString(3, \"name\"+i);\n                statement.addBatch();\n            }\n            int[] updateCounts = statement.executeBatch();\n            connection.commit();\n            long end = System.currentTimeMillis();\n            System.out.println(\"updateCounts=\" + updateCounts.length + \" cost=\" + (end-start)/1000);\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n            connection.rollback();\n        }finally {\n            if (connection != null) {\n                connection.close();\n            }\n        }\n    }\n```\n\n\n## 大结果集查询\n这个主要是defaultfetchsize的影响，默认0，即一次性获取全部结果。  \n\n具体参数可以参考[官网](https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-security.html#cj-conn-prop_allowMultiQueries)\n\n### jdbc\n``` java\n/**\n     * 客户端流式读取\n     * 测试时候设置  -Xmx5m -Xms5m， 然后对比 enableStreamingResults 差异\n     *\n     * 结果： 如果不设置流式读取，会OOM\n     *\n     * [原理] JDBC无论设置setFetchSize多少，都是客户端全部缓存后处理；当需要获取大量数据时，应该使用流式获取\n     * [注意] 流式Fetch会一直占用连接，慎用！\n     * @see 流式Fetch的坑 https://blog.csdn.net/nym232/article/details/89240054\n     */\n    @Test\n    public void streamFetch() {\n        Connection connection = null;\n        try {\n            String erpUrl = \"jdbc:mysql://localhost:3306/erp\";\n            connection = DriverManager.getConnection(erpUrl, username, password);\n            com.mysql.jdbc.PreparedStatement preparedStatement  = (com.mysql.jdbc.PreparedStatement)\n                    connection.prepareStatement(\"select * from erp_member_tag\");\n            preparedStatement.enableStreamingResults();\n            ResultSet rs = preparedStatement.executeQuery();\n            int i=1;\n            while (rs.next()) {\n                if (i%10000==0) {\n                    System.out.println((i++) + \"--\" +rs.getString(\"id\") + \"--\" + rs.getString(\"member_id\"));\n                }\n                i++;\n            }\n            System.err.println(\"end=\" + i);\n        }catch (SQLException throwables) {\n            throwables.printStackTrace();\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n```\n\n### jdbcTemplate\n``` java\n/**\n     * [无论是设置setFetchSize(Integer.MIN_VALUE)或是URL中制定，就可以直接使用流式结果集， 很多blog中说的模拟两可]\n     *\n     * 如果使用RowMapper，则会将每一行读入内存，将其转换为对象，最终仍会OOM\n     *\n     * 解决办法： 使用RowCallbackHandler 自己处理结果集\n     */\n    @Test\n    public void streamFetchByTemplate() {\n//        String url = \"jdbc:mysql://localhost:3306/erp\";\n        String url = \"jdbc:mysql://localhost:3306/erp?defaultfetchsize=-214783648\";\n        DriverManagerDataSource dataSource = new DriverManagerDataSource(url, username, password);\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n//        jdbcTemplate.setFetchSize(Integer.MIN_VALUE);\n        AtomicInteger i = new AtomicInteger();\n        jdbcTemplate.query(\"select * from erp_member_tag\", new RowCallbackHandler() {\n            @Override\n            public void processRow(ResultSet rs) throws SQLException {\n                int x = i.getAndIncrement();\n                if (x%10000==0) {\n                    System.out.println(x + \"--\" +rs.getString(\"id\") + \"--\" + rs.getString(\"member_id\"));\n                }\n            }\n        });\n        System.err.println(\"end=\" + i);\n    }\n```\n\n\n\n## jdbc参数最佳实践\n``` ini\n// 使用utf-8编码，注意：这是java中的编码，在mysql中utf8mb4对应的也是这个\ncharacterEncoding=utf8\n// 不使用证书\nuseSSL=false\n// 使用服务器端预处理语句\nuseServerPrepStmts=true\n// 指定单个预处理语句缓存的大小限制，默认256\n&prepStmtCacheSglLimit=10000000000\n// 指定要使用的预定义配置:高性能\n&useConfigs=maxPerformance\n// 指定是否将批量插入语句重写为多行插入语句\n&rewriteBatchedStatements=true\n// 从服务器返回行数，默认0，即默认一次返回所有行\n&defaultfetchsize=-214783648\n```","source":"_posts/jdbc处理大数据时的坑.md","raw":"---\ntitle: jdbc处理大数据时的坑\ndate: 2023-12-20 19:44:09\ntags: \n- jdbc\n- 数据库\n- 大数据\ncategories: 数据库\n---\n作为有点经验的java coder，使用jdbc或者mybatis的时候有没有发现一点问题？插入大量数据怎么这么慢！查询大量结果，怎么一下就OOM了！！\n<!--more-->\n\n## 先说结论 \n1. jdbc默认只会一条条执行insert，即使你调用的是batch\n2. jdbc默认一次性将全部结果拉取到客户端，数据量一大极容易OOM\n\n### 解决方案：\n1. url加上参数`rewriteBatchedStatements=true`,其作用是改写你的sql为多行insert/update\n2. url加上参数`defaultfetchsize=-214783648`,并使用`StreamingResult`\n\n### 实验准备\n不动手试试，总是无法辨明真伪的。  \n自行建一个有jdbc的项目，通过junit单元测试验证。\n - maven依赖:  \n``` xml\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.47</version>\n    </dependency>    \n\n        <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n```\n- jvm参数  \n不设置最大内存的话，特别是大量拉取的时候对比不了效果。我设置的最大堆内存是5m。  \n`-Xmx5m -Xms5m`  \n为方便，顺便打印下相关参数：  \n``` java\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n        runtimeMxBean.getInputArguments().stream().forEach(System.out::println);\n    }\n```\n\n## 批量插入\n```\n   /**\n     * 插入本地10w条数据，实验结果：\n     * 真批量：1s\n     * 假批量：超过6min，差别远不止别人测试几十倍。这个差距应该是随着数据量不断放大的\n     */\n    @Test\n    public void test2() {\n        String url = \"jdbc:mysql://localhost:3306/benchtest\";\n//        String url = \"jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true\";\n        Connection connection = null;\n        try {\n            long start = System.currentTimeMillis();\n            connection = DriverManager.getConnection(url, username, password);\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO user (email, pass, name) VALUES (?, ?, ?)\");\n            for (int i = 0; i < 100000; i++) {\n                statement.setString(1, \"email\"+i);\n                statement.setString(2, \"pass\"+i);\n                statement.setString(3, \"name\"+i);\n                statement.addBatch();\n            }\n            int[] updateCounts = statement.executeBatch();\n            connection.close();\n            long end = System.currentTimeMillis();\n            System.out.println(\"updateCounts=\" + updateCounts.length + \" cost=\" + (end-start)/1000);\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        }\n    }\n```\n\n### 批量插入可能存在的问题\n一般创建的连接都是自动commit的，无法针对异常rollback。也就是说，你批量插入一堆数据，保不齐什么时候异常了，只插入了一半。至于说插入了多少数据，那不知道（自动commit的时机应该是客户端根据缓存自行确定的）。\n\n#### 测试实验\n这里我准备插入50w，所以让它在45w的时候异常，测试一下实际插入情况。  \n``` sql\n# 清空表\ntruncate user;\n# 构造1个唯一索引\ncreate unique index user_email_uindex\n\ton user (email);\n# 插入一条冲突数据（）\nINSERT INTO benchtest.user (id, name, sno, email, pass, source) VALUES (1, DEFAULT, null, 'email450000', '', '');\n```\n实验结果： 表中存在356961条数据\n> 说明：之前测试插入5w数据，想着4w5的时候异常，结果直接提交成功了。\n\n#### 批量插入优化\n既然知道问题是自动提交引发的，那么改成手动提交就可以了。  \n``` java\n   @Test\n    public void test2() throws SQLException {\n        String url = \"jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true\";\n        Connection connection = null;\n        try {\n            long start = System.currentTimeMillis();\n            connection = DriverManager.getConnection(url, username, password);\n            connection.setAutoCommit(false);\n            System.out.println(\"AutoCommit=\" + connection.getAutoCommit());\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO user (email, pass, name) VALUES (?, ?, ?)\");\n            for (int i = 0; i < 500000; i++) {\n                statement.setString(1, \"email\"+i);\n                statement.setString(2, \"pass\"+i);\n                statement.setString(3, \"name\"+i);\n                statement.addBatch();\n            }\n            int[] updateCounts = statement.executeBatch();\n            connection.commit();\n            long end = System.currentTimeMillis();\n            System.out.println(\"updateCounts=\" + updateCounts.length + \" cost=\" + (end-start)/1000);\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n            connection.rollback();\n        }finally {\n            if (connection != null) {\n                connection.close();\n            }\n        }\n    }\n```\n\n\n## 大结果集查询\n这个主要是defaultfetchsize的影响，默认0，即一次性获取全部结果。  \n\n具体参数可以参考[官网](https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-security.html#cj-conn-prop_allowMultiQueries)\n\n### jdbc\n``` java\n/**\n     * 客户端流式读取\n     * 测试时候设置  -Xmx5m -Xms5m， 然后对比 enableStreamingResults 差异\n     *\n     * 结果： 如果不设置流式读取，会OOM\n     *\n     * [原理] JDBC无论设置setFetchSize多少，都是客户端全部缓存后处理；当需要获取大量数据时，应该使用流式获取\n     * [注意] 流式Fetch会一直占用连接，慎用！\n     * @see 流式Fetch的坑 https://blog.csdn.net/nym232/article/details/89240054\n     */\n    @Test\n    public void streamFetch() {\n        Connection connection = null;\n        try {\n            String erpUrl = \"jdbc:mysql://localhost:3306/erp\";\n            connection = DriverManager.getConnection(erpUrl, username, password);\n            com.mysql.jdbc.PreparedStatement preparedStatement  = (com.mysql.jdbc.PreparedStatement)\n                    connection.prepareStatement(\"select * from erp_member_tag\");\n            preparedStatement.enableStreamingResults();\n            ResultSet rs = preparedStatement.executeQuery();\n            int i=1;\n            while (rs.next()) {\n                if (i%10000==0) {\n                    System.out.println((i++) + \"--\" +rs.getString(\"id\") + \"--\" + rs.getString(\"member_id\"));\n                }\n                i++;\n            }\n            System.err.println(\"end=\" + i);\n        }catch (SQLException throwables) {\n            throwables.printStackTrace();\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n```\n\n### jdbcTemplate\n``` java\n/**\n     * [无论是设置setFetchSize(Integer.MIN_VALUE)或是URL中制定，就可以直接使用流式结果集， 很多blog中说的模拟两可]\n     *\n     * 如果使用RowMapper，则会将每一行读入内存，将其转换为对象，最终仍会OOM\n     *\n     * 解决办法： 使用RowCallbackHandler 自己处理结果集\n     */\n    @Test\n    public void streamFetchByTemplate() {\n//        String url = \"jdbc:mysql://localhost:3306/erp\";\n        String url = \"jdbc:mysql://localhost:3306/erp?defaultfetchsize=-214783648\";\n        DriverManagerDataSource dataSource = new DriverManagerDataSource(url, username, password);\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n//        jdbcTemplate.setFetchSize(Integer.MIN_VALUE);\n        AtomicInteger i = new AtomicInteger();\n        jdbcTemplate.query(\"select * from erp_member_tag\", new RowCallbackHandler() {\n            @Override\n            public void processRow(ResultSet rs) throws SQLException {\n                int x = i.getAndIncrement();\n                if (x%10000==0) {\n                    System.out.println(x + \"--\" +rs.getString(\"id\") + \"--\" + rs.getString(\"member_id\"));\n                }\n            }\n        });\n        System.err.println(\"end=\" + i);\n    }\n```\n\n\n\n## jdbc参数最佳实践\n``` ini\n// 使用utf-8编码，注意：这是java中的编码，在mysql中utf8mb4对应的也是这个\ncharacterEncoding=utf8\n// 不使用证书\nuseSSL=false\n// 使用服务器端预处理语句\nuseServerPrepStmts=true\n// 指定单个预处理语句缓存的大小限制，默认256\n&prepStmtCacheSglLimit=10000000000\n// 指定要使用的预定义配置:高性能\n&useConfigs=maxPerformance\n// 指定是否将批量插入语句重写为多行插入语句\n&rewriteBatchedStatements=true\n// 从服务器返回行数，默认0，即默认一次返回所有行\n&defaultfetchsize=-214783648\n```","slug":"jdbc处理大数据时的坑","published":1,"updated":"2024-04-24T08:05:12.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz50024qwvdclpq2zbu","content":"<p>作为有点经验的java coder，使用jdbc或者mybatis的时候有没有发现一点问题？插入大量数据怎么这么慢！查询大量结果，怎么一下就OOM了！！</p>\n<span id=\"more\"></span>\n\n<h2 id=\"先说结论\"><a href=\"#先说结论\" class=\"headerlink\" title=\"先说结论\"></a>先说结论</h2><ol>\n<li>jdbc默认只会一条条执行insert，即使你调用的是batch</li>\n<li>jdbc默认一次性将全部结果拉取到客户端，数据量一大极容易OOM</li>\n</ol>\n<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li>url加上参数<code>rewriteBatchedStatements=true</code>,其作用是改写你的sql为多行insert&#x2F;update</li>\n<li>url加上参数<code>defaultfetchsize=-214783648</code>,并使用<code>StreamingResult</code></li>\n</ol>\n<h3 id=\"实验准备\"><a href=\"#实验准备\" class=\"headerlink\" title=\"实验准备\"></a>实验准备</h3><p>不动手试试，总是无法辨明真伪的。<br>自行建一个有jdbc的项目，通过junit单元测试验证。</p>\n<ul>\n<li>maven依赖:  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.47<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span>    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>jvm参数<br>不设置最大内存的话，特别是大量拉取的时候对比不了效果。我设置的最大堆内存是5m。<br><code>-Xmx5m -Xms5m</code><br>为方便，顺便打印下相关参数：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@BeforeClass</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeClass</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();</span><br><span class=\"line\">    runtimeMxBean.getInputArguments().stream().forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"批量插入\"><a href=\"#批量插入\" class=\"headerlink\" title=\"批量插入\"></a>批量插入</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   /**</span><br><span class=\"line\">     * 插入本地10w条数据，实验结果：</span><br><span class=\"line\">     * 真批量：1s</span><br><span class=\"line\">     * 假批量：超过6min，差别远不止别人测试几十倍。这个差距应该是随着数据量不断放大的</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test2() &#123;</span><br><span class=\"line\">        String url = &quot;jdbc:mysql://localhost:3306/benchtest&quot;;</span><br><span class=\"line\">//        String url = &quot;jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true&quot;;</span><br><span class=\"line\">        Connection connection = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            long start = System.currentTimeMillis();</span><br><span class=\"line\">            connection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">            PreparedStatement statement = connection.prepareStatement(&quot;INSERT INTO user (email, pass, name) VALUES (?, ?, ?)&quot;);</span><br><span class=\"line\">            for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class=\"line\">                statement.setString(1, &quot;email&quot;+i);</span><br><span class=\"line\">                statement.setString(2, &quot;pass&quot;+i);</span><br><span class=\"line\">                statement.setString(3, &quot;name&quot;+i);</span><br><span class=\"line\">                statement.addBatch();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int[] updateCounts = statement.executeBatch();</span><br><span class=\"line\">            connection.close();</span><br><span class=\"line\">            long end = System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(&quot;updateCounts=&quot; + updateCounts.length + &quot; cost=&quot; + (end-start)/1000);</span><br><span class=\"line\">        &#125; catch (SQLException throwables) &#123;</span><br><span class=\"line\">            throwables.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"批量插入可能存在的问题\"><a href=\"#批量插入可能存在的问题\" class=\"headerlink\" title=\"批量插入可能存在的问题\"></a>批量插入可能存在的问题</h3><p>一般创建的连接都是自动commit的，无法针对异常rollback。也就是说，你批量插入一堆数据，保不齐什么时候异常了，只插入了一半。至于说插入了多少数据，那不知道（自动commit的时机应该是客户端根据缓存自行确定的）。</p>\n<h4 id=\"测试实验\"><a href=\"#测试实验\" class=\"headerlink\" title=\"测试实验\"></a>测试实验</h4><p>这里我准备插入50w，所以让它在45w的时候异常，测试一下实际插入情况。  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 清空表</span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"># 构造<span class=\"number\">1</span>个唯一索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> index user_email_uindex</span><br><span class=\"line\">\t<span class=\"keyword\">on</span> <span class=\"keyword\">user</span> (email);</span><br><span class=\"line\"># 插入一条冲突数据（）</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> benchtest.user (id, name, sno, email, pass, source) <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"keyword\">DEFAULT</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&#x27;email450000&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>实验结果： 表中存在356961条数据</p>\n<blockquote>\n<p>说明：之前测试插入5w数据，想着4w5的时候异常，结果直接提交成功了。</p>\n</blockquote>\n<h4 id=\"批量插入优化\"><a href=\"#批量插入优化\" class=\"headerlink\" title=\"批量插入优化\"></a>批量插入优化</h4><p>既然知道问题是自动提交引发的，那么改成手动提交就可以了。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">     String url = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true&quot;</span>;</span><br><span class=\"line\">     Connection connection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">         connection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">         connection.setAutoCommit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;AutoCommit=&quot;</span> + connection.getAutoCommit());</span><br><span class=\"line\">         PreparedStatement statement = connection.prepareStatement(<span class=\"string\">&quot;INSERT INTO user (email, pass, name) VALUES (?, ?, ?)&quot;</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500000</span>; i++) &#123;</span><br><span class=\"line\">             statement.setString(<span class=\"number\">1</span>, <span class=\"string\">&quot;email&quot;</span>+i);</span><br><span class=\"line\">             statement.setString(<span class=\"number\">2</span>, <span class=\"string\">&quot;pass&quot;</span>+i);</span><br><span class=\"line\">             statement.setString(<span class=\"number\">3</span>, <span class=\"string\">&quot;name&quot;</span>+i);</span><br><span class=\"line\">             statement.addBatch();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>[] updateCounts = statement.executeBatch();</span><br><span class=\"line\">         connection.commit();</span><br><span class=\"line\">         <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;updateCounts=&quot;</span> + updateCounts.length + <span class=\"string\">&quot; cost=&quot;</span> + (end-start)/<span class=\"number\">1000</span>);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">catch</span> (SQLException throwables) &#123;</span><br><span class=\"line\">         throwables.printStackTrace();</span><br><span class=\"line\">         connection.rollback();</span><br><span class=\"line\">     &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             connection.close();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"大结果集查询\"><a href=\"#大结果集查询\" class=\"headerlink\" title=\"大结果集查询\"></a>大结果集查询</h2><p>这个主要是defaultfetchsize的影响，默认0，即一次性获取全部结果。  </p>\n<p>具体参数可以参考<a href=\"https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-security.html#cj-conn-prop_allowMultiQueries\">官网</a></p>\n<h3 id=\"jdbc\"><a href=\"#jdbc\" class=\"headerlink\" title=\"jdbc\"></a>jdbc</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 客户端流式读取</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试时候设置  -Xmx5m -Xms5m， 然后对比 enableStreamingResults 差异</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 结果： 如果不设置流式读取，会OOM</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * [原理] JDBC无论设置setFetchSize多少，都是客户端全部缓存后处理；当需要获取大量数据时，应该使用流式获取</span></span><br><span class=\"line\"><span class=\"comment\">     * [注意] 流式Fetch会一直占用连接，慎用！</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span> 流式Fetch的坑 https://blog.csdn.net/nym232/article/details/89240054</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">streamFetch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String erpUrl = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/erp&quot;</span>;</span><br><span class=\"line\">            connection = DriverManager.getConnection(erpUrl, username, password);</span><br><span class=\"line\">            com.mysql.jdbc.PreparedStatement preparedStatement  = (com.mysql.jdbc.PreparedStatement)</span><br><span class=\"line\">                    connection.prepareStatement(<span class=\"string\">&quot;select * from erp_member_tag&quot;</span>);</span><br><span class=\"line\">            preparedStatement.enableStreamingResults();</span><br><span class=\"line\">            ResultSet rs = preparedStatement.executeQuery();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i%<span class=\"number\">10000</span>==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println((i++) + <span class=\"string\">&quot;--&quot;</span> +rs.getString(<span class=\"string\">&quot;id&quot;</span>) + <span class=\"string\">&quot;--&quot;</span> + rs.getString(<span class=\"string\">&quot;member_id&quot;</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;end=&quot;</span> + i);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (SQLException throwables) &#123;</span><br><span class=\"line\">            throwables.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                connection.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException throwables) &#123;</span><br><span class=\"line\">                throwables.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"jdbcTemplate\"><a href=\"#jdbcTemplate\" class=\"headerlink\" title=\"jdbcTemplate\"></a>jdbcTemplate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * [无论是设置setFetchSize(Integer.MIN_VALUE)或是URL中制定，就可以直接使用流式结果集， 很多blog中说的模拟两可]</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果使用RowMapper，则会将每一行读入内存，将其转换为对象，最终仍会OOM</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 解决办法： 使用RowCallbackHandler 自己处理结果集</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">streamFetchByTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        String url = &quot;jdbc:mysql://localhost:3306/erp&quot;;</span></span><br><span class=\"line\">        String url = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/erp?defaultfetchsize=-214783648&quot;</span>;</span><br><span class=\"line\">        DriverManagerDataSource dataSource = <span class=\"keyword\">new</span> DriverManagerDataSource(url, username, password);</span><br><span class=\"line\">        dataSource.setDriverClassName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">        JdbcTemplate jdbcTemplate = <span class=\"keyword\">new</span> JdbcTemplate(dataSource);</span><br><span class=\"line\"><span class=\"comment\">//        jdbcTemplate.setFetchSize(Integer.MIN_VALUE);</span></span><br><span class=\"line\">        AtomicInteger i = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">        jdbcTemplate.query(<span class=\"string\">&quot;select * from erp_member_tag&quot;</span>, <span class=\"keyword\">new</span> RowCallbackHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processRow</span><span class=\"params\">(ResultSet rs)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> x = i.getAndIncrement();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x%<span class=\"number\">10000</span>==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println(x + <span class=\"string\">&quot;--&quot;</span> +rs.getString(<span class=\"string\">&quot;id&quot;</span>) + <span class=\"string\">&quot;--&quot;</span> + rs.getString(<span class=\"string\">&quot;member_id&quot;</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.err.println(<span class=\"string\">&quot;end=&quot;</span> + i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"jdbc参数最佳实践\"><a href=\"#jdbc参数最佳实践\" class=\"headerlink\" title=\"jdbc参数最佳实践\"></a>jdbc参数最佳实践</h2><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用utf-8编码，注意：这是java中的编码，在mysql中utf8mb4对应的也是这个</span><br><span class=\"line\"><span class=\"attr\">characterEncoding</span>=utf8</span><br><span class=\"line\">// 不使用证书</span><br><span class=\"line\"><span class=\"attr\">useSSL</span>=<span class=\"literal\">false</span></span><br><span class=\"line\">// 使用服务器端预处理语句</span><br><span class=\"line\"><span class=\"attr\">useServerPrepStmts</span>=<span class=\"literal\">true</span></span><br><span class=\"line\">// 指定单个预处理语句缓存的大小限制，默认256</span><br><span class=\"line\">&amp;<span class=\"attr\">prepStmtCacheSglLimit</span>=<span class=\"number\">10000000000</span></span><br><span class=\"line\">// 指定要使用的预定义配置:高性能</span><br><span class=\"line\">&amp;<span class=\"attr\">useConfigs</span>=maxPerformance</span><br><span class=\"line\">// 指定是否将批量插入语句重写为多行插入语句</span><br><span class=\"line\">&amp;<span class=\"attr\">rewriteBatchedStatements</span>=<span class=\"literal\">true</span></span><br><span class=\"line\">// 从服务器返回行数，默认0，即默认一次返回所有行</span><br><span class=\"line\">&amp;<span class=\"attr\">defaultfetchsize</span>=-<span class=\"number\">214783648</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>作为有点经验的java coder，使用jdbc或者mybatis的时候有没有发现一点问题？插入大量数据怎么这么慢！查询大量结果，怎么一下就OOM了！！</p>","more":"<h2 id=\"先说结论\"><a href=\"#先说结论\" class=\"headerlink\" title=\"先说结论\"></a>先说结论</h2><ol>\n<li>jdbc默认只会一条条执行insert，即使你调用的是batch</li>\n<li>jdbc默认一次性将全部结果拉取到客户端，数据量一大极容易OOM</li>\n</ol>\n<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li>url加上参数<code>rewriteBatchedStatements=true</code>,其作用是改写你的sql为多行insert&#x2F;update</li>\n<li>url加上参数<code>defaultfetchsize=-214783648</code>,并使用<code>StreamingResult</code></li>\n</ol>\n<h3 id=\"实验准备\"><a href=\"#实验准备\" class=\"headerlink\" title=\"实验准备\"></a>实验准备</h3><p>不动手试试，总是无法辨明真伪的。<br>自行建一个有jdbc的项目，通过junit单元测试验证。</p>\n<ul>\n<li>maven依赖:  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.47<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span>    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>jvm参数<br>不设置最大内存的话，特别是大量拉取的时候对比不了效果。我设置的最大堆内存是5m。<br><code>-Xmx5m -Xms5m</code><br>为方便，顺便打印下相关参数：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@BeforeClass</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeClass</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();</span><br><span class=\"line\">    runtimeMxBean.getInputArguments().stream().forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"批量插入\"><a href=\"#批量插入\" class=\"headerlink\" title=\"批量插入\"></a>批量插入</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   /**</span><br><span class=\"line\">     * 插入本地10w条数据，实验结果：</span><br><span class=\"line\">     * 真批量：1s</span><br><span class=\"line\">     * 假批量：超过6min，差别远不止别人测试几十倍。这个差距应该是随着数据量不断放大的</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test2() &#123;</span><br><span class=\"line\">        String url = &quot;jdbc:mysql://localhost:3306/benchtest&quot;;</span><br><span class=\"line\">//        String url = &quot;jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true&quot;;</span><br><span class=\"line\">        Connection connection = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            long start = System.currentTimeMillis();</span><br><span class=\"line\">            connection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">            PreparedStatement statement = connection.prepareStatement(&quot;INSERT INTO user (email, pass, name) VALUES (?, ?, ?)&quot;);</span><br><span class=\"line\">            for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class=\"line\">                statement.setString(1, &quot;email&quot;+i);</span><br><span class=\"line\">                statement.setString(2, &quot;pass&quot;+i);</span><br><span class=\"line\">                statement.setString(3, &quot;name&quot;+i);</span><br><span class=\"line\">                statement.addBatch();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int[] updateCounts = statement.executeBatch();</span><br><span class=\"line\">            connection.close();</span><br><span class=\"line\">            long end = System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(&quot;updateCounts=&quot; + updateCounts.length + &quot; cost=&quot; + (end-start)/1000);</span><br><span class=\"line\">        &#125; catch (SQLException throwables) &#123;</span><br><span class=\"line\">            throwables.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"批量插入可能存在的问题\"><a href=\"#批量插入可能存在的问题\" class=\"headerlink\" title=\"批量插入可能存在的问题\"></a>批量插入可能存在的问题</h3><p>一般创建的连接都是自动commit的，无法针对异常rollback。也就是说，你批量插入一堆数据，保不齐什么时候异常了，只插入了一半。至于说插入了多少数据，那不知道（自动commit的时机应该是客户端根据缓存自行确定的）。</p>\n<h4 id=\"测试实验\"><a href=\"#测试实验\" class=\"headerlink\" title=\"测试实验\"></a>测试实验</h4><p>这里我准备插入50w，所以让它在45w的时候异常，测试一下实际插入情况。  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 清空表</span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"># 构造<span class=\"number\">1</span>个唯一索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> index user_email_uindex</span><br><span class=\"line\">\t<span class=\"keyword\">on</span> <span class=\"keyword\">user</span> (email);</span><br><span class=\"line\"># 插入一条冲突数据（）</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> benchtest.user (id, name, sno, email, pass, source) <span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"keyword\">DEFAULT</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&#x27;email450000&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>实验结果： 表中存在356961条数据</p>\n<blockquote>\n<p>说明：之前测试插入5w数据，想着4w5的时候异常，结果直接提交成功了。</p>\n</blockquote>\n<h4 id=\"批量插入优化\"><a href=\"#批量插入优化\" class=\"headerlink\" title=\"批量插入优化\"></a>批量插入优化</h4><p>既然知道问题是自动提交引发的，那么改成手动提交就可以了。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">     String url = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/benchtest?rewriteBatchedStatements=true&quot;</span>;</span><br><span class=\"line\">     Connection connection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">         connection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">         connection.setAutoCommit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;AutoCommit=&quot;</span> + connection.getAutoCommit());</span><br><span class=\"line\">         PreparedStatement statement = connection.prepareStatement(<span class=\"string\">&quot;INSERT INTO user (email, pass, name) VALUES (?, ?, ?)&quot;</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500000</span>; i++) &#123;</span><br><span class=\"line\">             statement.setString(<span class=\"number\">1</span>, <span class=\"string\">&quot;email&quot;</span>+i);</span><br><span class=\"line\">             statement.setString(<span class=\"number\">2</span>, <span class=\"string\">&quot;pass&quot;</span>+i);</span><br><span class=\"line\">             statement.setString(<span class=\"number\">3</span>, <span class=\"string\">&quot;name&quot;</span>+i);</span><br><span class=\"line\">             statement.addBatch();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">int</span>[] updateCounts = statement.executeBatch();</span><br><span class=\"line\">         connection.commit();</span><br><span class=\"line\">         <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;updateCounts=&quot;</span> + updateCounts.length + <span class=\"string\">&quot; cost=&quot;</span> + (end-start)/<span class=\"number\">1000</span>);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">catch</span> (SQLException throwables) &#123;</span><br><span class=\"line\">         throwables.printStackTrace();</span><br><span class=\"line\">         connection.rollback();</span><br><span class=\"line\">     &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             connection.close();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"大结果集查询\"><a href=\"#大结果集查询\" class=\"headerlink\" title=\"大结果集查询\"></a>大结果集查询</h2><p>这个主要是defaultfetchsize的影响，默认0，即一次性获取全部结果。  </p>\n<p>具体参数可以参考<a href=\"https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-security.html#cj-conn-prop_allowMultiQueries\">官网</a></p>\n<h3 id=\"jdbc\"><a href=\"#jdbc\" class=\"headerlink\" title=\"jdbc\"></a>jdbc</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 客户端流式读取</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试时候设置  -Xmx5m -Xms5m， 然后对比 enableStreamingResults 差异</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 结果： 如果不设置流式读取，会OOM</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * [原理] JDBC无论设置setFetchSize多少，都是客户端全部缓存后处理；当需要获取大量数据时，应该使用流式获取</span></span><br><span class=\"line\"><span class=\"comment\">     * [注意] 流式Fetch会一直占用连接，慎用！</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span> 流式Fetch的坑 https://blog.csdn.net/nym232/article/details/89240054</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">streamFetch</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String erpUrl = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/erp&quot;</span>;</span><br><span class=\"line\">            connection = DriverManager.getConnection(erpUrl, username, password);</span><br><span class=\"line\">            com.mysql.jdbc.PreparedStatement preparedStatement  = (com.mysql.jdbc.PreparedStatement)</span><br><span class=\"line\">                    connection.prepareStatement(<span class=\"string\">&quot;select * from erp_member_tag&quot;</span>);</span><br><span class=\"line\">            preparedStatement.enableStreamingResults();</span><br><span class=\"line\">            ResultSet rs = preparedStatement.executeQuery();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i%<span class=\"number\">10000</span>==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println((i++) + <span class=\"string\">&quot;--&quot;</span> +rs.getString(<span class=\"string\">&quot;id&quot;</span>) + <span class=\"string\">&quot;--&quot;</span> + rs.getString(<span class=\"string\">&quot;member_id&quot;</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;end=&quot;</span> + i);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (SQLException throwables) &#123;</span><br><span class=\"line\">            throwables.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                connection.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException throwables) &#123;</span><br><span class=\"line\">                throwables.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"jdbcTemplate\"><a href=\"#jdbcTemplate\" class=\"headerlink\" title=\"jdbcTemplate\"></a>jdbcTemplate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * [无论是设置setFetchSize(Integer.MIN_VALUE)或是URL中制定，就可以直接使用流式结果集， 很多blog中说的模拟两可]</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果使用RowMapper，则会将每一行读入内存，将其转换为对象，最终仍会OOM</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 解决办法： 使用RowCallbackHandler 自己处理结果集</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">streamFetchByTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        String url = &quot;jdbc:mysql://localhost:3306/erp&quot;;</span></span><br><span class=\"line\">        String url = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/erp?defaultfetchsize=-214783648&quot;</span>;</span><br><span class=\"line\">        DriverManagerDataSource dataSource = <span class=\"keyword\">new</span> DriverManagerDataSource(url, username, password);</span><br><span class=\"line\">        dataSource.setDriverClassName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">        JdbcTemplate jdbcTemplate = <span class=\"keyword\">new</span> JdbcTemplate(dataSource);</span><br><span class=\"line\"><span class=\"comment\">//        jdbcTemplate.setFetchSize(Integer.MIN_VALUE);</span></span><br><span class=\"line\">        AtomicInteger i = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">        jdbcTemplate.query(<span class=\"string\">&quot;select * from erp_member_tag&quot;</span>, <span class=\"keyword\">new</span> RowCallbackHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processRow</span><span class=\"params\">(ResultSet rs)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> x = i.getAndIncrement();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x%<span class=\"number\">10000</span>==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println(x + <span class=\"string\">&quot;--&quot;</span> +rs.getString(<span class=\"string\">&quot;id&quot;</span>) + <span class=\"string\">&quot;--&quot;</span> + rs.getString(<span class=\"string\">&quot;member_id&quot;</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.err.println(<span class=\"string\">&quot;end=&quot;</span> + i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"jdbc参数最佳实践\"><a href=\"#jdbc参数最佳实践\" class=\"headerlink\" title=\"jdbc参数最佳实践\"></a>jdbc参数最佳实践</h2><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用utf-8编码，注意：这是java中的编码，在mysql中utf8mb4对应的也是这个</span><br><span class=\"line\"><span class=\"attr\">characterEncoding</span>=utf8</span><br><span class=\"line\">// 不使用证书</span><br><span class=\"line\"><span class=\"attr\">useSSL</span>=<span class=\"literal\">false</span></span><br><span class=\"line\">// 使用服务器端预处理语句</span><br><span class=\"line\"><span class=\"attr\">useServerPrepStmts</span>=<span class=\"literal\">true</span></span><br><span class=\"line\">// 指定单个预处理语句缓存的大小限制，默认256</span><br><span class=\"line\">&amp;<span class=\"attr\">prepStmtCacheSglLimit</span>=<span class=\"number\">10000000000</span></span><br><span class=\"line\">// 指定要使用的预定义配置:高性能</span><br><span class=\"line\">&amp;<span class=\"attr\">useConfigs</span>=maxPerformance</span><br><span class=\"line\">// 指定是否将批量插入语句重写为多行插入语句</span><br><span class=\"line\">&amp;<span class=\"attr\">rewriteBatchedStatements</span>=<span class=\"literal\">true</span></span><br><span class=\"line\">// 从服务器返回行数，默认0，即默认一次返回所有行</span><br><span class=\"line\">&amp;<span class=\"attr\">defaultfetchsize</span>=-<span class=\"number\">214783648</span></span><br></pre></td></tr></table></figure>"},{"title":"kafka入门","date":"2023-09-14T06:37:52.000Z","_content":"一个大家都在用的分布式的事件流平台...\n<!--more-->\n![](https://kafka.apache.org/images/streams-and-tables-p1_p4.png)\n# quickStart\n> 不建议在windows上瞎折腾，没有云主机就装个虚拟机，装个Ubantu玩一下吧。zookeeper在windows下总是莫名崩溃...  \n> 建议结合官网[quickstart](https://kafka.apache.org/documentation/#quickstart)阅读\n\n\n## 下载安装包\n直接[官网下载](https://kafka.apache.org/downloads.html)版本2的二进制安装包。版本3中自己集成raft的模式在生产中应用不多。  \n1. 下载后解压到合适目录，设置kafka环境变量\n``` sh\nsudo vim /etc/profile.d/my env.sh\n# 增加如下内容:\n# KAFKA HOME\nexport KAFKA HOME=/opt/module/kafkaexport PATH-SPATH:SKAFKA HOME/bin\n# 生效\n/etc/profilesource\n```\n\n\n## 修改kafkaServer配置文件\n有几个重要配置需要check或修改\n``` ini\n# 如果存在多个kafkaServer，这个ID不能重复，且必须正整数\nbroker.id=0\n# kafka 运行日志(数据) 存放的路径，路径不需要提前创建\nlog.dirs=/opt/module/kafka/datas\n# 连接 Zookeeper 集群地址\nzookeeper.connect=localhost:2181/kafka\n# 如果是多个zookeeper,那么配置为 hadoop102:2181,hadoop104:2181/kafka\n```\n\n## 启动\n从命令行来体会下基本的运用：创建主题、订阅、消费  \n``` bash\n# 启动zookeeper\nbin/zookeeper-server-start.sh -daemon config/zookeeper.properties \n\n# 启动kafka\nbin/kafka-server-start.sh  -daemon config/server.properties\n\n# 查看主题\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --list\n\n# 创建主题\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --create --partitions 2 --replication-factor 1 --topic first\n\n# 消费消息\n## --from-beginning \nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --topic test\n\n# 发送消息\nbin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test\n```\n\n\n## 启动常见问题\n- Cluster ID xxx doesn’t match stored clusterId in meta.properties\n1. Step1:  日志中找到异常ID:  \n`p2Ke6DSDzfdcxcfarkcxJscoQ`  \n2. Step2:  \n`cat  $KAFKA_HOME/config/server.properties  | grep log.dir`  \n3. Step3: 编辑`meta.properties`并重启 \n    ``` ini\n    #Wed May 26 11:21:15 EET 2021\n    cluster.id=P2Ka7bKGmJwBduCchqrhsP\n    version=0\n    broker.id=0\n    ```\n\n# 生产者与消费者\n\n加入依赖  \n``` xml\n<dependency>\n<groupId>org.apache.kafka</groupId>\n<artifactId>kafka-clients</artifactId>\n<version>3.0.0</version>\n</dependency>\n```\n\n## java生产者\n``` java\n// 1. 创建kafka生产者的配置对象\nProperties properties = new Properties();\n\n// 2. 给kafka配置对象添加配置信息：bootstrap.servers\nproperties.put(ProducerConfigBOOTSTRAP_SERVERS_CONFIG, \"172.16.90.164:9092\");\n\n// 3. 创建kafka生产者对象\nKafkaProducer<String, String> kafkaProducer = new KafkaProducer<String, String>(properties);\n\n// 发送完成回调函数.\n// 注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试\nCallback callM = (metadata, exception) -> {\n    if (exception == null) {\n        // 没有异常,输出信息到控制台\n        System.out.println(\"主题：\" + metadata.topic()  + \" ->\"  + \"分区：\" + metadata.partition() );\n    } else {\n        // 出现异常打印\n        System.out.println(\"成产消息异常\" + exception.getMessage());\n        exception.printStackTrace();\n    }\n};\n\n// 4. 调用send方法,发送消息\nfor (int i = 0; i < 100; i++) {\n    /**\n        * 如果需要同步调用，直接future.get()即可\n        * ProducerRecord 的构造函数中可以指定分区 详情见\n        * @see org.apache.kafka.clients.producer.internals.DefaultPartitioner\n        */\n    String msg = \"[序号]\"+i + \"[时间]\" + LocalDateTime.now().toString();\n    Future<RecordMetadata> future = kafkaProducer.send(new ProducerRecord<>(\"third\", i%3, String.valueOf(i), msg), callM);\n    TimeUnit.MILLISECONDS.sleep(100L);\n}\n\n// 5. 关闭资源\nkafkaProducer.close();\n\n\n```\n\n## java消费者\n``` java\n//  Kafka从Broker中主动拉取数据\n//  同一消费者组的消费者会瓜分消息\n\n// 1.创建消费者的配置对象\nProperties properties = new Properties();\n\n// 2.给消费者配置对象添加参数\nproperties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"172.16.90.164:9092\");\n\n// 配置序列化 必须\nproperties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\nproperties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n\n// 配置消费者组（组名任意起名） 必须\nproperties.put(ConsumerConfig.GROUP_ID_CONFIG, \"consumer_group_001\");\n\n// 创建消费者对象\nKafkaConsumer<String, String> kafkaConsumer = new KafkaConsumer<String, String>(properties);\n\n// 注册要消费的主题（可以消费多个主题）\nkafkaConsumer.subscribe(Arrays.asList(\"third\"));\n\n// 是否自动提交offset\nproperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true);\n// 提交offset的时间周期1000ms，默认5s\nproperties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, 1000);\n\n// 拉取数据打印\nwhile (true) {\n    // 设置1s中消费一批数据\n    ConsumerRecords<String, String> consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(1));\n\n    if (consumerRecords.count() == 0) {\n        continue;\n    }\n    // 打印消费到的数据\n    for (ConsumerRecord<String, String> consumerRecord : consumerRecords) {\n        System.out.println(consumerRecord);\n        TimeUnit.MILLISECONDS.sleep(100L);\n    }\n\n}\n\n```\n\n\n# Kafka-Eagle监控\nEagle是一个带大屏的web监控，并支持新建主题、查看消息等强大功能\n\n## 安装\n> Ubantu默认安装了Jdk，却不设置home  \n``` bash\n# 先找到jdk安装地址\nreadlink -f `which java`\n\n# 配置JAVA_HOME\nsudo vim /etc/profile.d/env.sh\n    export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\n    export PATH=$PATH:$JAVA_HOME/bin\nsource /etc/profile\n```\n\n> 需要安装mysql  \n``` bash\nsudo apt install mysql-server\n```\n\n> 创建数据库和user  \n``` bash\ncreate database `ke` default character set utf8mb4 collate utf8mb4_general_ci;\nCREATE USER 'ke'@'localhost' IDENTIFIED BY 'ke@123456';\nGRANT ALL PRIVILEGES ON ke.* to 'ke'@'localhost';\nflush privileges;\n```\n\n\n> 修改配置文件\n``` sh \nvim conf/system-config.properties\n# 特别注意\nefak.zk.cluster.alias=cluster1\ncluster1.zk.list=localhost:2181/kafka\n# 重启\nbin/ke.sh  restart\n```\n\n","source":"_posts/kafka入门.md","raw":"---\ntitle: kafka入门\ndate: 2023-09-14 14:37:52\ntags: \n- kafka\ncategories: 中间件\n---\n一个大家都在用的分布式的事件流平台...\n<!--more-->\n![](https://kafka.apache.org/images/streams-and-tables-p1_p4.png)\n# quickStart\n> 不建议在windows上瞎折腾，没有云主机就装个虚拟机，装个Ubantu玩一下吧。zookeeper在windows下总是莫名崩溃...  \n> 建议结合官网[quickstart](https://kafka.apache.org/documentation/#quickstart)阅读\n\n\n## 下载安装包\n直接[官网下载](https://kafka.apache.org/downloads.html)版本2的二进制安装包。版本3中自己集成raft的模式在生产中应用不多。  \n1. 下载后解压到合适目录，设置kafka环境变量\n``` sh\nsudo vim /etc/profile.d/my env.sh\n# 增加如下内容:\n# KAFKA HOME\nexport KAFKA HOME=/opt/module/kafkaexport PATH-SPATH:SKAFKA HOME/bin\n# 生效\n/etc/profilesource\n```\n\n\n## 修改kafkaServer配置文件\n有几个重要配置需要check或修改\n``` ini\n# 如果存在多个kafkaServer，这个ID不能重复，且必须正整数\nbroker.id=0\n# kafka 运行日志(数据) 存放的路径，路径不需要提前创建\nlog.dirs=/opt/module/kafka/datas\n# 连接 Zookeeper 集群地址\nzookeeper.connect=localhost:2181/kafka\n# 如果是多个zookeeper,那么配置为 hadoop102:2181,hadoop104:2181/kafka\n```\n\n## 启动\n从命令行来体会下基本的运用：创建主题、订阅、消费  \n``` bash\n# 启动zookeeper\nbin/zookeeper-server-start.sh -daemon config/zookeeper.properties \n\n# 启动kafka\nbin/kafka-server-start.sh  -daemon config/server.properties\n\n# 查看主题\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --list\n\n# 创建主题\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --create --partitions 2 --replication-factor 1 --topic first\n\n# 消费消息\n## --from-beginning \nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --topic test\n\n# 发送消息\nbin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test\n```\n\n\n## 启动常见问题\n- Cluster ID xxx doesn’t match stored clusterId in meta.properties\n1. Step1:  日志中找到异常ID:  \n`p2Ke6DSDzfdcxcfarkcxJscoQ`  \n2. Step2:  \n`cat  $KAFKA_HOME/config/server.properties  | grep log.dir`  \n3. Step3: 编辑`meta.properties`并重启 \n    ``` ini\n    #Wed May 26 11:21:15 EET 2021\n    cluster.id=P2Ka7bKGmJwBduCchqrhsP\n    version=0\n    broker.id=0\n    ```\n\n# 生产者与消费者\n\n加入依赖  \n``` xml\n<dependency>\n<groupId>org.apache.kafka</groupId>\n<artifactId>kafka-clients</artifactId>\n<version>3.0.0</version>\n</dependency>\n```\n\n## java生产者\n``` java\n// 1. 创建kafka生产者的配置对象\nProperties properties = new Properties();\n\n// 2. 给kafka配置对象添加配置信息：bootstrap.servers\nproperties.put(ProducerConfigBOOTSTRAP_SERVERS_CONFIG, \"172.16.90.164:9092\");\n\n// 3. 创建kafka生产者对象\nKafkaProducer<String, String> kafkaProducer = new KafkaProducer<String, String>(properties);\n\n// 发送完成回调函数.\n// 注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试\nCallback callM = (metadata, exception) -> {\n    if (exception == null) {\n        // 没有异常,输出信息到控制台\n        System.out.println(\"主题：\" + metadata.topic()  + \" ->\"  + \"分区：\" + metadata.partition() );\n    } else {\n        // 出现异常打印\n        System.out.println(\"成产消息异常\" + exception.getMessage());\n        exception.printStackTrace();\n    }\n};\n\n// 4. 调用send方法,发送消息\nfor (int i = 0; i < 100; i++) {\n    /**\n        * 如果需要同步调用，直接future.get()即可\n        * ProducerRecord 的构造函数中可以指定分区 详情见\n        * @see org.apache.kafka.clients.producer.internals.DefaultPartitioner\n        */\n    String msg = \"[序号]\"+i + \"[时间]\" + LocalDateTime.now().toString();\n    Future<RecordMetadata> future = kafkaProducer.send(new ProducerRecord<>(\"third\", i%3, String.valueOf(i), msg), callM);\n    TimeUnit.MILLISECONDS.sleep(100L);\n}\n\n// 5. 关闭资源\nkafkaProducer.close();\n\n\n```\n\n## java消费者\n``` java\n//  Kafka从Broker中主动拉取数据\n//  同一消费者组的消费者会瓜分消息\n\n// 1.创建消费者的配置对象\nProperties properties = new Properties();\n\n// 2.给消费者配置对象添加参数\nproperties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"172.16.90.164:9092\");\n\n// 配置序列化 必须\nproperties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\nproperties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n\n// 配置消费者组（组名任意起名） 必须\nproperties.put(ConsumerConfig.GROUP_ID_CONFIG, \"consumer_group_001\");\n\n// 创建消费者对象\nKafkaConsumer<String, String> kafkaConsumer = new KafkaConsumer<String, String>(properties);\n\n// 注册要消费的主题（可以消费多个主题）\nkafkaConsumer.subscribe(Arrays.asList(\"third\"));\n\n// 是否自动提交offset\nproperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true);\n// 提交offset的时间周期1000ms，默认5s\nproperties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, 1000);\n\n// 拉取数据打印\nwhile (true) {\n    // 设置1s中消费一批数据\n    ConsumerRecords<String, String> consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(1));\n\n    if (consumerRecords.count() == 0) {\n        continue;\n    }\n    // 打印消费到的数据\n    for (ConsumerRecord<String, String> consumerRecord : consumerRecords) {\n        System.out.println(consumerRecord);\n        TimeUnit.MILLISECONDS.sleep(100L);\n    }\n\n}\n\n```\n\n\n# Kafka-Eagle监控\nEagle是一个带大屏的web监控，并支持新建主题、查看消息等强大功能\n\n## 安装\n> Ubantu默认安装了Jdk，却不设置home  \n``` bash\n# 先找到jdk安装地址\nreadlink -f `which java`\n\n# 配置JAVA_HOME\nsudo vim /etc/profile.d/env.sh\n    export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\n    export PATH=$PATH:$JAVA_HOME/bin\nsource /etc/profile\n```\n\n> 需要安装mysql  \n``` bash\nsudo apt install mysql-server\n```\n\n> 创建数据库和user  \n``` bash\ncreate database `ke` default character set utf8mb4 collate utf8mb4_general_ci;\nCREATE USER 'ke'@'localhost' IDENTIFIED BY 'ke@123456';\nGRANT ALL PRIVILEGES ON ke.* to 'ke'@'localhost';\nflush privileges;\n```\n\n\n> 修改配置文件\n``` sh \nvim conf/system-config.properties\n# 特别注意\nefak.zk.cluster.alias=cluster1\ncluster1.zk.list=localhost:2181/kafka\n# 重启\nbin/ke.sh  restart\n```\n\n","slug":"kafka入门","published":1,"updated":"2024-02-18T08:25:17.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz50027qwvdfi0xbonb","content":"<p>一个大家都在用的分布式的事件流平台…</p>\n<span id=\"more\"></span>\n<p><img src=\"https://kafka.apache.org/images/streams-and-tables-p1_p4.png\"></p>\n<h1 id=\"quickStart\"><a href=\"#quickStart\" class=\"headerlink\" title=\"quickStart\"></a>quickStart</h1><blockquote>\n<p>不建议在windows上瞎折腾，没有云主机就装个虚拟机，装个Ubantu玩一下吧。zookeeper在windows下总是莫名崩溃…<br>建议结合官网<a href=\"https://kafka.apache.org/documentation/#quickstart\">quickstart</a>阅读</p>\n</blockquote>\n<h2 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h2><p>直接<a href=\"https://kafka.apache.org/downloads.html\">官网下载</a>版本2的二进制安装包。版本3中自己集成raft的模式在生产中应用不多。  </p>\n<ol>\n<li>下载后解压到合适目录，设置kafka环境变量<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/profile.d/my env.sh</span><br><span class=\"line\"><span class=\"comment\"># 增加如下内容:</span></span><br><span class=\"line\"><span class=\"comment\"># KAFKA HOME</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA HOME=/opt/module/kafkaexport PATH-SPATH:SKAFKA HOME/bin</span><br><span class=\"line\"><span class=\"comment\"># 生效</span></span><br><span class=\"line\">/etc/profilesource</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"修改kafkaServer配置文件\"><a href=\"#修改kafkaServer配置文件\" class=\"headerlink\" title=\"修改kafkaServer配置文件\"></a>修改kafkaServer配置文件</h2><p>有几个重要配置需要check或修改</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果存在多个kafkaServer，这个ID不能重复，且必须正整数</span></span><br><span class=\"line\"><span class=\"attr\">broker.id</span>=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\"># kafka 运行日志(数据) 存放的路径，路径不需要提前创建</span></span><br><span class=\"line\"><span class=\"attr\">log.dirs</span>=/opt/module/kafka/datas</span><br><span class=\"line\"><span class=\"comment\"># 连接 Zookeeper 集群地址</span></span><br><span class=\"line\"><span class=\"attr\">zookeeper.connect</span>=localhost:<span class=\"number\">2181</span>/kafka</span><br><span class=\"line\"><span class=\"comment\"># 如果是多个zookeeper,那么配置为 hadoop102:2181,hadoop104:2181/kafka</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><p>从命令行来体会下基本的运用：创建主题、订阅、消费  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动zookeeper</span></span><br><span class=\"line\">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动kafka</span></span><br><span class=\"line\">bin/kafka-server-start.sh  -daemon config/server.properties</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看主题</span></span><br><span class=\"line\">bin/kafka-topics.sh --bootstrap-server localhost:9092 --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建主题</span></span><br><span class=\"line\">bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --partitions 2 --replication-factor 1 --topic first</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 消费消息</span></span><br><span class=\"line\"><span class=\"comment\">## --from-beginning </span></span><br><span class=\"line\">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --topic <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 发送消息</span></span><br><span class=\"line\">bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"启动常见问题\"><a href=\"#启动常见问题\" class=\"headerlink\" title=\"启动常见问题\"></a>启动常见问题</h2><ul>\n<li>Cluster ID xxx doesn’t match stored clusterId in meta.properties</li>\n</ul>\n<ol>\n<li>Step1:  日志中找到异常ID:<br><code>p2Ke6DSDzfdcxcfarkcxJscoQ</code>  </li>\n<li>Step2:<br><code>cat  $KAFKA_HOME/config/server.properties  | grep log.dir</code>  </li>\n<li>Step3: 编辑<code>meta.properties</code>并重启  <figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Wed May 26 11:21:15 EET 2021</span></span><br><span class=\"line\"><span class=\"attr\">cluster.id</span>=P2Ka7bKGmJwBduCchqrhsP</span><br><span class=\"line\"><span class=\"attr\">version</span>=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">broker.id</span>=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"生产者与消费者\"><a href=\"#生产者与消费者\" class=\"headerlink\" title=\"生产者与消费者\"></a>生产者与消费者</h1><p>加入依赖  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>kafka-clients<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"java生产者\"><a href=\"#java生产者\" class=\"headerlink\" title=\"java生产者\"></a>java生产者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建kafka生产者的配置对象</span></span><br><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 给kafka配置对象添加配置信息：bootstrap.servers</span></span><br><span class=\"line\">properties.put(ProducerConfigBOOTSTRAP_SERVERS_CONFIG, <span class=\"string\">&quot;172.16.90.164:9092&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 创建kafka生产者对象</span></span><br><span class=\"line\">KafkaProducer&lt;String, String&gt; kafkaProducer = <span class=\"keyword\">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送完成回调函数.</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试</span></span><br><span class=\"line\">Callback callM = (metadata, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 没有异常,输出信息到控制台</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;主题：&quot;</span> + metadata.topic()  + <span class=\"string\">&quot; -&gt;&quot;</span>  + <span class=\"string\">&quot;分区：&quot;</span> + metadata.partition() );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出现异常打印</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;成产消息异常&quot;</span> + exception.getMessage());</span><br><span class=\"line\">        exception.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 调用send方法,发送消息</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果需要同步调用，直接future.get()即可</span></span><br><span class=\"line\"><span class=\"comment\">        * ProducerRecord 的构造函数中可以指定分区 详情见</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@see</span> org.apache.kafka.clients.producer.internals.DefaultPartitioner</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    String msg = <span class=\"string\">&quot;[序号]&quot;</span>+i + <span class=\"string\">&quot;[时间]&quot;</span> + LocalDateTime.now().toString();</span><br><span class=\"line\">    Future&lt;RecordMetadata&gt; future = kafkaProducer.send(<span class=\"keyword\">new</span> ProducerRecord&lt;&gt;(<span class=\"string\">&quot;third&quot;</span>, i%<span class=\"number\">3</span>, String.valueOf(i), msg), callM);</span><br><span class=\"line\">    TimeUnit.MILLISECONDS.sleep(<span class=\"number\">100L</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 关闭资源</span></span><br><span class=\"line\">kafkaProducer.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"java消费者\"><a href=\"#java消费者\" class=\"headerlink\" title=\"java消费者\"></a>java消费者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  Kafka从Broker中主动拉取数据</span></span><br><span class=\"line\"><span class=\"comment\">//  同一消费者组的消费者会瓜分消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.创建消费者的配置对象</span></span><br><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.给消费者配置对象添加参数</span></span><br><span class=\"line\">properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class=\"string\">&quot;172.16.90.164:9092&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置序列化 必须</span></span><br><span class=\"line\">properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class=\"line\">properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置消费者组（组名任意起名） 必须</span></span><br><span class=\"line\">properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class=\"string\">&quot;consumer_group_001&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建消费者对象</span></span><br><span class=\"line\">KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class=\"keyword\">new</span> KafkaConsumer&lt;String, String&gt;(properties);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册要消费的主题（可以消费多个主题）</span></span><br><span class=\"line\">kafkaConsumer.subscribe(Arrays.asList(<span class=\"string\">&quot;third&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否自动提交offset</span></span><br><span class=\"line\">properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 提交offset的时间周期1000ms，默认5s</span></span><br><span class=\"line\">properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拉取数据打印</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置1s中消费一批数据</span></span><br><span class=\"line\">    ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (consumerRecords.count() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 打印消费到的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123;</span><br><span class=\"line\">        System.out.println(consumerRecord);</span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">100L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Kafka-Eagle监控\"><a href=\"#Kafka-Eagle监控\" class=\"headerlink\" title=\"Kafka-Eagle监控\"></a>Kafka-Eagle监控</h1><p>Eagle是一个带大屏的web监控，并支持新建主题、查看消息等强大功能</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>Ubantu默认安装了Jdk，却不设置home  </p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先找到jdk安装地址</span></span><br><span class=\"line\">readlink -f `<span class=\"built_in\">which</span> java`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置JAVA_HOME</span></span><br><span class=\"line\">sudo vim /etc/profile.d/env.sh</span><br><span class=\"line\">    <span class=\"built_in\">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class=\"line\">    <span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$JAVA_HOME</span>/bin</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要安装mysql  </p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install mysql-server</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建数据库和user  </p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database `ke` default character <span class=\"built_in\">set</span> utf8mb4 collate utf8mb4_general_ci;</span><br><span class=\"line\">CREATE USER <span class=\"string\">&#x27;ke&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class=\"string\">&#x27;ke@123456&#x27;</span>;</span><br><span class=\"line\">GRANT ALL PRIVILEGES ON ke.* to <span class=\"string\">&#x27;ke&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>修改配置文件</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim conf/system-config.properties</span><br><span class=\"line\"><span class=\"comment\"># 特别注意</span></span><br><span class=\"line\">efak.zk.cluster.alias=cluster1</span><br><span class=\"line\">cluster1.zk.list=localhost:2181/kafka</span><br><span class=\"line\"><span class=\"comment\"># 重启</span></span><br><span class=\"line\">bin/ke.sh  restart</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>一个大家都在用的分布式的事件流平台…</p>","more":"<p><img src=\"https://kafka.apache.org/images/streams-and-tables-p1_p4.png\"></p>\n<h1 id=\"quickStart\"><a href=\"#quickStart\" class=\"headerlink\" title=\"quickStart\"></a>quickStart</h1><blockquote>\n<p>不建议在windows上瞎折腾，没有云主机就装个虚拟机，装个Ubantu玩一下吧。zookeeper在windows下总是莫名崩溃…<br>建议结合官网<a href=\"https://kafka.apache.org/documentation/#quickstart\">quickstart</a>阅读</p>\n</blockquote>\n<h2 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h2><p>直接<a href=\"https://kafka.apache.org/downloads.html\">官网下载</a>版本2的二进制安装包。版本3中自己集成raft的模式在生产中应用不多。  </p>\n<ol>\n<li>下载后解压到合适目录，设置kafka环境变量<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/profile.d/my env.sh</span><br><span class=\"line\"><span class=\"comment\"># 增加如下内容:</span></span><br><span class=\"line\"><span class=\"comment\"># KAFKA HOME</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA HOME=/opt/module/kafkaexport PATH-SPATH:SKAFKA HOME/bin</span><br><span class=\"line\"><span class=\"comment\"># 生效</span></span><br><span class=\"line\">/etc/profilesource</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"修改kafkaServer配置文件\"><a href=\"#修改kafkaServer配置文件\" class=\"headerlink\" title=\"修改kafkaServer配置文件\"></a>修改kafkaServer配置文件</h2><p>有几个重要配置需要check或修改</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果存在多个kafkaServer，这个ID不能重复，且必须正整数</span></span><br><span class=\"line\"><span class=\"attr\">broker.id</span>=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\"># kafka 运行日志(数据) 存放的路径，路径不需要提前创建</span></span><br><span class=\"line\"><span class=\"attr\">log.dirs</span>=/opt/module/kafka/datas</span><br><span class=\"line\"><span class=\"comment\"># 连接 Zookeeper 集群地址</span></span><br><span class=\"line\"><span class=\"attr\">zookeeper.connect</span>=localhost:<span class=\"number\">2181</span>/kafka</span><br><span class=\"line\"><span class=\"comment\"># 如果是多个zookeeper,那么配置为 hadoop102:2181,hadoop104:2181/kafka</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><p>从命令行来体会下基本的运用：创建主题、订阅、消费  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动zookeeper</span></span><br><span class=\"line\">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动kafka</span></span><br><span class=\"line\">bin/kafka-server-start.sh  -daemon config/server.properties</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看主题</span></span><br><span class=\"line\">bin/kafka-topics.sh --bootstrap-server localhost:9092 --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建主题</span></span><br><span class=\"line\">bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --partitions 2 --replication-factor 1 --topic first</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 消费消息</span></span><br><span class=\"line\"><span class=\"comment\">## --from-beginning </span></span><br><span class=\"line\">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --topic <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 发送消息</span></span><br><span class=\"line\">bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"启动常见问题\"><a href=\"#启动常见问题\" class=\"headerlink\" title=\"启动常见问题\"></a>启动常见问题</h2><ul>\n<li>Cluster ID xxx doesn’t match stored clusterId in meta.properties</li>\n</ul>\n<ol>\n<li>Step1:  日志中找到异常ID:<br><code>p2Ke6DSDzfdcxcfarkcxJscoQ</code>  </li>\n<li>Step2:<br><code>cat  $KAFKA_HOME/config/server.properties  | grep log.dir</code>  </li>\n<li>Step3: 编辑<code>meta.properties</code>并重启  <figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Wed May 26 11:21:15 EET 2021</span></span><br><span class=\"line\"><span class=\"attr\">cluster.id</span>=P2Ka7bKGmJwBduCchqrhsP</span><br><span class=\"line\"><span class=\"attr\">version</span>=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">broker.id</span>=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"生产者与消费者\"><a href=\"#生产者与消费者\" class=\"headerlink\" title=\"生产者与消费者\"></a>生产者与消费者</h1><p>加入依赖  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>kafka-clients<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"java生产者\"><a href=\"#java生产者\" class=\"headerlink\" title=\"java生产者\"></a>java生产者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建kafka生产者的配置对象</span></span><br><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 给kafka配置对象添加配置信息：bootstrap.servers</span></span><br><span class=\"line\">properties.put(ProducerConfigBOOTSTRAP_SERVERS_CONFIG, <span class=\"string\">&quot;172.16.90.164:9092&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 创建kafka生产者对象</span></span><br><span class=\"line\">KafkaProducer&lt;String, String&gt; kafkaProducer = <span class=\"keyword\">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送完成回调函数.</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试</span></span><br><span class=\"line\">Callback callM = (metadata, exception) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 没有异常,输出信息到控制台</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;主题：&quot;</span> + metadata.topic()  + <span class=\"string\">&quot; -&gt;&quot;</span>  + <span class=\"string\">&quot;分区：&quot;</span> + metadata.partition() );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出现异常打印</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;成产消息异常&quot;</span> + exception.getMessage());</span><br><span class=\"line\">        exception.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 调用send方法,发送消息</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果需要同步调用，直接future.get()即可</span></span><br><span class=\"line\"><span class=\"comment\">        * ProducerRecord 的构造函数中可以指定分区 详情见</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@see</span> org.apache.kafka.clients.producer.internals.DefaultPartitioner</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    String msg = <span class=\"string\">&quot;[序号]&quot;</span>+i + <span class=\"string\">&quot;[时间]&quot;</span> + LocalDateTime.now().toString();</span><br><span class=\"line\">    Future&lt;RecordMetadata&gt; future = kafkaProducer.send(<span class=\"keyword\">new</span> ProducerRecord&lt;&gt;(<span class=\"string\">&quot;third&quot;</span>, i%<span class=\"number\">3</span>, String.valueOf(i), msg), callM);</span><br><span class=\"line\">    TimeUnit.MILLISECONDS.sleep(<span class=\"number\">100L</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 关闭资源</span></span><br><span class=\"line\">kafkaProducer.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"java消费者\"><a href=\"#java消费者\" class=\"headerlink\" title=\"java消费者\"></a>java消费者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  Kafka从Broker中主动拉取数据</span></span><br><span class=\"line\"><span class=\"comment\">//  同一消费者组的消费者会瓜分消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.创建消费者的配置对象</span></span><br><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.给消费者配置对象添加参数</span></span><br><span class=\"line\">properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class=\"string\">&quot;172.16.90.164:9092&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置序列化 必须</span></span><br><span class=\"line\">properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class=\"line\">properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置消费者组（组名任意起名） 必须</span></span><br><span class=\"line\">properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class=\"string\">&quot;consumer_group_001&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建消费者对象</span></span><br><span class=\"line\">KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class=\"keyword\">new</span> KafkaConsumer&lt;String, String&gt;(properties);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册要消费的主题（可以消费多个主题）</span></span><br><span class=\"line\">kafkaConsumer.subscribe(Arrays.asList(<span class=\"string\">&quot;third&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否自动提交offset</span></span><br><span class=\"line\">properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 提交offset的时间周期1000ms，默认5s</span></span><br><span class=\"line\">properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拉取数据打印</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置1s中消费一批数据</span></span><br><span class=\"line\">    ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (consumerRecords.count() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 打印消费到的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123;</span><br><span class=\"line\">        System.out.println(consumerRecord);</span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">100L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Kafka-Eagle监控\"><a href=\"#Kafka-Eagle监控\" class=\"headerlink\" title=\"Kafka-Eagle监控\"></a>Kafka-Eagle监控</h1><p>Eagle是一个带大屏的web监控，并支持新建主题、查看消息等强大功能</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>Ubantu默认安装了Jdk，却不设置home  </p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先找到jdk安装地址</span></span><br><span class=\"line\">readlink -f `<span class=\"built_in\">which</span> java`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置JAVA_HOME</span></span><br><span class=\"line\">sudo vim /etc/profile.d/env.sh</span><br><span class=\"line\">    <span class=\"built_in\">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class=\"line\">    <span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$JAVA_HOME</span>/bin</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要安装mysql  </p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install mysql-server</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建数据库和user  </p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database `ke` default character <span class=\"built_in\">set</span> utf8mb4 collate utf8mb4_general_ci;</span><br><span class=\"line\">CREATE USER <span class=\"string\">&#x27;ke&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class=\"string\">&#x27;ke@123456&#x27;</span>;</span><br><span class=\"line\">GRANT ALL PRIVILEGES ON ke.* to <span class=\"string\">&#x27;ke&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>修改配置文件</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim conf/system-config.properties</span><br><span class=\"line\"><span class=\"comment\"># 特别注意</span></span><br><span class=\"line\">efak.zk.cluster.alias=cluster1</span><br><span class=\"line\">cluster1.zk.list=localhost:2181/kafka</span><br><span class=\"line\"><span class=\"comment\"># 重启</span></span><br><span class=\"line\">bin/ke.sh  restart</span><br></pre></td></tr></table></figure>"},{"title":"kubernetes-2-相关概念","date":"2024-01-30T06:53:00.000Z","_content":"k8s是未来，理解各类基本概念再开始\n<!--more-->  \n\n![image](/image/assets/image-20240116183723-ievwwyy.png)\n\n## 元数据类型\n\n* HPA：扩容缩容\n* PodTemplate\n* LimitRange\n\n\n## 集群类型\n\nNameSpace\n\nNode\n\nClusterRole\n\n\n## 命名空间\n\n\n### 工作负载\n\n* Pod： 容器组（共享网络、存储和依赖，它们被分配到同一Node，被同时调用；因此，应该是同一类型的应用运行在同一Pod中，一般只有一个容器）\n\n* Controller： 可以创建和管理多个 Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个 Node 故障，Controller 就能自动将该节点上的 Pod 调度到其他健康的 Node 上\n\n  * 无状态\n\n    * Replication Controllers（RC， 动态控制副本数量）\n    * ReplicaSet（RS，通过selector选择对哪些pod生效）\n    * Deployment（对RS更高级的封装）\n\n      1. 创建RS\n      2. 滚动升级/回滚\n      3. 平滑扩容/缩容\n      4. 暂停与恢复\n  * 有状态（针对持久化、网络标识、有序部署）\n\n    * Headless Service（DNS域管理）\n    * volumeClaimTemplates（持久化）\n  * DaemonSet（日志、监控）\n  * Job/CronJob\n\n\n### 服务发现\n\n- \t横向流量：Service\n- \t纵向流量：Ingress\n\n![image](/images/assets/image-20240116183723-ievwwyy.png)\n\n- 集群内访问与集群外访问\n![image](/imagesassets/image-20240116183756-jtgrcuo.png)\n\n\n### 存储\n\n* [Volume](https://lib.jimmysong.io/kubernetes-handbook/storage/volume/)\n* CSI（容器持久化存储标准）\n\n\n### 配置\n\n[ConfigMap](https://lib.jimmysong.io/kubernetes-handbook/storage/configmap/)\n\n[Secret](https://lib.jimmysong.io/kubernetes-handbook/storage/secret/)\n\nDownwardAPI（将Pod信息暴露到容器内）\n\n\n### 其他\n\n* Role\n* RoleBinding\n\n---\n\n","source":"_posts/kubernetes-2-相关概念.md","raw":"---\ntitle: kubernetes-2-相关概念\ndate: 2024-01-30 14:53:00\ntags: kubernetes\ncategories: 云原生\n---\nk8s是未来，理解各类基本概念再开始\n<!--more-->  \n\n![image](/image/assets/image-20240116183723-ievwwyy.png)\n\n## 元数据类型\n\n* HPA：扩容缩容\n* PodTemplate\n* LimitRange\n\n\n## 集群类型\n\nNameSpace\n\nNode\n\nClusterRole\n\n\n## 命名空间\n\n\n### 工作负载\n\n* Pod： 容器组（共享网络、存储和依赖，它们被分配到同一Node，被同时调用；因此，应该是同一类型的应用运行在同一Pod中，一般只有一个容器）\n\n* Controller： 可以创建和管理多个 Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个 Node 故障，Controller 就能自动将该节点上的 Pod 调度到其他健康的 Node 上\n\n  * 无状态\n\n    * Replication Controllers（RC， 动态控制副本数量）\n    * ReplicaSet（RS，通过selector选择对哪些pod生效）\n    * Deployment（对RS更高级的封装）\n\n      1. 创建RS\n      2. 滚动升级/回滚\n      3. 平滑扩容/缩容\n      4. 暂停与恢复\n  * 有状态（针对持久化、网络标识、有序部署）\n\n    * Headless Service（DNS域管理）\n    * volumeClaimTemplates（持久化）\n  * DaemonSet（日志、监控）\n  * Job/CronJob\n\n\n### 服务发现\n\n- \t横向流量：Service\n- \t纵向流量：Ingress\n\n![image](/images/assets/image-20240116183723-ievwwyy.png)\n\n- 集群内访问与集群外访问\n![image](/imagesassets/image-20240116183756-jtgrcuo.png)\n\n\n### 存储\n\n* [Volume](https://lib.jimmysong.io/kubernetes-handbook/storage/volume/)\n* CSI（容器持久化存储标准）\n\n\n### 配置\n\n[ConfigMap](https://lib.jimmysong.io/kubernetes-handbook/storage/configmap/)\n\n[Secret](https://lib.jimmysong.io/kubernetes-handbook/storage/secret/)\n\nDownwardAPI（将Pod信息暴露到容器内）\n\n\n### 其他\n\n* Role\n* RoleBinding\n\n---\n\n","slug":"kubernetes-2-相关概念","published":1,"updated":"2024-02-18T08:27:15.608Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz6002aqwvdd2j08ho0","content":"<p>k8s是未来，理解各类基本概念再开始</p>\n<span id=\"more\"></span>  \n\n<p><img src=\"/.io//assets/image-20240116183723-ievwwyy.png\" alt=\"image\"></p>\n<h2 id=\"元数据类型\"><a href=\"#元数据类型\" class=\"headerlink\" title=\"元数据类型\"></a>元数据类型</h2><ul>\n<li>HPA：扩容缩容</li>\n<li>PodTemplate</li>\n<li>LimitRange</li>\n</ul>\n<h2 id=\"集群类型\"><a href=\"#集群类型\" class=\"headerlink\" title=\"集群类型\"></a>集群类型</h2><p>NameSpace</p>\n<p>Node</p>\n<p>ClusterRole</p>\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><h3 id=\"工作负载\"><a href=\"#工作负载\" class=\"headerlink\" title=\"工作负载\"></a>工作负载</h3><ul>\n<li><p>Pod： 容器组（共享网络、存储和依赖，它们被分配到同一Node，被同时调用；因此，应该是同一类型的应用运行在同一Pod中，一般只有一个容器）</p>\n</li>\n<li><p>Controller： 可以创建和管理多个 Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个 Node 故障，Controller 就能自动将该节点上的 Pod 调度到其他健康的 Node 上</p>\n<ul>\n<li><p>无状态</p>\n<ul>\n<li><p>Replication Controllers（RC， 动态控制副本数量）</p>\n</li>\n<li><p>ReplicaSet（RS，通过selector选择对哪些pod生效）</p>\n</li>\n<li><p>Deployment（对RS更高级的封装）</p>\n<ol>\n<li>创建RS</li>\n<li>滚动升级&#x2F;回滚</li>\n<li>平滑扩容&#x2F;缩容</li>\n<li>暂停与恢复</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>有状态（针对持久化、网络标识、有序部署）</p>\n<ul>\n<li>Headless Service（DNS域管理）</li>\n<li>volumeClaimTemplates（持久化）</li>\n</ul>\n</li>\n<li><p>DaemonSet（日志、监控）</p>\n</li>\n<li><p>Job&#x2F;CronJob</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h3><ul>\n<li><pre><code>横向流量：Service\n</code></pre>\n</li>\n<li><pre><code>纵向流量：Ingress\n</code></pre>\n</li>\n</ul>\n<p><img src=\"/images/assets/image-20240116183723-ievwwyy.png\" alt=\"image\"></p>\n<ul>\n<li>集群内访问与集群外访问<br><img src=\"/.io//image-20240116183756-jtgrcuo.png\" alt=\"image\"></li>\n</ul>\n<h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><ul>\n<li><a href=\"https://lib.jimmysong.io/kubernetes-handbook/storage/volume/\">Volume</a></li>\n<li>CSI（容器持久化存储标准）</li>\n</ul>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p><a href=\"https://lib.jimmysong.io/kubernetes-handbook/storage/configmap/\">ConfigMap</a></p>\n<p><a href=\"https://lib.jimmysong.io/kubernetes-handbook/storage/secret/\">Secret</a></p>\n<p>DownwardAPI（将Pod信息暴露到容器内）</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>Role</li>\n<li>RoleBinding</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<p>k8s是未来，理解各类基本概念再开始</p>","more":"<p><img src=\"/.io//assets/image-20240116183723-ievwwyy.png\" alt=\"image\"></p>\n<h2 id=\"元数据类型\"><a href=\"#元数据类型\" class=\"headerlink\" title=\"元数据类型\"></a>元数据类型</h2><ul>\n<li>HPA：扩容缩容</li>\n<li>PodTemplate</li>\n<li>LimitRange</li>\n</ul>\n<h2 id=\"集群类型\"><a href=\"#集群类型\" class=\"headerlink\" title=\"集群类型\"></a>集群类型</h2><p>NameSpace</p>\n<p>Node</p>\n<p>ClusterRole</p>\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><h3 id=\"工作负载\"><a href=\"#工作负载\" class=\"headerlink\" title=\"工作负载\"></a>工作负载</h3><ul>\n<li><p>Pod： 容器组（共享网络、存储和依赖，它们被分配到同一Node，被同时调用；因此，应该是同一类型的应用运行在同一Pod中，一般只有一个容器）</p>\n</li>\n<li><p>Controller： 可以创建和管理多个 Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个 Node 故障，Controller 就能自动将该节点上的 Pod 调度到其他健康的 Node 上</p>\n<ul>\n<li><p>无状态</p>\n<ul>\n<li><p>Replication Controllers（RC， 动态控制副本数量）</p>\n</li>\n<li><p>ReplicaSet（RS，通过selector选择对哪些pod生效）</p>\n</li>\n<li><p>Deployment（对RS更高级的封装）</p>\n<ol>\n<li>创建RS</li>\n<li>滚动升级&#x2F;回滚</li>\n<li>平滑扩容&#x2F;缩容</li>\n<li>暂停与恢复</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>有状态（针对持久化、网络标识、有序部署）</p>\n<ul>\n<li>Headless Service（DNS域管理）</li>\n<li>volumeClaimTemplates（持久化）</li>\n</ul>\n</li>\n<li><p>DaemonSet（日志、监控）</p>\n</li>\n<li><p>Job&#x2F;CronJob</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h3><ul>\n<li><pre><code>横向流量：Service\n</code></pre>\n</li>\n<li><pre><code>纵向流量：Ingress\n</code></pre>\n</li>\n</ul>\n<p><img src=\"/images/assets/image-20240116183723-ievwwyy.png\" alt=\"image\"></p>\n<ul>\n<li>集群内访问与集群外访问<br><img src=\"/.io//image-20240116183756-jtgrcuo.png\" alt=\"image\"></li>\n</ul>\n<h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><ul>\n<li><a href=\"https://lib.jimmysong.io/kubernetes-handbook/storage/volume/\">Volume</a></li>\n<li>CSI（容器持久化存储标准）</li>\n</ul>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p><a href=\"https://lib.jimmysong.io/kubernetes-handbook/storage/configmap/\">ConfigMap</a></p>\n<p><a href=\"https://lib.jimmysong.io/kubernetes-handbook/storage/secret/\">Secret</a></p>\n<p>DownwardAPI（将Pod信息暴露到容器内）</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>Role</li>\n<li>RoleBinding</li>\n</ul>\n<hr>"},{"title":"kubernetes-1-基本架构","date":"2024-01-03T12:36:05.000Z","_content":"k8s是未来，理解架构\n<!--more-->\n\n\n​![image](/images/assets/image-20240116140626-xdrpftt.png)​\n\n\n​​![image](/images/assets/image-20240117120120-oyzznx1.png)​​\n\n‍\n## 组件及概念\n\n### Master\n\n1. ApiServer： 接口服务\n2. kube-Controller-manager ： 控制器管理器\n3. cloud-Controller-manager ： 第三方控制器管理器\n4. kube-scheduler： （节点）调度器\n\n‍\n\n### Node\n\n1. kubelet：负责Pod生命周期、存储、网络\n2. kube-proxy： 网络代理、服务发现负载\n3. Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器\n4. container-runtime： 容器运行时环境（docker、containerd...）\n\n‍\n\n### k8s生态架构\n\n* 核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境\n* 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）、Service Mesh（部分位于应用层）\n* 管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）、Service Mesh（部分位于管理层）\n* 接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦\n* 生态系统：日志监控/集群配置等\n> 作为开发者，最主要的就是理解服务、任务的执行部署方式，熟悉kubectl和API的使用，了解流量控制  \n\n\n\n\n\n---\n学习资料:\n\n[2.2.2_集群架构与组件-组件详解：核心组件与分层架构_bilibili_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1MT411x7GH?p=10&spm_id_from=pageDriver&vd_source=eeb1c6e015a7ca03cb75e71d6ae0a6e1)  \n\n[Kubernetes 架构 | 云原生资料库 (jimmysong.io)](https://lib.jimmysong.io/kubernetes-handbook/architecture/)  \n\n\n","source":"_posts/kubernetes-1-基本架构.md","raw":"---\ntitle: kubernetes-1-基本架构\ndate: 2024-01-03 20:36:05\ntags: kubernetes\ncategories: 云原生\n---\nk8s是未来，理解架构\n<!--more-->\n\n\n​![image](/images/assets/image-20240116140626-xdrpftt.png)​\n\n\n​​![image](/images/assets/image-20240117120120-oyzznx1.png)​​\n\n‍\n## 组件及概念\n\n### Master\n\n1. ApiServer： 接口服务\n2. kube-Controller-manager ： 控制器管理器\n3. cloud-Controller-manager ： 第三方控制器管理器\n4. kube-scheduler： （节点）调度器\n\n‍\n\n### Node\n\n1. kubelet：负责Pod生命周期、存储、网络\n2. kube-proxy： 网络代理、服务发现负载\n3. Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器\n4. container-runtime： 容器运行时环境（docker、containerd...）\n\n‍\n\n### k8s生态架构\n\n* 核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境\n* 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）、Service Mesh（部分位于应用层）\n* 管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）、Service Mesh（部分位于管理层）\n* 接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦\n* 生态系统：日志监控/集群配置等\n> 作为开发者，最主要的就是理解服务、任务的执行部署方式，熟悉kubectl和API的使用，了解流量控制  \n\n\n\n\n\n---\n学习资料:\n\n[2.2.2_集群架构与组件-组件详解：核心组件与分层架构_bilibili_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1MT411x7GH?p=10&spm_id_from=pageDriver&vd_source=eeb1c6e015a7ca03cb75e71d6ae0a6e1)  \n\n[Kubernetes 架构 | 云原生资料库 (jimmysong.io)](https://lib.jimmysong.io/kubernetes-handbook/architecture/)  \n\n\n","slug":"kubernetes-1-基本架构","published":1,"updated":"2024-02-18T08:26:54.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz6002cqwvd5w9u51dp","content":"<p>k8s是未来，理解架构</p>\n<span id=\"more\"></span>\n\n\n<p>​<img src=\"/images/assets/image-20240116140626-xdrpftt.png\" alt=\"image\">​</p>\n<p>​​<img src=\"/images/assets/image-20240117120120-oyzznx1.png\" alt=\"image\">​​</p>\n<p>‍</p>\n<h2 id=\"组件及概念\"><a href=\"#组件及概念\" class=\"headerlink\" title=\"组件及概念\"></a>组件及概念</h2><h3 id=\"Master\"><a href=\"#Master\" class=\"headerlink\" title=\"Master\"></a>Master</h3><ol>\n<li>ApiServer： 接口服务</li>\n<li>kube-Controller-manager ： 控制器管理器</li>\n<li>cloud-Controller-manager ： 第三方控制器管理器</li>\n<li>kube-scheduler： （节点）调度器</li>\n</ol>\n<p>‍</p>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li>kubelet：负责Pod生命周期、存储、网络</li>\n<li>kube-proxy： 网络代理、服务发现负载</li>\n<li>Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</li>\n<li>container-runtime： 容器运行时环境（docker、containerd…）</li>\n</ol>\n<p>‍</p>\n<h3 id=\"k8s生态架构\"><a href=\"#k8s生态架构\" class=\"headerlink\" title=\"k8s生态架构\"></a>k8s生态架构</h3><ul>\n<li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境</li>\n<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）、Service Mesh（部分位于应用层）</li>\n<li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）、Service Mesh（部分位于管理层）</li>\n<li>接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦</li>\n<li>生态系统：日志监控&#x2F;集群配置等<blockquote>\n<p>作为开发者，最主要的就是理解服务、任务的执行部署方式，熟悉kubectl和API的使用，了解流量控制</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<p>学习资料:</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MT411x7GH?p=10&spm_id_from=pageDriver&vd_source=eeb1c6e015a7ca03cb75e71d6ae0a6e1\">2.2.2_集群架构与组件-组件详解：核心组件与分层架构_bilibili_哔哩哔哩_bilibili</a>  </p>\n<p><a href=\"https://lib.jimmysong.io/kubernetes-handbook/architecture/\">Kubernetes 架构 | 云原生资料库 (jimmysong.io)</a>  </p>\n","site":{"data":{}},"excerpt":"<p>k8s是未来，理解架构</p>","more":"<p>​<img src=\"/images/assets/image-20240116140626-xdrpftt.png\" alt=\"image\">​</p>\n<p>​​<img src=\"/images/assets/image-20240117120120-oyzznx1.png\" alt=\"image\">​​</p>\n<p>‍</p>\n<h2 id=\"组件及概念\"><a href=\"#组件及概念\" class=\"headerlink\" title=\"组件及概念\"></a>组件及概念</h2><h3 id=\"Master\"><a href=\"#Master\" class=\"headerlink\" title=\"Master\"></a>Master</h3><ol>\n<li>ApiServer： 接口服务</li>\n<li>kube-Controller-manager ： 控制器管理器</li>\n<li>cloud-Controller-manager ： 第三方控制器管理器</li>\n<li>kube-scheduler： （节点）调度器</li>\n</ol>\n<p>‍</p>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li>kubelet：负责Pod生命周期、存储、网络</li>\n<li>kube-proxy： 网络代理、服务发现负载</li>\n<li>Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</li>\n<li>container-runtime： 容器运行时环境（docker、containerd…）</li>\n</ol>\n<p>‍</p>\n<h3 id=\"k8s生态架构\"><a href=\"#k8s生态架构\" class=\"headerlink\" title=\"k8s生态架构\"></a>k8s生态架构</h3><ul>\n<li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境</li>\n<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）、Service Mesh（部分位于应用层）</li>\n<li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）、Service Mesh（部分位于管理层）</li>\n<li>接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦</li>\n<li>生态系统：日志监控&#x2F;集群配置等<blockquote>\n<p>作为开发者，最主要的就是理解服务、任务的执行部署方式，熟悉kubectl和API的使用，了解流量控制</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<p>学习资料:</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MT411x7GH?p=10&spm_id_from=pageDriver&vd_source=eeb1c6e015a7ca03cb75e71d6ae0a6e1\">2.2.2_集群架构与组件-组件详解：核心组件与分层架构_bilibili_哔哩哔哩_bilibili</a>  </p>\n<p><a href=\"https://lib.jimmysong.io/kubernetes-handbook/architecture/\">Kubernetes 架构 | 云原生资料库 (jimmysong.io)</a>  </p>"},{"title":"kubernetes-3-安装与使用","date":"2024-01-30T06:53:25.000Z","_content":"k8s是未来，理解了基础架构和概念后，从实践入手\n<!--more-->\n\n## 一、基本应用\n\n1. 仅使用容器能力\n\n    > // 类似docker启动服务\n    >\n    > kubectl run redis --image\\=redis\n    >\n    > // 查看pod\n    >\n    > kubectl get pods\n    >\n    > // 进入容器可直连\n    >\n    > kubectl exec -it redis -- bash\n    >\n\n2. 以上应用类似可以指定为k8s独有的Deployment（无状态应用，支持扩容缩容/滚动升级，自动重启等），如：\n\n>  kubectl create deployment redis-deployment --image=redis\n\n3. 具体应用往往不是简单的镜像复制，而包含了很多参数。kubectl支持通过yml配置文件来创建服务\n\n    ```yml\n    # pod.yaml\n    apiVersion: v1\n    kind: Pod\n    metadata:\n      name: redis\n    spec:\n      containers:\n      - name: redis\n        image: redis\n    ```\n\n 指定配置文件启动： `kubectl create -f pod.yaml`​\n\n‍\n\nPod不具有自愈能力，一般是通过Controller来控制。比如自定义一个nginx：\n\n```yml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.7.9\n        ports:\n        - containerPort: 80\n```\n\n‍\n\n‍\n\n## 二 、kubectl命令汇总\n\n> 获取节点和服务版本信息  \n> kubectl get nodes\n>\n> 获取pod的信息，以JSON格式展示\n>\n> kubectl get pod -o json\n>\n> 查看所有deployments信息  \n> kubectl get deploy -A  \n> 查看所有replicasets信息  \n> kubectl get rs -A  \n> 查看所有statefulsets信息  \n> kubectl get sts -A  \n> 查看所有jobs信息  \n> kubectl get jobs -A  \n> 查看所有ingresses信息  \n> kubectl get ing -A  \n> 查看有哪些名称空间  \n> kubectl get ns\n\n‍常用命令归类：\n\n> kubectl get – 输出一个/多个资源\n> kubectl create – 通过文件名或控制台输入，创建资源\n> kubectl delete – 通过文件名、控制台输入、资源名或者label selector删除资源\n> kubectl describe – 输出指定的一个/多个资源的详细信息\n> kubectl edit – 编辑服务端的资源\n> kubectl apply – 通过文件名或控制台输入，对资源进行配置\n> kubectl exec – 在容器内部执行命令\n> kubectl expose – 输入replication controller，service或者pod，并将其暴露为新的kubernetes service\n> kubectl logs – 输出pod中一个容器的日志  \n\n\nkuberctl命令行众多，不必死记硬背，在需要的时候查一查[kuberctl命令行概览](https://lib.jimmysong.io/kubernetes-handbook/cli/using-kubectl/)就知道了。  \n\n另外，开始不熟练可以通过dashboard访问。\n\n```sh\n# 运行dashboard\nminikube dashboard\n# 让dashboard可以外部访问\nkubectl proxy --port=8888 --address='0.0.0.0' --accept-hosts='^.*'\n# 获取dashboard的url\nminikube dashboard --url\n```\n\n‍\n\n‍\n\n## 三、创建无状态服务\n\n一个 [Deployment](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/) 为 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 和 [ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) (副本控制器)提供声明式的更新能力  \n\n‍\n\n### 3.1  平滑升级\n\n创建有两个备份的nginx，版本号14:\n\n```yml\nkubectl apply -f https://k8s.io/examples/application/deployment.yaml\n# 查看deployment详情\nkubectl describe deployment nginx-deployment\n# 通过标签查询pod信息\nkubectl get pods -l app=nginx\n```\n\n现在用一个新版本号的yml文件来， 升级nginx版本：\n\n```yml\nkubectl apply -f https://k8s.io/examples/application/deployment-update.yaml\n# 也可以直接通过参数指定\nkubectl set image deployment/nginx-deployment nginx=nginx:1.9.1\n\n# 不断查看pod观察\nkubectl get pods -l app=nginx\n# 重新查看deployment详情，校验版本号\nkubectl describe deployment nginx-deployment\n```\n\n观察输出的Events信息，会先启动新的服务，然后停掉旧的；这个升级过程是平滑的\n\n> StrategyType:       RollingUpdate  \n> MinReadySeconds:    0  \n> RollingUpdateStrategy:  1 max unavailable, 1 max surge\n\n‍\n\n### 3.2 动态扩容缩容\n\n* 扩容\n\n  ```yml\n  kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml\n\n  # 也可以使用scale缩放\n  kubectl scale deployment/nginx-deployment --replicas=4\n  ```\n\n* 缩容\n\n  ```yml\n  # 指定备份数\n  kubectl scale deployment/nginx-deployment --replicas=2\n  # 按比例缩放\n  kubectl autoscale deployment/nginx-deployment --min=2 --max=10 --cpu-percent=80\n  ```\n\n### 3.3 回滚\n\n```yml\n# 直接回滚\nkubectl rollout undo deployment/nginx-deployment\n\n# 获取历史\nkubectl rollout history deployment/nginx-deployment\n# 指定版本详情\nkubectl rollout history deployment/nginx-deployment --revision=2\n# 回滚到指定版本\nkubectl rollout undo deployment/nginx-deployment --to-revision=2\n```\n\n## 四、创建有状态服务集群\n\nStatefulSet 是用来管理有状态应用的工作负载 API 对象。\n\n参考： https://juejin.cn/post/7033600843131666469  \n\n\n创建一个主从结构的Redis集群：  \n\n```yml\n# server.yaml\napiVersion: apps/v1\nkind: StatefulSet  # 类型为 statefulset\nmetadata:\n  name: redis-sfs  # app 名称\nspec:\n  serviceName: redis-sfs  # 这里的 service 下面解释\n  replicas: 2      # 定义了两个副本\n  selector:\n    matchLabels:\n      app: redis-sfs\n  template:\n    metadata:\n      labels:\n        app: redis-sfs\n    spec:\n      containers:\n      - name: redis-sfs \n        image: redis  # 镜像版本\n        command:\n          - bash\n          - \"-c\"\n          - |\n            set -ex\n            ordinal=`hostname | awk -F '-' '{print $NF}'`   # 使用 hostname 获取序列\n            if [[ $ordinal -eq 0 ]]; then     # 如果是 0，作为主\n              echo > /tmp/redis.conf\n            else\n              echo \"slaveof redis-sfs-0.redis-sfs 6379\" > /tmp/redis.conf # 如果是 1，作为备\n            fi\n            redis-server /tmp/redis.conf\n```\n\n执行`kubectl apply -f server.yaml` , 这里会创建redis-sfs-0 和 redis-sfs-1 两个 pod，他们正式按照 name-index 的规则来编号的。\n\n上面的两个节点创建了，但是却是分开的两个主节点，而不是一主一从。需要建立Service，将它们放到一组：\n\n```yml\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis-sfs\n  labels:\n    app: redis-sfs\nspec:\n  clusterIP: None   # 这里的 None 就是 Headless 的意思，表示会主动由 k8s 分配\n  ports:\n    - port: 6379\n      name: redis-sfs\n  selector:\n    app: redis-sfs\n\n```\n\n执行`kubectl apply -f service.yaml` ，再查看日志 `kubectl logs -f redis-sfs-1`， 会获取主从连接信息。\n\n‍\n\n‍\n\n‍\n\n‍\n","source":"_posts/kubernetes-3-安装与使用.md","raw":"---\ntitle: kubernetes-3-安装与使用\ndate: 2024-01-30 14:53:25\ntags: kubernetes\ncategories: 云原生\n---\nk8s是未来，理解了基础架构和概念后，从实践入手\n<!--more-->\n\n## 一、基本应用\n\n1. 仅使用容器能力\n\n    > // 类似docker启动服务\n    >\n    > kubectl run redis --image\\=redis\n    >\n    > // 查看pod\n    >\n    > kubectl get pods\n    >\n    > // 进入容器可直连\n    >\n    > kubectl exec -it redis -- bash\n    >\n\n2. 以上应用类似可以指定为k8s独有的Deployment（无状态应用，支持扩容缩容/滚动升级，自动重启等），如：\n\n>  kubectl create deployment redis-deployment --image=redis\n\n3. 具体应用往往不是简单的镜像复制，而包含了很多参数。kubectl支持通过yml配置文件来创建服务\n\n    ```yml\n    # pod.yaml\n    apiVersion: v1\n    kind: Pod\n    metadata:\n      name: redis\n    spec:\n      containers:\n      - name: redis\n        image: redis\n    ```\n\n 指定配置文件启动： `kubectl create -f pod.yaml`​\n\n‍\n\nPod不具有自愈能力，一般是通过Controller来控制。比如自定义一个nginx：\n\n```yml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.7.9\n        ports:\n        - containerPort: 80\n```\n\n‍\n\n‍\n\n## 二 、kubectl命令汇总\n\n> 获取节点和服务版本信息  \n> kubectl get nodes\n>\n> 获取pod的信息，以JSON格式展示\n>\n> kubectl get pod -o json\n>\n> 查看所有deployments信息  \n> kubectl get deploy -A  \n> 查看所有replicasets信息  \n> kubectl get rs -A  \n> 查看所有statefulsets信息  \n> kubectl get sts -A  \n> 查看所有jobs信息  \n> kubectl get jobs -A  \n> 查看所有ingresses信息  \n> kubectl get ing -A  \n> 查看有哪些名称空间  \n> kubectl get ns\n\n‍常用命令归类：\n\n> kubectl get – 输出一个/多个资源\n> kubectl create – 通过文件名或控制台输入，创建资源\n> kubectl delete – 通过文件名、控制台输入、资源名或者label selector删除资源\n> kubectl describe – 输出指定的一个/多个资源的详细信息\n> kubectl edit – 编辑服务端的资源\n> kubectl apply – 通过文件名或控制台输入，对资源进行配置\n> kubectl exec – 在容器内部执行命令\n> kubectl expose – 输入replication controller，service或者pod，并将其暴露为新的kubernetes service\n> kubectl logs – 输出pod中一个容器的日志  \n\n\nkuberctl命令行众多，不必死记硬背，在需要的时候查一查[kuberctl命令行概览](https://lib.jimmysong.io/kubernetes-handbook/cli/using-kubectl/)就知道了。  \n\n另外，开始不熟练可以通过dashboard访问。\n\n```sh\n# 运行dashboard\nminikube dashboard\n# 让dashboard可以外部访问\nkubectl proxy --port=8888 --address='0.0.0.0' --accept-hosts='^.*'\n# 获取dashboard的url\nminikube dashboard --url\n```\n\n‍\n\n‍\n\n## 三、创建无状态服务\n\n一个 [Deployment](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/) 为 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 和 [ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) (副本控制器)提供声明式的更新能力  \n\n‍\n\n### 3.1  平滑升级\n\n创建有两个备份的nginx，版本号14:\n\n```yml\nkubectl apply -f https://k8s.io/examples/application/deployment.yaml\n# 查看deployment详情\nkubectl describe deployment nginx-deployment\n# 通过标签查询pod信息\nkubectl get pods -l app=nginx\n```\n\n现在用一个新版本号的yml文件来， 升级nginx版本：\n\n```yml\nkubectl apply -f https://k8s.io/examples/application/deployment-update.yaml\n# 也可以直接通过参数指定\nkubectl set image deployment/nginx-deployment nginx=nginx:1.9.1\n\n# 不断查看pod观察\nkubectl get pods -l app=nginx\n# 重新查看deployment详情，校验版本号\nkubectl describe deployment nginx-deployment\n```\n\n观察输出的Events信息，会先启动新的服务，然后停掉旧的；这个升级过程是平滑的\n\n> StrategyType:       RollingUpdate  \n> MinReadySeconds:    0  \n> RollingUpdateStrategy:  1 max unavailable, 1 max surge\n\n‍\n\n### 3.2 动态扩容缩容\n\n* 扩容\n\n  ```yml\n  kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml\n\n  # 也可以使用scale缩放\n  kubectl scale deployment/nginx-deployment --replicas=4\n  ```\n\n* 缩容\n\n  ```yml\n  # 指定备份数\n  kubectl scale deployment/nginx-deployment --replicas=2\n  # 按比例缩放\n  kubectl autoscale deployment/nginx-deployment --min=2 --max=10 --cpu-percent=80\n  ```\n\n### 3.3 回滚\n\n```yml\n# 直接回滚\nkubectl rollout undo deployment/nginx-deployment\n\n# 获取历史\nkubectl rollout history deployment/nginx-deployment\n# 指定版本详情\nkubectl rollout history deployment/nginx-deployment --revision=2\n# 回滚到指定版本\nkubectl rollout undo deployment/nginx-deployment --to-revision=2\n```\n\n## 四、创建有状态服务集群\n\nStatefulSet 是用来管理有状态应用的工作负载 API 对象。\n\n参考： https://juejin.cn/post/7033600843131666469  \n\n\n创建一个主从结构的Redis集群：  \n\n```yml\n# server.yaml\napiVersion: apps/v1\nkind: StatefulSet  # 类型为 statefulset\nmetadata:\n  name: redis-sfs  # app 名称\nspec:\n  serviceName: redis-sfs  # 这里的 service 下面解释\n  replicas: 2      # 定义了两个副本\n  selector:\n    matchLabels:\n      app: redis-sfs\n  template:\n    metadata:\n      labels:\n        app: redis-sfs\n    spec:\n      containers:\n      - name: redis-sfs \n        image: redis  # 镜像版本\n        command:\n          - bash\n          - \"-c\"\n          - |\n            set -ex\n            ordinal=`hostname | awk -F '-' '{print $NF}'`   # 使用 hostname 获取序列\n            if [[ $ordinal -eq 0 ]]; then     # 如果是 0，作为主\n              echo > /tmp/redis.conf\n            else\n              echo \"slaveof redis-sfs-0.redis-sfs 6379\" > /tmp/redis.conf # 如果是 1，作为备\n            fi\n            redis-server /tmp/redis.conf\n```\n\n执行`kubectl apply -f server.yaml` , 这里会创建redis-sfs-0 和 redis-sfs-1 两个 pod，他们正式按照 name-index 的规则来编号的。\n\n上面的两个节点创建了，但是却是分开的两个主节点，而不是一主一从。需要建立Service，将它们放到一组：\n\n```yml\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis-sfs\n  labels:\n    app: redis-sfs\nspec:\n  clusterIP: None   # 这里的 None 就是 Headless 的意思，表示会主动由 k8s 分配\n  ports:\n    - port: 6379\n      name: redis-sfs\n  selector:\n    app: redis-sfs\n\n```\n\n执行`kubectl apply -f service.yaml` ，再查看日志 `kubectl logs -f redis-sfs-1`， 会获取主从连接信息。\n\n‍\n\n‍\n\n‍\n\n‍\n","slug":"kubernetes-3-安装与使用","published":1,"updated":"2024-02-18T08:27:27.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz7002gqwvdexwef26x","content":"<p>k8s是未来，理解了基础架构和概念后，从实践入手</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、基本应用\"><a href=\"#一、基本应用\" class=\"headerlink\" title=\"一、基本应用\"></a>一、基本应用</h2><ol>\n<li><p>仅使用容器能力</p>\n<blockquote>\n<p>&#x2F;&#x2F; 类似docker启动服务</p>\n<p>kubectl run redis –image=redis</p>\n<p>&#x2F;&#x2F; 查看pod</p>\n<p>kubectl get pods</p>\n<p>&#x2F;&#x2F; 进入容器可直连</p>\n<p>kubectl exec -it redis – bash</p>\n</blockquote>\n</li>\n<li><p>以上应用类似可以指定为k8s独有的Deployment（无状态应用，支持扩容缩容&#x2F;滚动升级，自动重启等），如：</p>\n</li>\n</ol>\n<blockquote>\n<p> kubectl create deployment redis-deployment –image&#x3D;redis</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>具体应用往往不是简单的镜像复制，而包含了很多参数。kubectl支持通过yml配置文件来创建服务</p>\n <figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p> 指定配置文件启动： <code>kubectl create -f pod.yaml</code>​</p>\n<p>‍</p>\n<p>Pod不具有自愈能力，一般是通过Controller来控制。比如自定义一个nginx：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">extensions/v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.7.9</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"二-、kubectl命令汇总\"><a href=\"#二-、kubectl命令汇总\" class=\"headerlink\" title=\"二 、kubectl命令汇总\"></a>二 、kubectl命令汇总</h2><blockquote>\n<p>获取节点和服务版本信息<br>kubectl get nodes</p>\n<p>获取pod的信息，以JSON格式展示</p>\n<p>kubectl get pod -o json</p>\n<p>查看所有deployments信息<br>kubectl get deploy -A<br>查看所有replicasets信息<br>kubectl get rs -A<br>查看所有statefulsets信息<br>kubectl get sts -A<br>查看所有jobs信息<br>kubectl get jobs -A<br>查看所有ingresses信息<br>kubectl get ing -A<br>查看有哪些名称空间<br>kubectl get ns</p>\n</blockquote>\n<p>‍常用命令归类：</p>\n<blockquote>\n<p>kubectl get – 输出一个&#x2F;多个资源<br>kubectl create – 通过文件名或控制台输入，创建资源<br>kubectl delete – 通过文件名、控制台输入、资源名或者label selector删除资源<br>kubectl describe – 输出指定的一个&#x2F;多个资源的详细信息<br>kubectl edit – 编辑服务端的资源<br>kubectl apply – 通过文件名或控制台输入，对资源进行配置<br>kubectl exec – 在容器内部执行命令<br>kubectl expose – 输入replication controller，service或者pod，并将其暴露为新的kubernetes service<br>kubectl logs – 输出pod中一个容器的日志  </p>\n</blockquote>\n<p>kuberctl命令行众多，不必死记硬背，在需要的时候查一查<a href=\"https://lib.jimmysong.io/kubernetes-handbook/cli/using-kubectl/\">kuberctl命令行概览</a>就知道了。  </p>\n<p>另外，开始不熟练可以通过dashboard访问。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行dashboard</span></span><br><span class=\"line\">minikube dashboard</span><br><span class=\"line\"><span class=\"comment\"># 让dashboard可以外部访问</span></span><br><span class=\"line\">kubectl proxy --port=8888 --address=<span class=\"string\">&#x27;0.0.0.0&#x27;</span> --accept-hosts=<span class=\"string\">&#x27;^.*&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 获取dashboard的url</span></span><br><span class=\"line\">minikube dashboard --url</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"三、创建无状态服务\"><a href=\"#三、创建无状态服务\" class=\"headerlink\" title=\"三、创建无状态服务\"></a>三、创建无状态服务</h2><p>一个 <a href=\"https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/\">Deployment</a> 为 <a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/\">Pod</a> 和 <a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/\">ReplicaSet</a> (副本控制器)提供声明式的更新能力  </p>\n<p>‍</p>\n<h3 id=\"3-1-平滑升级\"><a href=\"#3-1-平滑升级\" class=\"headerlink\" title=\"3.1  平滑升级\"></a>3.1  平滑升级</h3><p>创建有两个备份的nginx，版本号14:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">apply</span> <span class=\"string\">-f</span> <span class=\"string\">https://k8s.io/examples/application/deployment.yaml</span></span><br><span class=\"line\"><span class=\"comment\"># 查看deployment详情</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">describe</span> <span class=\"string\">deployment</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"comment\"># 通过标签查询pod信息</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pods</span> <span class=\"string\">-l</span> <span class=\"string\">app=nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>现在用一个新版本号的yml文件来， 升级nginx版本：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">apply</span> <span class=\"string\">-f</span> <span class=\"string\">https://k8s.io/examples/application/deployment-update.yaml</span></span><br><span class=\"line\"><span class=\"comment\"># 也可以直接通过参数指定</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">set</span> <span class=\"string\">image</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">nginx=nginx:1.9.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不断查看pod观察</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pods</span> <span class=\"string\">-l</span> <span class=\"string\">app=nginx</span></span><br><span class=\"line\"><span class=\"comment\"># 重新查看deployment详情，校验版本号</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">describe</span> <span class=\"string\">deployment</span> <span class=\"string\">nginx-deployment</span></span><br></pre></td></tr></table></figure>\n\n<p>观察输出的Events信息，会先启动新的服务，然后停掉旧的；这个升级过程是平滑的</p>\n<blockquote>\n<p>StrategyType:       RollingUpdate<br>MinReadySeconds:    0<br>RollingUpdateStrategy:  1 max unavailable, 1 max surge</p>\n</blockquote>\n<p>‍</p>\n<h3 id=\"3-2-动态扩容缩容\"><a href=\"#3-2-动态扩容缩容\" class=\"headerlink\" title=\"3.2 动态扩容缩容\"></a>3.2 动态扩容缩容</h3><ul>\n<li><p>扩容</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">apply</span> <span class=\"string\">-f</span> <span class=\"string\">https://k8s.io/examples/application/deployment-scale.yaml</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以使用scale缩放</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">scale</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--replicas=4</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缩容</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定备份数</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">scale</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--replicas=2</span></span><br><span class=\"line\"><span class=\"comment\"># 按比例缩放</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">autoscale</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--min=2</span> <span class=\"string\">--max=10</span> <span class=\"string\">--cpu-percent=80</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-3-回滚\"><a href=\"#3-3-回滚\" class=\"headerlink\" title=\"3.3 回滚\"></a>3.3 回滚</h3><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接回滚</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">undo</span> <span class=\"string\">deployment/nginx-deployment</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取历史</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">history</span> <span class=\"string\">deployment/nginx-deployment</span></span><br><span class=\"line\"><span class=\"comment\"># 指定版本详情</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">history</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--revision=2</span></span><br><span class=\"line\"><span class=\"comment\"># 回滚到指定版本</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">undo</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--to-revision=2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、创建有状态服务集群\"><a href=\"#四、创建有状态服务集群\" class=\"headerlink\" title=\"四、创建有状态服务集群\"></a>四、创建有状态服务集群</h2><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p>\n<p>参考： <a href=\"https://juejin.cn/post/7033600843131666469\">https://juejin.cn/post/7033600843131666469</a>  </p>\n<p>创建一个主从结构的Redis集群：  </p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># server.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span>  <span class=\"comment\"># 类型为 statefulset</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span>  <span class=\"comment\"># app 名称</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">redis-sfs</span>  <span class=\"comment\"># 这里的 service 下面解释</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span>      <span class=\"comment\"># 定义了两个副本</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span> </span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">redis</span>  <span class=\"comment\"># 镜像版本</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">bash</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">&quot;-c&quot;</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            set -ex</span></span><br><span class=\"line\"><span class=\"string\">            ordinal=`hostname | awk -F &#x27;-&#x27; &#x27;&#123;print $NF&#125;&#x27;`   # 使用 hostname 获取序列</span></span><br><span class=\"line\"><span class=\"string\">            if [[ $ordinal -eq 0 ]]; then     # 如果是 0，作为主</span></span><br><span class=\"line\"><span class=\"string\">              echo &gt; /tmp/redis.conf</span></span><br><span class=\"line\"><span class=\"string\">            else</span></span><br><span class=\"line\"><span class=\"string\">              echo &quot;slaveof redis-sfs-0.redis-sfs 6379&quot; &gt; /tmp/redis.conf # 如果是 1，作为备</span></span><br><span class=\"line\"><span class=\"string\">            fi</span></span><br><span class=\"line\"><span class=\"string\">            redis-server /tmp/redis.conf</span></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>kubectl apply -f server.yaml</code> , 这里会创建redis-sfs-0 和 redis-sfs-1 两个 pod，他们正式按照 name-index 的规则来编号的。</p>\n<p>上面的两个节点创建了，但是却是分开的两个主节点，而不是一主一从。需要建立Service，将它们放到一组：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># service.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">clusterIP:</span> <span class=\"string\">None</span>   <span class=\"comment\"># 这里的 None 就是 Headless 的意思，表示会主动由 k8s 分配</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>kubectl apply -f service.yaml</code> ，再查看日志 <code>kubectl logs -f redis-sfs-1</code>， 会获取主从连接信息。</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>k8s是未来，理解了基础架构和概念后，从实践入手</p>","more":"<h2 id=\"一、基本应用\"><a href=\"#一、基本应用\" class=\"headerlink\" title=\"一、基本应用\"></a>一、基本应用</h2><ol>\n<li><p>仅使用容器能力</p>\n<blockquote>\n<p>&#x2F;&#x2F; 类似docker启动服务</p>\n<p>kubectl run redis –image=redis</p>\n<p>&#x2F;&#x2F; 查看pod</p>\n<p>kubectl get pods</p>\n<p>&#x2F;&#x2F; 进入容器可直连</p>\n<p>kubectl exec -it redis – bash</p>\n</blockquote>\n</li>\n<li><p>以上应用类似可以指定为k8s独有的Deployment（无状态应用，支持扩容缩容&#x2F;滚动升级，自动重启等），如：</p>\n</li>\n</ol>\n<blockquote>\n<p> kubectl create deployment redis-deployment –image&#x3D;redis</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>具体应用往往不是简单的镜像复制，而包含了很多参数。kubectl支持通过yml配置文件来创建服务</p>\n <figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p> 指定配置文件启动： <code>kubectl create -f pod.yaml</code>​</p>\n<p>‍</p>\n<p>Pod不具有自愈能力，一般是通过Controller来控制。比如自定义一个nginx：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">extensions/v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.7.9</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"二-、kubectl命令汇总\"><a href=\"#二-、kubectl命令汇总\" class=\"headerlink\" title=\"二 、kubectl命令汇总\"></a>二 、kubectl命令汇总</h2><blockquote>\n<p>获取节点和服务版本信息<br>kubectl get nodes</p>\n<p>获取pod的信息，以JSON格式展示</p>\n<p>kubectl get pod -o json</p>\n<p>查看所有deployments信息<br>kubectl get deploy -A<br>查看所有replicasets信息<br>kubectl get rs -A<br>查看所有statefulsets信息<br>kubectl get sts -A<br>查看所有jobs信息<br>kubectl get jobs -A<br>查看所有ingresses信息<br>kubectl get ing -A<br>查看有哪些名称空间<br>kubectl get ns</p>\n</blockquote>\n<p>‍常用命令归类：</p>\n<blockquote>\n<p>kubectl get – 输出一个&#x2F;多个资源<br>kubectl create – 通过文件名或控制台输入，创建资源<br>kubectl delete – 通过文件名、控制台输入、资源名或者label selector删除资源<br>kubectl describe – 输出指定的一个&#x2F;多个资源的详细信息<br>kubectl edit – 编辑服务端的资源<br>kubectl apply – 通过文件名或控制台输入，对资源进行配置<br>kubectl exec – 在容器内部执行命令<br>kubectl expose – 输入replication controller，service或者pod，并将其暴露为新的kubernetes service<br>kubectl logs – 输出pod中一个容器的日志  </p>\n</blockquote>\n<p>kuberctl命令行众多，不必死记硬背，在需要的时候查一查<a href=\"https://lib.jimmysong.io/kubernetes-handbook/cli/using-kubectl/\">kuberctl命令行概览</a>就知道了。  </p>\n<p>另外，开始不熟练可以通过dashboard访问。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行dashboard</span></span><br><span class=\"line\">minikube dashboard</span><br><span class=\"line\"><span class=\"comment\"># 让dashboard可以外部访问</span></span><br><span class=\"line\">kubectl proxy --port=8888 --address=<span class=\"string\">&#x27;0.0.0.0&#x27;</span> --accept-hosts=<span class=\"string\">&#x27;^.*&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 获取dashboard的url</span></span><br><span class=\"line\">minikube dashboard --url</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"三、创建无状态服务\"><a href=\"#三、创建无状态服务\" class=\"headerlink\" title=\"三、创建无状态服务\"></a>三、创建无状态服务</h2><p>一个 <a href=\"https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/\">Deployment</a> 为 <a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/\">Pod</a> 和 <a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/\">ReplicaSet</a> (副本控制器)提供声明式的更新能力  </p>\n<p>‍</p>\n<h3 id=\"3-1-平滑升级\"><a href=\"#3-1-平滑升级\" class=\"headerlink\" title=\"3.1  平滑升级\"></a>3.1  平滑升级</h3><p>创建有两个备份的nginx，版本号14:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">apply</span> <span class=\"string\">-f</span> <span class=\"string\">https://k8s.io/examples/application/deployment.yaml</span></span><br><span class=\"line\"><span class=\"comment\"># 查看deployment详情</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">describe</span> <span class=\"string\">deployment</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"comment\"># 通过标签查询pod信息</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pods</span> <span class=\"string\">-l</span> <span class=\"string\">app=nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>现在用一个新版本号的yml文件来， 升级nginx版本：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">apply</span> <span class=\"string\">-f</span> <span class=\"string\">https://k8s.io/examples/application/deployment-update.yaml</span></span><br><span class=\"line\"><span class=\"comment\"># 也可以直接通过参数指定</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">set</span> <span class=\"string\">image</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">nginx=nginx:1.9.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不断查看pod观察</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pods</span> <span class=\"string\">-l</span> <span class=\"string\">app=nginx</span></span><br><span class=\"line\"><span class=\"comment\"># 重新查看deployment详情，校验版本号</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">describe</span> <span class=\"string\">deployment</span> <span class=\"string\">nginx-deployment</span></span><br></pre></td></tr></table></figure>\n\n<p>观察输出的Events信息，会先启动新的服务，然后停掉旧的；这个升级过程是平滑的</p>\n<blockquote>\n<p>StrategyType:       RollingUpdate<br>MinReadySeconds:    0<br>RollingUpdateStrategy:  1 max unavailable, 1 max surge</p>\n</blockquote>\n<p>‍</p>\n<h3 id=\"3-2-动态扩容缩容\"><a href=\"#3-2-动态扩容缩容\" class=\"headerlink\" title=\"3.2 动态扩容缩容\"></a>3.2 动态扩容缩容</h3><ul>\n<li><p>扩容</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">apply</span> <span class=\"string\">-f</span> <span class=\"string\">https://k8s.io/examples/application/deployment-scale.yaml</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以使用scale缩放</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">scale</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--replicas=4</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缩容</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定备份数</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">scale</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--replicas=2</span></span><br><span class=\"line\"><span class=\"comment\"># 按比例缩放</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">autoscale</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--min=2</span> <span class=\"string\">--max=10</span> <span class=\"string\">--cpu-percent=80</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-3-回滚\"><a href=\"#3-3-回滚\" class=\"headerlink\" title=\"3.3 回滚\"></a>3.3 回滚</h3><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接回滚</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">undo</span> <span class=\"string\">deployment/nginx-deployment</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取历史</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">history</span> <span class=\"string\">deployment/nginx-deployment</span></span><br><span class=\"line\"><span class=\"comment\"># 指定版本详情</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">history</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--revision=2</span></span><br><span class=\"line\"><span class=\"comment\"># 回滚到指定版本</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">rollout</span> <span class=\"string\">undo</span> <span class=\"string\">deployment/nginx-deployment</span> <span class=\"string\">--to-revision=2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、创建有状态服务集群\"><a href=\"#四、创建有状态服务集群\" class=\"headerlink\" title=\"四、创建有状态服务集群\"></a>四、创建有状态服务集群</h2><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p>\n<p>参考： <a href=\"https://juejin.cn/post/7033600843131666469\">https://juejin.cn/post/7033600843131666469</a>  </p>\n<p>创建一个主从结构的Redis集群：  </p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># server.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">StatefulSet</span>  <span class=\"comment\"># 类型为 statefulset</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span>  <span class=\"comment\"># app 名称</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">serviceName:</span> <span class=\"string\">redis-sfs</span>  <span class=\"comment\"># 这里的 service 下面解释</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span>      <span class=\"comment\"># 定义了两个副本</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span> </span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">redis</span>  <span class=\"comment\"># 镜像版本</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">bash</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">&quot;-c&quot;</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            set -ex</span></span><br><span class=\"line\"><span class=\"string\">            ordinal=`hostname | awk -F &#x27;-&#x27; &#x27;&#123;print $NF&#125;&#x27;`   # 使用 hostname 获取序列</span></span><br><span class=\"line\"><span class=\"string\">            if [[ $ordinal -eq 0 ]]; then     # 如果是 0，作为主</span></span><br><span class=\"line\"><span class=\"string\">              echo &gt; /tmp/redis.conf</span></span><br><span class=\"line\"><span class=\"string\">            else</span></span><br><span class=\"line\"><span class=\"string\">              echo &quot;slaveof redis-sfs-0.redis-sfs 6379&quot; &gt; /tmp/redis.conf # 如果是 1，作为备</span></span><br><span class=\"line\"><span class=\"string\">            fi</span></span><br><span class=\"line\"><span class=\"string\">            redis-server /tmp/redis.conf</span></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>kubectl apply -f server.yaml</code> , 这里会创建redis-sfs-0 和 redis-sfs-1 两个 pod，他们正式按照 name-index 的规则来编号的。</p>\n<p>上面的两个节点创建了，但是却是分开的两个主节点，而不是一主一从。需要建立Service，将它们放到一组：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># service.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">clusterIP:</span> <span class=\"string\">None</span>   <span class=\"comment\"># 这里的 None 就是 Headless 的意思，表示会主动由 k8s 分配</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">redis-sfs</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>kubectl apply -f service.yaml</code> ，再查看日志 <code>kubectl logs -f redis-sfs-1</code>， 会获取主从连接信息。</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>"},{"title":"protobuf","date":"2023-03-19T03:52:58.000Z","_content":"\nGoogle Protocol Buffer(简称Protobuf)是 Google开发的一种跨语言跨平台,轻量高效的序列化数据结构。\n广泛用于服务器间通信以及存档存储磁盘上的数据。\n<!--more--> \n一个入门的例子是\n```\nmessage Person {\n  optional string name = 1;\n  optional int32 id = 2;\n  optional string email = 3;\n}\n```\n\n\n## 1. 安装\n\n[3.20RC版本下载地址](https://github.com/protocolbuffers/protobuf/releases/tag/v3.20.1-rc1)  \n\n命令行基本使用:  \n```\nprotoc --proto_path=. --java_out=../../ hello.proto\n```\n其中，`--proto_path`可以简写为`-I`\n\n> 为啥用老版本？新的22RC版本有bug啊：  \n[Java Compile Error on parseUnknownField]（https://github.com/protocolbuffers/protobuf/issues/10695）\n\n如果是IDEA中使用，主要是通过插件调用本地安装的protoc来实现，或者通过org.xolstice提供的maven插件。个人感觉在初期学习的话，直接使用本地安装的protoc更简单明了，后期在项目中集成的话考虑不依赖本地的maven插件。  \n\n[IDEA中集成protoc，讲的全面靠谱的](https://w3sun.com/1287.html)\n\n## 2. 基本用法\n推荐prot3  \n\nhttps://protobuf.dev/programming-guides/proto3/\n\n## 3. grpc\ngrpc的代码生成依赖于protoc-gen-grpc-java插件  \n\n[插件下载地址](https://repo.maven.apache.org/maven2/io/grpc/protoc-gen-grpc-java/)  \n主要是添加两项参数  \n``--plugin=protoc-gen-grpc-java=`` 和``--grpc-java_out=``  \n用法：\n```\nprotoc -I=. --plugin=protoc-gen-grpc-java=D:\\Tools\\protoc-3.20.1-rc-1-win64\\bin\\grpc-java.exe   --java_out=../../   --grpc-java_out=../../    hello.proto\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/protobuf.md","raw":"---\ntitle: protobuf\ndate: 2023-03-19 11:52:58\ntags: protobuf\ncategories: Spring+\n#description: Protobuf是Google开发的一种跨语言跨平台, 轻量高效的序列化数据结构\n---\n\nGoogle Protocol Buffer(简称Protobuf)是 Google开发的一种跨语言跨平台,轻量高效的序列化数据结构。\n广泛用于服务器间通信以及存档存储磁盘上的数据。\n<!--more--> \n一个入门的例子是\n```\nmessage Person {\n  optional string name = 1;\n  optional int32 id = 2;\n  optional string email = 3;\n}\n```\n\n\n## 1. 安装\n\n[3.20RC版本下载地址](https://github.com/protocolbuffers/protobuf/releases/tag/v3.20.1-rc1)  \n\n命令行基本使用:  \n```\nprotoc --proto_path=. --java_out=../../ hello.proto\n```\n其中，`--proto_path`可以简写为`-I`\n\n> 为啥用老版本？新的22RC版本有bug啊：  \n[Java Compile Error on parseUnknownField]（https://github.com/protocolbuffers/protobuf/issues/10695）\n\n如果是IDEA中使用，主要是通过插件调用本地安装的protoc来实现，或者通过org.xolstice提供的maven插件。个人感觉在初期学习的话，直接使用本地安装的protoc更简单明了，后期在项目中集成的话考虑不依赖本地的maven插件。  \n\n[IDEA中集成protoc，讲的全面靠谱的](https://w3sun.com/1287.html)\n\n## 2. 基本用法\n推荐prot3  \n\nhttps://protobuf.dev/programming-guides/proto3/\n\n## 3. grpc\ngrpc的代码生成依赖于protoc-gen-grpc-java插件  \n\n[插件下载地址](https://repo.maven.apache.org/maven2/io/grpc/protoc-gen-grpc-java/)  \n主要是添加两项参数  \n``--plugin=protoc-gen-grpc-java=`` 和``--grpc-java_out=``  \n用法：\n```\nprotoc -I=. --plugin=protoc-gen-grpc-java=D:\\Tools\\protoc-3.20.1-rc-1-win64\\bin\\grpc-java.exe   --java_out=../../   --grpc-java_out=../../    hello.proto\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"protobuf","published":1,"updated":"2024-02-18T08:25:58.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz8002jqwvdb1cta7xy","content":"<p>Google Protocol Buffer(简称Protobuf)是 Google开发的一种跨语言跨平台,轻量高效的序列化数据结构。<br>广泛用于服务器间通信以及存档存储磁盘上的数据。</p>\n<span id=\"more\"></span> \n<p>一个入门的例子是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message Person &#123;</span><br><span class=\"line\">  optional string name = 1;</span><br><span class=\"line\">  optional int32 id = 2;</span><br><span class=\"line\">  optional string email = 3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p><a href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.20.1-rc1\">3.20RC版本下载地址</a>  </p>\n<p>命令行基本使用:  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=. --java_out=../../ hello.proto</span><br></pre></td></tr></table></figure>\n<p>其中，<code>--proto_path</code>可以简写为<code>-I</code></p>\n<blockquote>\n<p>为啥用老版本？新的22RC版本有bug啊：<br>[Java Compile Error on parseUnknownField]（<a href=\"https://github.com/protocolbuffers/protobuf/issues/10695%EF%BC%89\">https://github.com/protocolbuffers/protobuf/issues/10695）</a></p>\n</blockquote>\n<p>如果是IDEA中使用，主要是通过插件调用本地安装的protoc来实现，或者通过org.xolstice提供的maven插件。个人感觉在初期学习的话，直接使用本地安装的protoc更简单明了，后期在项目中集成的话考虑不依赖本地的maven插件。  </p>\n<p><a href=\"https://w3sun.com/1287.html\">IDEA中集成protoc，讲的全面靠谱的</a></p>\n<h2 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h2><p>推荐prot3  </p>\n<p><a href=\"https://protobuf.dev/programming-guides/proto3/\">https://protobuf.dev/programming-guides/proto3/</a></p>\n<h2 id=\"3-grpc\"><a href=\"#3-grpc\" class=\"headerlink\" title=\"3. grpc\"></a>3. grpc</h2><p>grpc的代码生成依赖于protoc-gen-grpc-java插件  </p>\n<p><a href=\"https://repo.maven.apache.org/maven2/io/grpc/protoc-gen-grpc-java/\">插件下载地址</a><br>主要是添加两项参数<br><code>--plugin=protoc-gen-grpc-java=</code> 和<code>--grpc-java_out=</code><br>用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc -I=. --plugin=protoc-gen-grpc-java=D:\\Tools\\protoc-3.20.1-rc-1-win64\\bin\\grpc-java.exe   --java_out=../../   --grpc-java_out=../../    hello.proto</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>Google Protocol Buffer(简称Protobuf)是 Google开发的一种跨语言跨平台,轻量高效的序列化数据结构。<br>广泛用于服务器间通信以及存档存储磁盘上的数据。</p>","more":"<p>一个入门的例子是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message Person &#123;</span><br><span class=\"line\">  optional string name = 1;</span><br><span class=\"line\">  optional int32 id = 2;</span><br><span class=\"line\">  optional string email = 3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p><a href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.20.1-rc1\">3.20RC版本下载地址</a>  </p>\n<p>命令行基本使用:  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=. --java_out=../../ hello.proto</span><br></pre></td></tr></table></figure>\n<p>其中，<code>--proto_path</code>可以简写为<code>-I</code></p>\n<blockquote>\n<p>为啥用老版本？新的22RC版本有bug啊：<br>[Java Compile Error on parseUnknownField]（<a href=\"https://github.com/protocolbuffers/protobuf/issues/10695%EF%BC%89\">https://github.com/protocolbuffers/protobuf/issues/10695）</a></p>\n</blockquote>\n<p>如果是IDEA中使用，主要是通过插件调用本地安装的protoc来实现，或者通过org.xolstice提供的maven插件。个人感觉在初期学习的话，直接使用本地安装的protoc更简单明了，后期在项目中集成的话考虑不依赖本地的maven插件。  </p>\n<p><a href=\"https://w3sun.com/1287.html\">IDEA中集成protoc，讲的全面靠谱的</a></p>\n<h2 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h2><p>推荐prot3  </p>\n<p><a href=\"https://protobuf.dev/programming-guides/proto3/\">https://protobuf.dev/programming-guides/proto3/</a></p>\n<h2 id=\"3-grpc\"><a href=\"#3-grpc\" class=\"headerlink\" title=\"3. grpc\"></a>3. grpc</h2><p>grpc的代码生成依赖于protoc-gen-grpc-java插件  </p>\n<p><a href=\"https://repo.maven.apache.org/maven2/io/grpc/protoc-gen-grpc-java/\">插件下载地址</a><br>主要是添加两项参数<br><code>--plugin=protoc-gen-grpc-java=</code> 和<code>--grpc-java_out=</code><br>用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc -I=. --plugin=protoc-gen-grpc-java=D:\\Tools\\protoc-3.20.1-rc-1-win64\\bin\\grpc-java.exe   --java_out=../../   --grpc-java_out=../../    hello.proto</span><br></pre></td></tr></table></figure>"},{"title":"redis集群-cluster","date":"2024-01-24T02:18:57.000Z","_content":"Redis的哨兵模式已经存在主备结构，并且能自动故障转移和动态扩容，为什么要整出cluster集群呢?  \n哨兵模式只是一个Master节点的高可用，如果需要一堆节点的高可用呢？集群管理，故障发现，数据分片，这些问题自然应运而生。  \n解决方案就是Cluster。\n<!--more-->\n\n### 特征\n\n1. 多个 Redis 节点之间自动分片\n2. 当小部分节点出现故障或无法与群集的其余部分通信时，集群可以继续运行\n\n‍\n\n### 端口\n\n每个 Redis 集群节点都需要两个开放的 TCP 连接\n\n* 一个用于为客户端提供服务的 Redis TCP 端口（6379）\n* 集群总线端口（默认加上10000，如16379；作用：故障检测、配置更新、故障转移授权等）\n\n‍\n\n### 集群主备模型\n\n集群每个节点，都有1个和N-1个副本构成。  \n以基础的3主+3备为例：  \n​![image](/images/assets/image-20240123142211-7frka5a.png)​\n\n\n### 集群一致性\n\nRedis 集群不保证强一致性，原因：  \n\n1. 异步复制。 可以通过 WAIT 命令实现同步写入\n2. 网络分区。客户端与少数实例隔离，客户端在主节点故障转移前（这个时间可配置<u>node timeout</u>）的写入都会丢失\n\n‍\n\n### 配置参数\n\n* cluster-enabled `<yes/no>`​ ：如果是，则在特定 Redis 实例中启用 Redis 集群支持\n* cluster-config-file `<filename>`​ ：集群节点在每次发生更改时自动保留集群配置（基本上是状态）的文件，用户不要编辑ta\n* cluster-node-timeout `<milliseconds>`​ ：Redis 集群节点不可用的最长时间\n* cluster-migration-barrier `<count>`​ ：主服务器将保持连接的最小副本数\n* cluster-require-full-coverage `<yes/no>`​ ：如果设置为 yes，如果某个百分比的密钥空间未被任何节点覆盖，则停止写入\n* luster-allow-reads-when-down `<yes/no>`​ ：默认否，当集群标记为失败时，是否允许可读\n\n‍\n\n#### 部署方式1（首次执行推荐）\n\n1. 要创建集群，首先需要让几个空的 Redis 实例在集群模式下运行。\n\n每个节点配置文件 redis.conf\n\n```sh\nport 7000\ncluster-enabled yes\ncluster-config-file nodes7000.conf\ncluster-node-timeout 5000\nappendonly yes\n```\n\n基于以上配置，创建一个启动6个节点的脚本（Maste或Slave，角色由集群分配）：\n\n```sh\n#!/bin/bash\nif [ ! -d \"clustertest\" ]; then\n    mkdir clustertest\nfi\nrm -rf ./clustertest/*\ncd clustertest\nfor port in 7000 7001 7002 7003 7004 7005\ndo\n    cp ../redis.conf redis${port}.conf\n    sed -i \"s#port 6379#port ${port}#g\"  redis${port}.conf\n    echo \"cluster-enabled yes\\ncluster-config-file nodes${port}.conf\\ncluster-node-timeout 5000\\nappendonly yes\" >> redis${port}.conf\n    nohup redis-server redis${port}.conf &\ndone\n```\n\n‍\n\n2. 创建Redis Cluster集群，由集群为每个端口创建ID并分配节点角色(M/S)\n\n    ```sh\n    redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\\n    127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\\n    --cluster-replicas 1\n    ```\n\n‍\n\n3. 创建完成反馈实例角色、槽位分配信息等\n\n```sh\n# redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\\n> 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\\n> --cluster-replicas 1\n>>> Performing hash slots allocation on 6 nodes...\nMaster[0] -> Slots 0 - 5460\nMaster[1] -> Slots 5461 - 10922\nMaster[2] -> Slots 10923 - 16383\nAdding replica 127.0.0.1:7004 to 127.0.0.1:7000\nAdding replica 127.0.0.1:7005 to 127.0.0.1:7001\nAdding replica 127.0.0.1:7003 to 127.0.0.1:7002\n>>> Trying to optimize slaves allocation for anti-affinity\n[WARNING] Some slaves are in the same host as their master\nM: 9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000\n   slots:[0-5460] (5461 slots) master\nM: 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001\n   slots:[5461-10922] (5462 slots) master\nM: b40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002\n   slots:[10923-16383] (5461 slots) master\nS: b27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003\n   replicates b40862b42ebd1a3c40df1eabe1eef9c06026a39a\nS: a0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004\n   replicates 9a7c5a97e34a57eee737166f54851edc27b80538\nS: a5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005\n   replicates 61feac4042b4b3c3ab43ace2c85c45667c98ff8a\nCan I set the above configuration? (type 'yes' to accept): yes\n...\n[OK] All 16384 slots covered\n```\n\n这里集群将7000/7001/7002作为主节点，7004/7005/7003分别作为它们的备份，然后分别分配槽位[0-5460]/[5461-10922]/[10923-16383]。\n\n之前提过任意节点的主备都会共享1个内部维护的配置文件，随便找一个看看它（nodes7000.conf）里面是什么：\n\n```sh\nb27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003@17003,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 slave b40862b42ebd1a3c40df1eabe1eef9c06026a39a 0 1706000689000 3 connected   \na5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005@17005,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 slave 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 0 1706000690000 2 connected   \n61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001@17001,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 master - 0 1706000689657 2 connected 5461-10922\nb40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002@17002,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 master - 0 1706000690668 3 connected 10923-16383\na0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004@17004,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 slave 9a7c5a97e34a57eee737166f54851edc27b80538 0 1706000690972 1 connected   \n9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000@17000,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 myself,master - 0 1706000690000 1 connected 0-5460\nvars currentEpoch 6 lastVoteEpoch 0\n```\n\n可以看到，这个配置文件内包含了集群所有子服务的ID、端口以及节点内的角色信息，如果是master还会带有对应slot信息。\n\n基于此，可以得出结论：\n\n\t1. 任意节点都可以发现自己主不可用的时候，进行故障转移从而保障集群可用\n\n\t2. 新增节点的时候，集群可以为其分配合适角色，槽位变化后将对应槽位的key复制过去\n\n‍\n\n#### 部署方式2\n\n使用 `utils/create-cluster`​ 脚本，其实这个脚本 的start函数就是去创建redis节点；create就是创建集群。\n\n跟部署方式1的两步分别对应的。\n\n1. create-cluster start\n\n```sh\nStarting 30001\nStarting 30002\nStarting 30003\nStarting 30004\nStarting 30005\nStarting 30006\n```\n\n2. create-cluster create\n\n```sh\nM: 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f 127.0.0.1:30001\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nS: 731db1e49b61a405a835c904ec9bf92ccb92c9ac 127.0.0.1:30006\n   slots: (0 slots) slave\n   replicates 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f\nS: 7cccd9c0b4753fb67cc2b7f7dab221b80ee47e89 127.0.0.1:30004\n   slots: (0 slots) slave\n   replicates c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3\nM: c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3 127.0.0.1:30002\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nM: dbac2f171108fdb22fb336a93febbbd46f6d22d8 127.0.0.1:30003\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\nS: 71caec7e3a15a0a0bf4ffc59d8a45efd42361a01 127.0.0.1:30005\n   slots: (0 slots) slave\n   replicates dbac2f171108fdb22fb336a93febbbd46f6d22d8\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n```\n\n3. create-cluster stop\n\n    这个命令会停掉集群及所有实例\n\n‍\n\n### 集群交互\n\n通过redis-cli连接到集群任一节点读写数据。  \n可以看到key分配slot信息。如果不是本身连接节点，集群会帮忙重定向到对应节点，读写都是如此，并且客户端会跳转到该连接节点。  \n`cluster info` 可以读取到集群的基本信息，这可以用于第三方监控。\n\n```sh\n127.0.0.1:7000> cluster info\n# 集群状态\ncluster_state:ok\n# 与节点关联槽数量\ncluster_slots_assigned:16384\n# 映射到不处于FAIL或PFAI状态的槽的数量\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\n# 集群中已知节点数\ncluster_known_nodes:6\n# 集群中Master节点数\ncluster_size:3\n...\n127.0.0.1:7000> set abc 123\n-> Redirected to slot [7638] located at 127.0.0.1:7001\nOK\n127.0.0.1:7001> set abcdef 123\n-> Redirected to slot [15101] located at 127.0.0.1:7002\nOK\n127.0.0.1:7002> set abcdefhjk 123\nOK\n127.0.0.1:7002> get abc\n-> Redirected to slot [7638] located at 127.0.0.1:7001\n\"123\"\n127.0.0.1:7001> get abcdef\n-> Redirected to slot [15101] located at 127.0.0.1:7002\n\"123\"\n127.0.0.1:7002> get abcdefhjk\n\"123\"\n```\n\n### Redis选举机制\n\nRedis集群的选举机制是基于gossip协议的。  \n当一个从节点发现自己的主节点不可用时，它会尝试进行 Failover，以便成为新的主节点。  \n由于挂掉的主节点可能有多个从节点，因此存在多个从节点竞争成为主节点的过程。过程如下：  \n1. 从节点发现自己的主节点不可用;\n2. 从节点将记录集群的 currentEpoch（选举周期）加1，并广播 FAILOVER_AUTH_REQUEST 信息进行选举;\n3. 其他节点收到 FAILOVER_AUTH_REQUEST 信息后，其他的主节点收到消息后返回 FAILOVER_AUTH_ACK 信息(对于同一个 Epoch，只能响应一次 ack);\n4. 尝试failover的从节点收集主节点返回的 ack 消息;\n5. 从节点判断收到大于半数的 ack 消息，成为新的主节点;\n6. 广播 Pong 消息通知其他集群节点。\n\n> 从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。  \n延迟计算公式：  \n```\n# SLAVE_RANK表示此slave已经从master复制数据的总量的rank\n DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms\n```\nRank越小代表已复制的数据越新。理论上，持有最新数据的slave将会首先发起选举。\n\n‍\n","source":"_posts/redis集群-cluster.md","raw":"---\ntitle: redis集群-cluster\ndate: 2024-01-24 10:18:57\ntags: redis\ncategories: 中间件\n---\nRedis的哨兵模式已经存在主备结构，并且能自动故障转移和动态扩容，为什么要整出cluster集群呢?  \n哨兵模式只是一个Master节点的高可用，如果需要一堆节点的高可用呢？集群管理，故障发现，数据分片，这些问题自然应运而生。  \n解决方案就是Cluster。\n<!--more-->\n\n### 特征\n\n1. 多个 Redis 节点之间自动分片\n2. 当小部分节点出现故障或无法与群集的其余部分通信时，集群可以继续运行\n\n‍\n\n### 端口\n\n每个 Redis 集群节点都需要两个开放的 TCP 连接\n\n* 一个用于为客户端提供服务的 Redis TCP 端口（6379）\n* 集群总线端口（默认加上10000，如16379；作用：故障检测、配置更新、故障转移授权等）\n\n‍\n\n### 集群主备模型\n\n集群每个节点，都有1个和N-1个副本构成。  \n以基础的3主+3备为例：  \n​![image](/images/assets/image-20240123142211-7frka5a.png)​\n\n\n### 集群一致性\n\nRedis 集群不保证强一致性，原因：  \n\n1. 异步复制。 可以通过 WAIT 命令实现同步写入\n2. 网络分区。客户端与少数实例隔离，客户端在主节点故障转移前（这个时间可配置<u>node timeout</u>）的写入都会丢失\n\n‍\n\n### 配置参数\n\n* cluster-enabled `<yes/no>`​ ：如果是，则在特定 Redis 实例中启用 Redis 集群支持\n* cluster-config-file `<filename>`​ ：集群节点在每次发生更改时自动保留集群配置（基本上是状态）的文件，用户不要编辑ta\n* cluster-node-timeout `<milliseconds>`​ ：Redis 集群节点不可用的最长时间\n* cluster-migration-barrier `<count>`​ ：主服务器将保持连接的最小副本数\n* cluster-require-full-coverage `<yes/no>`​ ：如果设置为 yes，如果某个百分比的密钥空间未被任何节点覆盖，则停止写入\n* luster-allow-reads-when-down `<yes/no>`​ ：默认否，当集群标记为失败时，是否允许可读\n\n‍\n\n#### 部署方式1（首次执行推荐）\n\n1. 要创建集群，首先需要让几个空的 Redis 实例在集群模式下运行。\n\n每个节点配置文件 redis.conf\n\n```sh\nport 7000\ncluster-enabled yes\ncluster-config-file nodes7000.conf\ncluster-node-timeout 5000\nappendonly yes\n```\n\n基于以上配置，创建一个启动6个节点的脚本（Maste或Slave，角色由集群分配）：\n\n```sh\n#!/bin/bash\nif [ ! -d \"clustertest\" ]; then\n    mkdir clustertest\nfi\nrm -rf ./clustertest/*\ncd clustertest\nfor port in 7000 7001 7002 7003 7004 7005\ndo\n    cp ../redis.conf redis${port}.conf\n    sed -i \"s#port 6379#port ${port}#g\"  redis${port}.conf\n    echo \"cluster-enabled yes\\ncluster-config-file nodes${port}.conf\\ncluster-node-timeout 5000\\nappendonly yes\" >> redis${port}.conf\n    nohup redis-server redis${port}.conf &\ndone\n```\n\n‍\n\n2. 创建Redis Cluster集群，由集群为每个端口创建ID并分配节点角色(M/S)\n\n    ```sh\n    redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\\n    127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\\n    --cluster-replicas 1\n    ```\n\n‍\n\n3. 创建完成反馈实例角色、槽位分配信息等\n\n```sh\n# redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\\n> 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\\n> --cluster-replicas 1\n>>> Performing hash slots allocation on 6 nodes...\nMaster[0] -> Slots 0 - 5460\nMaster[1] -> Slots 5461 - 10922\nMaster[2] -> Slots 10923 - 16383\nAdding replica 127.0.0.1:7004 to 127.0.0.1:7000\nAdding replica 127.0.0.1:7005 to 127.0.0.1:7001\nAdding replica 127.0.0.1:7003 to 127.0.0.1:7002\n>>> Trying to optimize slaves allocation for anti-affinity\n[WARNING] Some slaves are in the same host as their master\nM: 9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000\n   slots:[0-5460] (5461 slots) master\nM: 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001\n   slots:[5461-10922] (5462 slots) master\nM: b40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002\n   slots:[10923-16383] (5461 slots) master\nS: b27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003\n   replicates b40862b42ebd1a3c40df1eabe1eef9c06026a39a\nS: a0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004\n   replicates 9a7c5a97e34a57eee737166f54851edc27b80538\nS: a5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005\n   replicates 61feac4042b4b3c3ab43ace2c85c45667c98ff8a\nCan I set the above configuration? (type 'yes' to accept): yes\n...\n[OK] All 16384 slots covered\n```\n\n这里集群将7000/7001/7002作为主节点，7004/7005/7003分别作为它们的备份，然后分别分配槽位[0-5460]/[5461-10922]/[10923-16383]。\n\n之前提过任意节点的主备都会共享1个内部维护的配置文件，随便找一个看看它（nodes7000.conf）里面是什么：\n\n```sh\nb27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003@17003,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 slave b40862b42ebd1a3c40df1eabe1eef9c06026a39a 0 1706000689000 3 connected   \na5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005@17005,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 slave 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 0 1706000690000 2 connected   \n61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001@17001,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 master - 0 1706000689657 2 connected 5461-10922\nb40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002@17002,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 master - 0 1706000690668 3 connected 10923-16383\na0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004@17004,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 slave 9a7c5a97e34a57eee737166f54851edc27b80538 0 1706000690972 1 connected   \n9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000@17000,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 myself,master - 0 1706000690000 1 connected 0-5460\nvars currentEpoch 6 lastVoteEpoch 0\n```\n\n可以看到，这个配置文件内包含了集群所有子服务的ID、端口以及节点内的角色信息，如果是master还会带有对应slot信息。\n\n基于此，可以得出结论：\n\n\t1. 任意节点都可以发现自己主不可用的时候，进行故障转移从而保障集群可用\n\n\t2. 新增节点的时候，集群可以为其分配合适角色，槽位变化后将对应槽位的key复制过去\n\n‍\n\n#### 部署方式2\n\n使用 `utils/create-cluster`​ 脚本，其实这个脚本 的start函数就是去创建redis节点；create就是创建集群。\n\n跟部署方式1的两步分别对应的。\n\n1. create-cluster start\n\n```sh\nStarting 30001\nStarting 30002\nStarting 30003\nStarting 30004\nStarting 30005\nStarting 30006\n```\n\n2. create-cluster create\n\n```sh\nM: 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f 127.0.0.1:30001\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nS: 731db1e49b61a405a835c904ec9bf92ccb92c9ac 127.0.0.1:30006\n   slots: (0 slots) slave\n   replicates 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f\nS: 7cccd9c0b4753fb67cc2b7f7dab221b80ee47e89 127.0.0.1:30004\n   slots: (0 slots) slave\n   replicates c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3\nM: c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3 127.0.0.1:30002\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nM: dbac2f171108fdb22fb336a93febbbd46f6d22d8 127.0.0.1:30003\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\nS: 71caec7e3a15a0a0bf4ffc59d8a45efd42361a01 127.0.0.1:30005\n   slots: (0 slots) slave\n   replicates dbac2f171108fdb22fb336a93febbbd46f6d22d8\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n```\n\n3. create-cluster stop\n\n    这个命令会停掉集群及所有实例\n\n‍\n\n### 集群交互\n\n通过redis-cli连接到集群任一节点读写数据。  \n可以看到key分配slot信息。如果不是本身连接节点，集群会帮忙重定向到对应节点，读写都是如此，并且客户端会跳转到该连接节点。  \n`cluster info` 可以读取到集群的基本信息，这可以用于第三方监控。\n\n```sh\n127.0.0.1:7000> cluster info\n# 集群状态\ncluster_state:ok\n# 与节点关联槽数量\ncluster_slots_assigned:16384\n# 映射到不处于FAIL或PFAI状态的槽的数量\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\n# 集群中已知节点数\ncluster_known_nodes:6\n# 集群中Master节点数\ncluster_size:3\n...\n127.0.0.1:7000> set abc 123\n-> Redirected to slot [7638] located at 127.0.0.1:7001\nOK\n127.0.0.1:7001> set abcdef 123\n-> Redirected to slot [15101] located at 127.0.0.1:7002\nOK\n127.0.0.1:7002> set abcdefhjk 123\nOK\n127.0.0.1:7002> get abc\n-> Redirected to slot [7638] located at 127.0.0.1:7001\n\"123\"\n127.0.0.1:7001> get abcdef\n-> Redirected to slot [15101] located at 127.0.0.1:7002\n\"123\"\n127.0.0.1:7002> get abcdefhjk\n\"123\"\n```\n\n### Redis选举机制\n\nRedis集群的选举机制是基于gossip协议的。  \n当一个从节点发现自己的主节点不可用时，它会尝试进行 Failover，以便成为新的主节点。  \n由于挂掉的主节点可能有多个从节点，因此存在多个从节点竞争成为主节点的过程。过程如下：  \n1. 从节点发现自己的主节点不可用;\n2. 从节点将记录集群的 currentEpoch（选举周期）加1，并广播 FAILOVER_AUTH_REQUEST 信息进行选举;\n3. 其他节点收到 FAILOVER_AUTH_REQUEST 信息后，其他的主节点收到消息后返回 FAILOVER_AUTH_ACK 信息(对于同一个 Epoch，只能响应一次 ack);\n4. 尝试failover的从节点收集主节点返回的 ack 消息;\n5. 从节点判断收到大于半数的 ack 消息，成为新的主节点;\n6. 广播 Pong 消息通知其他集群节点。\n\n> 从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。  \n延迟计算公式：  \n```\n# SLAVE_RANK表示此slave已经从master复制数据的总量的rank\n DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms\n```\nRank越小代表已复制的数据越新。理论上，持有最新数据的slave将会首先发起选举。\n\n‍\n","slug":"redis集群-cluster","published":1,"updated":"2024-02-18T08:27:42.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz8002mqwvde58i7bxk","content":"<p>Redis的哨兵模式已经存在主备结构，并且能自动故障转移和动态扩容，为什么要整出cluster集群呢?<br>哨兵模式只是一个Master节点的高可用，如果需要一堆节点的高可用呢？集群管理，故障发现，数据分片，这些问题自然应运而生。<br>解决方案就是Cluster。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ol>\n<li>多个 Redis 节点之间自动分片</li>\n<li>当小部分节点出现故障或无法与群集的其余部分通信时，集群可以继续运行</li>\n</ol>\n<p>‍</p>\n<h3 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h3><p>每个 Redis 集群节点都需要两个开放的 TCP 连接</p>\n<ul>\n<li>一个用于为客户端提供服务的 Redis TCP 端口（6379）</li>\n<li>集群总线端口（默认加上10000，如16379；作用：故障检测、配置更新、故障转移授权等）</li>\n</ul>\n<p>‍</p>\n<h3 id=\"集群主备模型\"><a href=\"#集群主备模型\" class=\"headerlink\" title=\"集群主备模型\"></a>集群主备模型</h3><p>集群每个节点，都有1个和N-1个副本构成。<br>以基础的3主+3备为例：<br>​<img src=\"/images/assets/image-20240123142211-7frka5a.png\" alt=\"image\">​</p>\n<h3 id=\"集群一致性\"><a href=\"#集群一致性\" class=\"headerlink\" title=\"集群一致性\"></a>集群一致性</h3><p>Redis 集群不保证强一致性，原因：  </p>\n<ol>\n<li>异步复制。 可以通过 WAIT 命令实现同步写入</li>\n<li>网络分区。客户端与少数实例隔离，客户端在主节点故障转移前（这个时间可配置<u>node timeout</u>）的写入都会丢失</li>\n</ol>\n<p>‍</p>\n<h3 id=\"配置参数\"><a href=\"#配置参数\" class=\"headerlink\" title=\"配置参数\"></a>配置参数</h3><ul>\n<li>cluster-enabled <code>&lt;yes/no&gt;</code>​ ：如果是，则在特定 Redis 实例中启用 Redis 集群支持</li>\n<li>cluster-config-file <code>&lt;filename&gt;</code>​ ：集群节点在每次发生更改时自动保留集群配置（基本上是状态）的文件，用户不要编辑ta</li>\n<li>cluster-node-timeout <code>&lt;milliseconds&gt;</code>​ ：Redis 集群节点不可用的最长时间</li>\n<li>cluster-migration-barrier <code>&lt;count&gt;</code>​ ：主服务器将保持连接的最小副本数</li>\n<li>cluster-require-full-coverage <code>&lt;yes/no&gt;</code>​ ：如果设置为 yes，如果某个百分比的密钥空间未被任何节点覆盖，则停止写入</li>\n<li>luster-allow-reads-when-down <code>&lt;yes/no&gt;</code>​ ：默认否，当集群标记为失败时，是否允许可读</li>\n</ul>\n<p>‍</p>\n<h4 id=\"部署方式1（首次执行推荐）\"><a href=\"#部署方式1（首次执行推荐）\" class=\"headerlink\" title=\"部署方式1（首次执行推荐）\"></a>部署方式1（首次执行推荐）</h4><ol>\n<li>要创建集群，首先需要让几个空的 Redis 实例在集群模式下运行。</li>\n</ol>\n<p>每个节点配置文件 redis.conf</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 7000</span><br><span class=\"line\">cluster-enabled yes</span><br><span class=\"line\">cluster-config-file nodes7000.conf</span><br><span class=\"line\">cluster-node-timeout 5000</span><br><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n\n<p>基于以上配置，创建一个启动6个节点的脚本（Maste或Slave，角色由集群分配）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ ! -d <span class=\"string\">&quot;clustertest&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    mkdir clustertest</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">rm -rf ./clustertest/*</span><br><span class=\"line\"><span class=\"built_in\">cd</span> clustertest</span><br><span class=\"line\"><span class=\"keyword\">for</span> port <span class=\"keyword\">in</span> 7000 7001 7002 7003 7004 7005</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    cp ../redis.conf redis<span class=\"variable\">$&#123;port&#125;</span>.conf</span><br><span class=\"line\">    sed -i <span class=\"string\">&quot;s#port 6379#port <span class=\"variable\">$&#123;port&#125;</span>#g&quot;</span>  redis<span class=\"variable\">$&#123;port&#125;</span>.conf</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;cluster-enabled yes\\ncluster-config-file nodes<span class=\"variable\">$&#123;port&#125;</span>.conf\\ncluster-node-timeout 5000\\nappendonly yes&quot;</span> &gt;&gt; redis<span class=\"variable\">$&#123;port&#125;</span>.conf</span><br><span class=\"line\">    nohup redis-server redis<span class=\"variable\">$&#123;port&#125;</span>.conf &amp;</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<ol start=\"2\">\n<li><p>创建Redis Cluster集群，由集群为每个端口创建ID并分配节点角色(M&#x2F;S)</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\</span><br><span class=\"line\">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\</span><br><span class=\"line\">--cluster-replicas 1</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>‍</p>\n<ol start=\"3\">\n<li>创建完成反馈实例角色、槽位分配信息等</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\</span></span><br><span class=\"line\">&gt; 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\</span><br><span class=\"line\">&gt; --cluster-replicas 1</span><br><span class=\"line\">&gt;&gt;&gt; Performing <span class=\"built_in\">hash</span> slots allocation on 6 nodes...</span><br><span class=\"line\">Master[0] -&gt; Slots 0 - 5460</span><br><span class=\"line\">Master[1] -&gt; Slots 5461 - 10922</span><br><span class=\"line\">Master[2] -&gt; Slots 10923 - 16383</span><br><span class=\"line\">Adding replica 127.0.0.1:7004 to 127.0.0.1:7000</span><br><span class=\"line\">Adding replica 127.0.0.1:7005 to 127.0.0.1:7001</span><br><span class=\"line\">Adding replica 127.0.0.1:7003 to 127.0.0.1:7002</span><br><span class=\"line\">&gt;&gt;&gt; Trying to optimize slaves allocation <span class=\"keyword\">for</span> anti-affinity</span><br><span class=\"line\">[WARNING] Some slaves are <span class=\"keyword\">in</span> the same host as their master</span><br><span class=\"line\">M: 9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">M: 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">M: b40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">S: b27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003</span><br><span class=\"line\">   replicates b40862b42ebd1a3c40df1eabe1eef9c06026a39a</span><br><span class=\"line\">S: a0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004</span><br><span class=\"line\">   replicates 9a7c5a97e34a57eee737166f54851edc27b80538</span><br><span class=\"line\">S: a5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005</span><br><span class=\"line\">   replicates 61feac4042b4b3c3ab43ace2c85c45667c98ff8a</span><br><span class=\"line\">Can I <span class=\"built_in\">set</span> the above configuration? (<span class=\"built_in\">type</span> <span class=\"string\">&#x27;yes&#x27;</span> to accept): yes</span><br><span class=\"line\">...</span><br><span class=\"line\">[OK] All 16384 slots covered</span><br></pre></td></tr></table></figure>\n\n<p>这里集群将7000&#x2F;7001&#x2F;7002作为主节点，7004&#x2F;7005&#x2F;7003分别作为它们的备份，然后分别分配槽位[0-5460]&#x2F;[5461-10922]&#x2F;[10923-16383]。</p>\n<p>之前提过任意节点的主备都会共享1个内部维护的配置文件，随便找一个看看它（nodes7000.conf）里面是什么：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003@17003,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 slave b40862b42ebd1a3c40df1eabe1eef9c06026a39a 0 1706000689000 3 connected   </span><br><span class=\"line\">a5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005@17005,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 slave 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 0 1706000690000 2 connected   </span><br><span class=\"line\">61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001@17001,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 master - 0 1706000689657 2 connected 5461-10922</span><br><span class=\"line\">b40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002@17002,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 master - 0 1706000690668 3 connected 10923-16383</span><br><span class=\"line\">a0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004@17004,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 slave 9a7c5a97e34a57eee737166f54851edc27b80538 0 1706000690972 1 connected   </span><br><span class=\"line\">9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000@17000,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 myself,master - 0 1706000690000 1 connected 0-5460</span><br><span class=\"line\">vars currentEpoch 6 lastVoteEpoch 0</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个配置文件内包含了集群所有子服务的ID、端口以及节点内的角色信息，如果是master还会带有对应slot信息。</p>\n<p>基于此，可以得出结论：</p>\n<pre><code>1. 任意节点都可以发现自己主不可用的时候，进行故障转移从而保障集群可用\n\n2. 新增节点的时候，集群可以为其分配合适角色，槽位变化后将对应槽位的key复制过去\n</code></pre>\n<p>‍</p>\n<h4 id=\"部署方式2\"><a href=\"#部署方式2\" class=\"headerlink\" title=\"部署方式2\"></a>部署方式2</h4><p>使用 <code>utils/create-cluster</code>​ 脚本，其实这个脚本 的start函数就是去创建redis节点；create就是创建集群。</p>\n<p>跟部署方式1的两步分别对应的。</p>\n<ol>\n<li>create-cluster start</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting 30001</span><br><span class=\"line\">Starting 30002</span><br><span class=\"line\">Starting 30003</span><br><span class=\"line\">Starting 30004</span><br><span class=\"line\">Starting 30005</span><br><span class=\"line\">Starting 30006</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>create-cluster create</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M: 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f 127.0.0.1:30001</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">S: 731db1e49b61a405a835c904ec9bf92ccb92c9ac 127.0.0.1:30006</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f</span><br><span class=\"line\">S: 7cccd9c0b4753fb67cc2b7f7dab221b80ee47e89 127.0.0.1:30004</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3</span><br><span class=\"line\">M: c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3 127.0.0.1:30002</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">M: dbac2f171108fdb22fb336a93febbbd46f6d22d8 127.0.0.1:30003</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">S: 71caec7e3a15a0a0bf4ffc59d8a45efd42361a01 127.0.0.1:30005</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates dbac2f171108fdb22fb336a93febbbd46f6d22d8</span><br><span class=\"line\">[OK] All nodes agree about slots configuration.</span><br><span class=\"line\">&gt;&gt;&gt; Check <span class=\"keyword\">for</span> open slots...</span><br><span class=\"line\">&gt;&gt;&gt; Check slots coverage...</span><br><span class=\"line\">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>create-cluster stop</p>\n<p> 这个命令会停掉集群及所有实例</p>\n</li>\n</ol>\n<p>‍</p>\n<h3 id=\"集群交互\"><a href=\"#集群交互\" class=\"headerlink\" title=\"集群交互\"></a>集群交互</h3><p>通过redis-cli连接到集群任一节点读写数据。<br>可以看到key分配slot信息。如果不是本身连接节点，集群会帮忙重定向到对应节点，读写都是如此，并且客户端会跳转到该连接节点。<br><code>cluster info</code> 可以读取到集群的基本信息，这可以用于第三方监控。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:7000&gt; cluster info</span><br><span class=\"line\"><span class=\"comment\"># 集群状态</span></span><br><span class=\"line\">cluster_state:ok</span><br><span class=\"line\"><span class=\"comment\"># 与节点关联槽数量</span></span><br><span class=\"line\">cluster_slots_assigned:16384</span><br><span class=\"line\"><span class=\"comment\"># 映射到不处于FAIL或PFAI状态的槽的数量</span></span><br><span class=\"line\">cluster_slots_ok:16384</span><br><span class=\"line\">cluster_slots_pfail:0</span><br><span class=\"line\">cluster_slots_fail:0</span><br><span class=\"line\"><span class=\"comment\"># 集群中已知节点数</span></span><br><span class=\"line\">cluster_known_nodes:6</span><br><span class=\"line\"><span class=\"comment\"># 集群中Master节点数</span></span><br><span class=\"line\">cluster_size:3</span><br><span class=\"line\">...</span><br><span class=\"line\">127.0.0.1:7000&gt; <span class=\"built_in\">set</span> abc 123</span><br><span class=\"line\">-&gt; Redirected to slot [7638] located at 127.0.0.1:7001</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7001&gt; <span class=\"built_in\">set</span> abcdef 123</span><br><span class=\"line\">-&gt; Redirected to slot [15101] located at 127.0.0.1:7002</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7002&gt; <span class=\"built_in\">set</span> abcdefhjk 123</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7002&gt; get abc</span><br><span class=\"line\">-&gt; Redirected to slot [7638] located at 127.0.0.1:7001</span><br><span class=\"line\"><span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\">127.0.0.1:7001&gt; get abcdef</span><br><span class=\"line\">-&gt; Redirected to slot [15101] located at 127.0.0.1:7002</span><br><span class=\"line\"><span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\">127.0.0.1:7002&gt; get abcdefhjk</span><br><span class=\"line\"><span class=\"string\">&quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Redis选举机制\"><a href=\"#Redis选举机制\" class=\"headerlink\" title=\"Redis选举机制\"></a>Redis选举机制</h3><p>Redis集群的选举机制是基于gossip协议的。<br>当一个从节点发现自己的主节点不可用时，它会尝试进行 Failover，以便成为新的主节点。<br>由于挂掉的主节点可能有多个从节点，因此存在多个从节点竞争成为主节点的过程。过程如下：  </p>\n<ol>\n<li>从节点发现自己的主节点不可用;</li>\n<li>从节点将记录集群的 currentEpoch（选举周期）加1，并广播 FAILOVER_AUTH_REQUEST 信息进行选举;</li>\n<li>其他节点收到 FAILOVER_AUTH_REQUEST 信息后，其他的主节点收到消息后返回 FAILOVER_AUTH_ACK 信息(对于同一个 Epoch，只能响应一次 ack);</li>\n<li>尝试failover的从节点收集主节点返回的 ack 消息;</li>\n<li>从节点判断收到大于半数的 ack 消息，成为新的主节点;</li>\n<li>广播 Pong 消息通知其他集群节点。</li>\n</ol>\n<blockquote>\n<p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。<br>延迟计算公式：  </p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SLAVE_RANK表示此slave已经从master复制数据的总量的rank</span><br><span class=\"line\"> DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</span><br></pre></td></tr></table></figure>\n<p>Rank越小代表已复制的数据越新。理论上，持有最新数据的slave将会首先发起选举。</p>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>Redis的哨兵模式已经存在主备结构，并且能自动故障转移和动态扩容，为什么要整出cluster集群呢?<br>哨兵模式只是一个Master节点的高可用，如果需要一堆节点的高可用呢？集群管理，故障发现，数据分片，这些问题自然应运而生。<br>解决方案就是Cluster。</p>","more":"<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ol>\n<li>多个 Redis 节点之间自动分片</li>\n<li>当小部分节点出现故障或无法与群集的其余部分通信时，集群可以继续运行</li>\n</ol>\n<p>‍</p>\n<h3 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h3><p>每个 Redis 集群节点都需要两个开放的 TCP 连接</p>\n<ul>\n<li>一个用于为客户端提供服务的 Redis TCP 端口（6379）</li>\n<li>集群总线端口（默认加上10000，如16379；作用：故障检测、配置更新、故障转移授权等）</li>\n</ul>\n<p>‍</p>\n<h3 id=\"集群主备模型\"><a href=\"#集群主备模型\" class=\"headerlink\" title=\"集群主备模型\"></a>集群主备模型</h3><p>集群每个节点，都有1个和N-1个副本构成。<br>以基础的3主+3备为例：<br>​<img src=\"/images/assets/image-20240123142211-7frka5a.png\" alt=\"image\">​</p>\n<h3 id=\"集群一致性\"><a href=\"#集群一致性\" class=\"headerlink\" title=\"集群一致性\"></a>集群一致性</h3><p>Redis 集群不保证强一致性，原因：  </p>\n<ol>\n<li>异步复制。 可以通过 WAIT 命令实现同步写入</li>\n<li>网络分区。客户端与少数实例隔离，客户端在主节点故障转移前（这个时间可配置<u>node timeout</u>）的写入都会丢失</li>\n</ol>\n<p>‍</p>\n<h3 id=\"配置参数\"><a href=\"#配置参数\" class=\"headerlink\" title=\"配置参数\"></a>配置参数</h3><ul>\n<li>cluster-enabled <code>&lt;yes/no&gt;</code>​ ：如果是，则在特定 Redis 实例中启用 Redis 集群支持</li>\n<li>cluster-config-file <code>&lt;filename&gt;</code>​ ：集群节点在每次发生更改时自动保留集群配置（基本上是状态）的文件，用户不要编辑ta</li>\n<li>cluster-node-timeout <code>&lt;milliseconds&gt;</code>​ ：Redis 集群节点不可用的最长时间</li>\n<li>cluster-migration-barrier <code>&lt;count&gt;</code>​ ：主服务器将保持连接的最小副本数</li>\n<li>cluster-require-full-coverage <code>&lt;yes/no&gt;</code>​ ：如果设置为 yes，如果某个百分比的密钥空间未被任何节点覆盖，则停止写入</li>\n<li>luster-allow-reads-when-down <code>&lt;yes/no&gt;</code>​ ：默认否，当集群标记为失败时，是否允许可读</li>\n</ul>\n<p>‍</p>\n<h4 id=\"部署方式1（首次执行推荐）\"><a href=\"#部署方式1（首次执行推荐）\" class=\"headerlink\" title=\"部署方式1（首次执行推荐）\"></a>部署方式1（首次执行推荐）</h4><ol>\n<li>要创建集群，首先需要让几个空的 Redis 实例在集群模式下运行。</li>\n</ol>\n<p>每个节点配置文件 redis.conf</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 7000</span><br><span class=\"line\">cluster-enabled yes</span><br><span class=\"line\">cluster-config-file nodes7000.conf</span><br><span class=\"line\">cluster-node-timeout 5000</span><br><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n\n<p>基于以上配置，创建一个启动6个节点的脚本（Maste或Slave，角色由集群分配）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ ! -d <span class=\"string\">&quot;clustertest&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    mkdir clustertest</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">rm -rf ./clustertest/*</span><br><span class=\"line\"><span class=\"built_in\">cd</span> clustertest</span><br><span class=\"line\"><span class=\"keyword\">for</span> port <span class=\"keyword\">in</span> 7000 7001 7002 7003 7004 7005</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    cp ../redis.conf redis<span class=\"variable\">$&#123;port&#125;</span>.conf</span><br><span class=\"line\">    sed -i <span class=\"string\">&quot;s#port 6379#port <span class=\"variable\">$&#123;port&#125;</span>#g&quot;</span>  redis<span class=\"variable\">$&#123;port&#125;</span>.conf</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;cluster-enabled yes\\ncluster-config-file nodes<span class=\"variable\">$&#123;port&#125;</span>.conf\\ncluster-node-timeout 5000\\nappendonly yes&quot;</span> &gt;&gt; redis<span class=\"variable\">$&#123;port&#125;</span>.conf</span><br><span class=\"line\">    nohup redis-server redis<span class=\"variable\">$&#123;port&#125;</span>.conf &amp;</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<ol start=\"2\">\n<li><p>创建Redis Cluster集群，由集群为每个端口创建ID并分配节点角色(M&#x2F;S)</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\</span><br><span class=\"line\">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\</span><br><span class=\"line\">--cluster-replicas 1</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>‍</p>\n<ol start=\"3\">\n<li>创建完成反馈实例角色、槽位分配信息等</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\</span></span><br><span class=\"line\">&gt; 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\</span><br><span class=\"line\">&gt; --cluster-replicas 1</span><br><span class=\"line\">&gt;&gt;&gt; Performing <span class=\"built_in\">hash</span> slots allocation on 6 nodes...</span><br><span class=\"line\">Master[0] -&gt; Slots 0 - 5460</span><br><span class=\"line\">Master[1] -&gt; Slots 5461 - 10922</span><br><span class=\"line\">Master[2] -&gt; Slots 10923 - 16383</span><br><span class=\"line\">Adding replica 127.0.0.1:7004 to 127.0.0.1:7000</span><br><span class=\"line\">Adding replica 127.0.0.1:7005 to 127.0.0.1:7001</span><br><span class=\"line\">Adding replica 127.0.0.1:7003 to 127.0.0.1:7002</span><br><span class=\"line\">&gt;&gt;&gt; Trying to optimize slaves allocation <span class=\"keyword\">for</span> anti-affinity</span><br><span class=\"line\">[WARNING] Some slaves are <span class=\"keyword\">in</span> the same host as their master</span><br><span class=\"line\">M: 9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">M: 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">M: b40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">S: b27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003</span><br><span class=\"line\">   replicates b40862b42ebd1a3c40df1eabe1eef9c06026a39a</span><br><span class=\"line\">S: a0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004</span><br><span class=\"line\">   replicates 9a7c5a97e34a57eee737166f54851edc27b80538</span><br><span class=\"line\">S: a5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005</span><br><span class=\"line\">   replicates 61feac4042b4b3c3ab43ace2c85c45667c98ff8a</span><br><span class=\"line\">Can I <span class=\"built_in\">set</span> the above configuration? (<span class=\"built_in\">type</span> <span class=\"string\">&#x27;yes&#x27;</span> to accept): yes</span><br><span class=\"line\">...</span><br><span class=\"line\">[OK] All 16384 slots covered</span><br></pre></td></tr></table></figure>\n\n<p>这里集群将7000&#x2F;7001&#x2F;7002作为主节点，7004&#x2F;7005&#x2F;7003分别作为它们的备份，然后分别分配槽位[0-5460]&#x2F;[5461-10922]&#x2F;[10923-16383]。</p>\n<p>之前提过任意节点的主备都会共享1个内部维护的配置文件，随便找一个看看它（nodes7000.conf）里面是什么：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b27d12f522eed9fbe3062b0d5be63598251b836a 127.0.0.1:7003@17003,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 slave b40862b42ebd1a3c40df1eabe1eef9c06026a39a 0 1706000689000 3 connected   </span><br><span class=\"line\">a5f06fad49384780af55a938dd4aa553b48f7eaa 127.0.0.1:7005@17005,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 slave 61feac4042b4b3c3ab43ace2c85c45667c98ff8a 0 1706000690000 2 connected   </span><br><span class=\"line\">61feac4042b4b3c3ab43ace2c85c45667c98ff8a 127.0.0.1:7001@17001,,tls-port=0,shard-id=49092a880937bcad546a472a5b04914d0c3d9fb0 master - 0 1706000689657 2 connected 5461-10922</span><br><span class=\"line\">b40862b42ebd1a3c40df1eabe1eef9c06026a39a 127.0.0.1:7002@17002,,tls-port=0,shard-id=70775289706c7855eeb17d765170af0b26f5dca6 master - 0 1706000690668 3 connected 10923-16383</span><br><span class=\"line\">a0883f0a14533b8fb5a3ddfe565330da089602b3 127.0.0.1:7004@17004,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 slave 9a7c5a97e34a57eee737166f54851edc27b80538 0 1706000690972 1 connected   </span><br><span class=\"line\">9a7c5a97e34a57eee737166f54851edc27b80538 127.0.0.1:7000@17000,,tls-port=0,shard-id=f2820606ef71d32e5e0e4cda08f4622c98ab1635 myself,master - 0 1706000690000 1 connected 0-5460</span><br><span class=\"line\">vars currentEpoch 6 lastVoteEpoch 0</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个配置文件内包含了集群所有子服务的ID、端口以及节点内的角色信息，如果是master还会带有对应slot信息。</p>\n<p>基于此，可以得出结论：</p>\n<pre><code>1. 任意节点都可以发现自己主不可用的时候，进行故障转移从而保障集群可用\n\n2. 新增节点的时候，集群可以为其分配合适角色，槽位变化后将对应槽位的key复制过去\n</code></pre>\n<p>‍</p>\n<h4 id=\"部署方式2\"><a href=\"#部署方式2\" class=\"headerlink\" title=\"部署方式2\"></a>部署方式2</h4><p>使用 <code>utils/create-cluster</code>​ 脚本，其实这个脚本 的start函数就是去创建redis节点；create就是创建集群。</p>\n<p>跟部署方式1的两步分别对应的。</p>\n<ol>\n<li>create-cluster start</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting 30001</span><br><span class=\"line\">Starting 30002</span><br><span class=\"line\">Starting 30003</span><br><span class=\"line\">Starting 30004</span><br><span class=\"line\">Starting 30005</span><br><span class=\"line\">Starting 30006</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>create-cluster create</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M: 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f 127.0.0.1:30001</span><br><span class=\"line\">   slots:[0-5460] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">S: 731db1e49b61a405a835c904ec9bf92ccb92c9ac 127.0.0.1:30006</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates 0d47125dcf264ca1e0e70feee5ba0bfb282a4f0f</span><br><span class=\"line\">S: 7cccd9c0b4753fb67cc2b7f7dab221b80ee47e89 127.0.0.1:30004</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3</span><br><span class=\"line\">M: c0418e4d34fe627f2080ac4261e5dbc6f4a6d3c3 127.0.0.1:30002</span><br><span class=\"line\">   slots:[5461-10922] (5462 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">M: dbac2f171108fdb22fb336a93febbbd46f6d22d8 127.0.0.1:30003</span><br><span class=\"line\">   slots:[10923-16383] (5461 slots) master</span><br><span class=\"line\">   1 additional replica(s)</span><br><span class=\"line\">S: 71caec7e3a15a0a0bf4ffc59d8a45efd42361a01 127.0.0.1:30005</span><br><span class=\"line\">   slots: (0 slots) slave</span><br><span class=\"line\">   replicates dbac2f171108fdb22fb336a93febbbd46f6d22d8</span><br><span class=\"line\">[OK] All nodes agree about slots configuration.</span><br><span class=\"line\">&gt;&gt;&gt; Check <span class=\"keyword\">for</span> open slots...</span><br><span class=\"line\">&gt;&gt;&gt; Check slots coverage...</span><br><span class=\"line\">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>create-cluster stop</p>\n<p> 这个命令会停掉集群及所有实例</p>\n</li>\n</ol>\n<p>‍</p>\n<h3 id=\"集群交互\"><a href=\"#集群交互\" class=\"headerlink\" title=\"集群交互\"></a>集群交互</h3><p>通过redis-cli连接到集群任一节点读写数据。<br>可以看到key分配slot信息。如果不是本身连接节点，集群会帮忙重定向到对应节点，读写都是如此，并且客户端会跳转到该连接节点。<br><code>cluster info</code> 可以读取到集群的基本信息，这可以用于第三方监控。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:7000&gt; cluster info</span><br><span class=\"line\"><span class=\"comment\"># 集群状态</span></span><br><span class=\"line\">cluster_state:ok</span><br><span class=\"line\"><span class=\"comment\"># 与节点关联槽数量</span></span><br><span class=\"line\">cluster_slots_assigned:16384</span><br><span class=\"line\"><span class=\"comment\"># 映射到不处于FAIL或PFAI状态的槽的数量</span></span><br><span class=\"line\">cluster_slots_ok:16384</span><br><span class=\"line\">cluster_slots_pfail:0</span><br><span class=\"line\">cluster_slots_fail:0</span><br><span class=\"line\"><span class=\"comment\"># 集群中已知节点数</span></span><br><span class=\"line\">cluster_known_nodes:6</span><br><span class=\"line\"><span class=\"comment\"># 集群中Master节点数</span></span><br><span class=\"line\">cluster_size:3</span><br><span class=\"line\">...</span><br><span class=\"line\">127.0.0.1:7000&gt; <span class=\"built_in\">set</span> abc 123</span><br><span class=\"line\">-&gt; Redirected to slot [7638] located at 127.0.0.1:7001</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7001&gt; <span class=\"built_in\">set</span> abcdef 123</span><br><span class=\"line\">-&gt; Redirected to slot [15101] located at 127.0.0.1:7002</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7002&gt; <span class=\"built_in\">set</span> abcdefhjk 123</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:7002&gt; get abc</span><br><span class=\"line\">-&gt; Redirected to slot [7638] located at 127.0.0.1:7001</span><br><span class=\"line\"><span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\">127.0.0.1:7001&gt; get abcdef</span><br><span class=\"line\">-&gt; Redirected to slot [15101] located at 127.0.0.1:7002</span><br><span class=\"line\"><span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\">127.0.0.1:7002&gt; get abcdefhjk</span><br><span class=\"line\"><span class=\"string\">&quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Redis选举机制\"><a href=\"#Redis选举机制\" class=\"headerlink\" title=\"Redis选举机制\"></a>Redis选举机制</h3><p>Redis集群的选举机制是基于gossip协议的。<br>当一个从节点发现自己的主节点不可用时，它会尝试进行 Failover，以便成为新的主节点。<br>由于挂掉的主节点可能有多个从节点，因此存在多个从节点竞争成为主节点的过程。过程如下：  </p>\n<ol>\n<li>从节点发现自己的主节点不可用;</li>\n<li>从节点将记录集群的 currentEpoch（选举周期）加1，并广播 FAILOVER_AUTH_REQUEST 信息进行选举;</li>\n<li>其他节点收到 FAILOVER_AUTH_REQUEST 信息后，其他的主节点收到消息后返回 FAILOVER_AUTH_ACK 信息(对于同一个 Epoch，只能响应一次 ack);</li>\n<li>尝试failover的从节点收集主节点返回的 ack 消息;</li>\n<li>从节点判断收到大于半数的 ack 消息，成为新的主节点;</li>\n<li>广播 Pong 消息通知其他集群节点。</li>\n</ol>\n<blockquote>\n<p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。<br>延迟计算公式：  </p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SLAVE_RANK表示此slave已经从master复制数据的总量的rank</span><br><span class=\"line\"> DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</span><br></pre></td></tr></table></figure>\n<p>Rank越小代表已复制的数据越新。理论上，持有最新数据的slave将会首先发起选举。</p>\n<p>‍</p>"},{"title":"redis集群-sentinel","date":"2024-01-19T13:22:58.000Z","_content":"redis哨兵模式实现了redis基本的高可用\n<!--more-->\n# 理解哨兵集群结构\n\n[理解sentinel集群](https://redis.io/docs/management/sentinel/)  \n一个典型的哨兵集群：1主(M)2从(R)  3哨兵(S)​​  \n```sh\n      +----+\n       | M1 |\n       | S1 |\n       +----+\n          |\n+----+    |    +----+\n| R2 |----+----| R3 |\n| S2 |         | S3 |\n+----+         +----+\n\nConfiguration: quorum = 2\n```\n故障转移检测配置：  \n``` ini\n# 至少 1 个副本同步写不成功\nmin-replicas-to-write 1\n# 超过max-lag秒数的时间内没有向主发送异步确认\nmin-replicas-max-lag 10\n```\n如果主 M1 发生故障，S2 和 S3 将就故障达成一致，并能够授权故障转移，使客户端能够继续。  \n\n# Redis及Sentinel配置\n\n## Redis从节点配置\nredis主节点配置不需要变更，从节点只需要声明是主节点的备份  \n`replicaof 127.0.0.1 6379`  \n在5.0或更早的版本中的命令是  \n`slaveof 127.0.0.1 6379`  \n> 注意每个redis节点占用不同端口  \n\n## Sentinel配置\nsentinel的配置文件为 sentinel.conf,以下列出其中的关键配置：    \n``` ini\n# 哨兵通信端口\nport 26379\n# 监控主节点名称/端口 以及多少个节点同意方可故障转移\nsentinel monitor mymaster 127.0.0.1 6379 2  \n# Sentinel认为它已关闭时，实例不应访问的时间\nsentinel down-after-milliseconds mymaster 60000  \n# 多长时间内不再对同一节点重试故障转移\nsentinel failover-timeout mymaster 180000  \n# 故障转移后，可以重新配置为同时使用新主服务器的副本数量\nsentinel parallel-syncs mymaster 1\n```\n> 注意：多个\n\n\n启动哨兵:  \n`redis-sentinel /path/to/sentinel.conf`   或    \n`redis-server /path/to/sentinel.conf --sentinel`\n\n\n# 启动集群  \n基于以上Redis及哨兵配置启动的知识，编辑启动Redis哨兵集群脚本：  \n```sh\n#!/bin/bash\n# config 2 slave\ncp redis.conf redis6380.conf\ncp redis.conf redis6381.conf\nsed -i \"s#$port 6379#$port 6380#g\"  redis6380.conf\nsed -i \"s#$port 6379#$port 6381#g\"  redis6381.conf\n# 在5以下，旧的版本中为 slaveof \necho \"replicaof 127.0.0.1 6379\" >> redis6380.conf\necho \"replicaof 127.0.0.1 6379\" >> redis6381.conf\n# run 1 master and 2 slave\nnohup redis-server redis.conf &\nnohup redis-server redis6380.conf &\nnohup redis-server redis6381.conf &\n# config 2 sentinel\ncp sentinel.conf sentinel6380.conf\ncp sentinel.conf sentinel6381.conf\nsed -i \"s#$port 26379#$port 26380#g\"  sentinel6380.conf\nsed -i \"s#$port 26379#$port 26381#g\"  sentinel6381.conf\n# run 3 sentinel\nnohup redis-sentinel  sentinel.conf &\nnohup redis-sentinel  sentinel6380.conf &\nnohup redis-sentinel  sentinel6381.conf &\n```\n\n## 查看集群状态：  \n- 主节点\n```sh\nredis-cli -h localhost -p 6379\n\n127.0.0.1:6379> info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6381,state=online,offset=17714,lag=1\nslave1:ip=127.0.0.1,port=6380,state=online,offset=17714,lag=1\n```\n- 从结点  \n  如果是连接到从节点，那么角色就是slave，并且只读不可写  \n```sh\nlocalhost:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\nmaster_link_status:up\n...\nlocalhost:6380> get 'a'\n\"1\"\nlocalhost:6380> set 'a' 2\n(error) READONLY You can't write against a read only replica.\n```\n\n# 故障切换\n\n## 主节点挂掉\n现在测试下哨兵的故障切换，连上6379，并执行shutdown  \n```sh\n127.0.0.1:6379> shutdown\nnot connected>\n```\n然后在从节点看下集群信息，发现主已经切换到6381了：  \n```sh\nlocalhost:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6381\nmaster_link_status:up\n```\n它其实是动态地修改了配置信息的。可以重新查看下redis节点的配置文件和哨兵的sentinel.conf配置文件中的，已经将主节点改为了6381  \n```sh\n# 节点配置文件\nreplicaof 127.0.0.1 6381\n\n# 哨兵配置文件\nsentinel monitor mymaster 127.0.0.1 6381 2\n```\n\n此时故障切换测试完成。 也可以再连上6381验证读写和info信息。  \n\n此时，如果主再挂掉，剩下的一个将处于只读不可写状态，因为配置文件中配置了quorum 参数（故障转移需要投票同意的节点数）为2\n\n## 自动发现\n\n另外， 我想测试下哨兵模式 的服务自动发现。 此处按照上面的脚本，同样准备一段执行代码  \n```sh\n#!/bin/bash\ncp redis.conf redis6382.conf\nsed -i \"s#$port 6379#$port 6382#g\"  redis6382.conf\necho \"replicaof 127.0.0.1 6381\" >> redis6382.conf\nnohup redis-server redis6382.conf &\ncp sentinel.conf sentinel6382.conf\nsed -i \"s#$port 26379#$port 26382#g\"  sentinel6382.conf\nnohup redis-sentinel  sentinel6382.conf &\n```\n> 注意： 这里sentinel.conf自动对齐了主节点，\n`sentinel monitor mymaster 127.0.0.1 6381 2`\n但是redis.conf中的端口还是6379，所以脚本略有变更  \n\n然后，在主节点6381下查看集群信息。可以看到6382确实是自动加入进来了。  \n```sh\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6380,state=online,offset=610579,lag=1\nslave1:ip=127.0.0.1,port=6382,state=online,offset=610579,lag=1\n```\n\n## 自动恢复\n  \n``` sh\n# 重新启动6379结点，预期中它应该重新连上集群，并成为Redis从节点\nnohup redis-server redis.conf &\n```\n然后在主节点查看集群信息  \n```sh\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:3\nslave0:ip=127.0.0.1,port=6380,state=online,offset=722511,lag=1\nslave1:ip=127.0.0.1,port=6382,state=online,offset=722511,lag=1\nslave2:ip=127.0.0.1,port=6379,state=online,offset=722644,lag=1\n```  \n> 如果想更仔细观察，建议配置日志 。默认`logfile`为空，意思是输出丢弃\n\n‍\n\n","source":"_posts/redis集群-sentinel.md","raw":"---\ntitle: redis集群-sentinel\ndate: 2024-01-19 21:22:58\ntags: redis\ncategories: 中间件\n---\nredis哨兵模式实现了redis基本的高可用\n<!--more-->\n# 理解哨兵集群结构\n\n[理解sentinel集群](https://redis.io/docs/management/sentinel/)  \n一个典型的哨兵集群：1主(M)2从(R)  3哨兵(S)​​  \n```sh\n      +----+\n       | M1 |\n       | S1 |\n       +----+\n          |\n+----+    |    +----+\n| R2 |----+----| R3 |\n| S2 |         | S3 |\n+----+         +----+\n\nConfiguration: quorum = 2\n```\n故障转移检测配置：  \n``` ini\n# 至少 1 个副本同步写不成功\nmin-replicas-to-write 1\n# 超过max-lag秒数的时间内没有向主发送异步确认\nmin-replicas-max-lag 10\n```\n如果主 M1 发生故障，S2 和 S3 将就故障达成一致，并能够授权故障转移，使客户端能够继续。  \n\n# Redis及Sentinel配置\n\n## Redis从节点配置\nredis主节点配置不需要变更，从节点只需要声明是主节点的备份  \n`replicaof 127.0.0.1 6379`  \n在5.0或更早的版本中的命令是  \n`slaveof 127.0.0.1 6379`  \n> 注意每个redis节点占用不同端口  \n\n## Sentinel配置\nsentinel的配置文件为 sentinel.conf,以下列出其中的关键配置：    \n``` ini\n# 哨兵通信端口\nport 26379\n# 监控主节点名称/端口 以及多少个节点同意方可故障转移\nsentinel monitor mymaster 127.0.0.1 6379 2  \n# Sentinel认为它已关闭时，实例不应访问的时间\nsentinel down-after-milliseconds mymaster 60000  \n# 多长时间内不再对同一节点重试故障转移\nsentinel failover-timeout mymaster 180000  \n# 故障转移后，可以重新配置为同时使用新主服务器的副本数量\nsentinel parallel-syncs mymaster 1\n```\n> 注意：多个\n\n\n启动哨兵:  \n`redis-sentinel /path/to/sentinel.conf`   或    \n`redis-server /path/to/sentinel.conf --sentinel`\n\n\n# 启动集群  \n基于以上Redis及哨兵配置启动的知识，编辑启动Redis哨兵集群脚本：  \n```sh\n#!/bin/bash\n# config 2 slave\ncp redis.conf redis6380.conf\ncp redis.conf redis6381.conf\nsed -i \"s#$port 6379#$port 6380#g\"  redis6380.conf\nsed -i \"s#$port 6379#$port 6381#g\"  redis6381.conf\n# 在5以下，旧的版本中为 slaveof \necho \"replicaof 127.0.0.1 6379\" >> redis6380.conf\necho \"replicaof 127.0.0.1 6379\" >> redis6381.conf\n# run 1 master and 2 slave\nnohup redis-server redis.conf &\nnohup redis-server redis6380.conf &\nnohup redis-server redis6381.conf &\n# config 2 sentinel\ncp sentinel.conf sentinel6380.conf\ncp sentinel.conf sentinel6381.conf\nsed -i \"s#$port 26379#$port 26380#g\"  sentinel6380.conf\nsed -i \"s#$port 26379#$port 26381#g\"  sentinel6381.conf\n# run 3 sentinel\nnohup redis-sentinel  sentinel.conf &\nnohup redis-sentinel  sentinel6380.conf &\nnohup redis-sentinel  sentinel6381.conf &\n```\n\n## 查看集群状态：  \n- 主节点\n```sh\nredis-cli -h localhost -p 6379\n\n127.0.0.1:6379> info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6381,state=online,offset=17714,lag=1\nslave1:ip=127.0.0.1,port=6380,state=online,offset=17714,lag=1\n```\n- 从结点  \n  如果是连接到从节点，那么角色就是slave，并且只读不可写  \n```sh\nlocalhost:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\nmaster_link_status:up\n...\nlocalhost:6380> get 'a'\n\"1\"\nlocalhost:6380> set 'a' 2\n(error) READONLY You can't write against a read only replica.\n```\n\n# 故障切换\n\n## 主节点挂掉\n现在测试下哨兵的故障切换，连上6379，并执行shutdown  \n```sh\n127.0.0.1:6379> shutdown\nnot connected>\n```\n然后在从节点看下集群信息，发现主已经切换到6381了：  \n```sh\nlocalhost:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6381\nmaster_link_status:up\n```\n它其实是动态地修改了配置信息的。可以重新查看下redis节点的配置文件和哨兵的sentinel.conf配置文件中的，已经将主节点改为了6381  \n```sh\n# 节点配置文件\nreplicaof 127.0.0.1 6381\n\n# 哨兵配置文件\nsentinel monitor mymaster 127.0.0.1 6381 2\n```\n\n此时故障切换测试完成。 也可以再连上6381验证读写和info信息。  \n\n此时，如果主再挂掉，剩下的一个将处于只读不可写状态，因为配置文件中配置了quorum 参数（故障转移需要投票同意的节点数）为2\n\n## 自动发现\n\n另外， 我想测试下哨兵模式 的服务自动发现。 此处按照上面的脚本，同样准备一段执行代码  \n```sh\n#!/bin/bash\ncp redis.conf redis6382.conf\nsed -i \"s#$port 6379#$port 6382#g\"  redis6382.conf\necho \"replicaof 127.0.0.1 6381\" >> redis6382.conf\nnohup redis-server redis6382.conf &\ncp sentinel.conf sentinel6382.conf\nsed -i \"s#$port 26379#$port 26382#g\"  sentinel6382.conf\nnohup redis-sentinel  sentinel6382.conf &\n```\n> 注意： 这里sentinel.conf自动对齐了主节点，\n`sentinel monitor mymaster 127.0.0.1 6381 2`\n但是redis.conf中的端口还是6379，所以脚本略有变更  \n\n然后，在主节点6381下查看集群信息。可以看到6382确实是自动加入进来了。  \n```sh\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6380,state=online,offset=610579,lag=1\nslave1:ip=127.0.0.1,port=6382,state=online,offset=610579,lag=1\n```\n\n## 自动恢复\n  \n``` sh\n# 重新启动6379结点，预期中它应该重新连上集群，并成为Redis从节点\nnohup redis-server redis.conf &\n```\n然后在主节点查看集群信息  \n```sh\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:3\nslave0:ip=127.0.0.1,port=6380,state=online,offset=722511,lag=1\nslave1:ip=127.0.0.1,port=6382,state=online,offset=722511,lag=1\nslave2:ip=127.0.0.1,port=6379,state=online,offset=722644,lag=1\n```  \n> 如果想更仔细观察，建议配置日志 。默认`logfile`为空，意思是输出丢弃\n\n‍\n\n","slug":"redis集群-sentinel","published":1,"updated":"2024-02-18T08:28:11.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6oz9002rqwvdeax168jx","content":"<p>redis哨兵模式实现了redis基本的高可用</p>\n<span id=\"more\"></span>\n<h1 id=\"理解哨兵集群结构\"><a href=\"#理解哨兵集群结构\" class=\"headerlink\" title=\"理解哨兵集群结构\"></a>理解哨兵集群结构</h1><p><a href=\"https://redis.io/docs/management/sentinel/\">理解sentinel集群</a><br>一个典型的哨兵集群：1主(M)2从(R)  3哨兵(S)​​  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      +----+</span><br><span class=\"line\">       | M1 |</span><br><span class=\"line\">       | S1 |</span><br><span class=\"line\">       +----+</span><br><span class=\"line\">          |</span><br><span class=\"line\">+----+    |    +----+</span><br><span class=\"line\">| R2 |----+----| R3 |</span><br><span class=\"line\">| S2 |         | S3 |</span><br><span class=\"line\">+----+         +----+</span><br><span class=\"line\"></span><br><span class=\"line\">Configuration: quorum = 2</span><br></pre></td></tr></table></figure>\n<p>故障转移检测配置：  </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 至少 1 个副本同步写不成功</span></span><br><span class=\"line\">min-replicas-to-write 1</span><br><span class=\"line\"><span class=\"comment\"># 超过max-lag秒数的时间内没有向主发送异步确认</span></span><br><span class=\"line\">min-replicas-max-lag 10</span><br></pre></td></tr></table></figure>\n<p>如果主 M1 发生故障，S2 和 S3 将就故障达成一致，并能够授权故障转移，使客户端能够继续。  </p>\n<h1 id=\"Redis及Sentinel配置\"><a href=\"#Redis及Sentinel配置\" class=\"headerlink\" title=\"Redis及Sentinel配置\"></a>Redis及Sentinel配置</h1><h2 id=\"Redis从节点配置\"><a href=\"#Redis从节点配置\" class=\"headerlink\" title=\"Redis从节点配置\"></a>Redis从节点配置</h2><p>redis主节点配置不需要变更，从节点只需要声明是主节点的备份<br><code>replicaof 127.0.0.1 6379</code><br>在5.0或更早的版本中的命令是<br><code>slaveof 127.0.0.1 6379</code>  </p>\n<blockquote>\n<p>注意每个redis节点占用不同端口  </p>\n</blockquote>\n<h2 id=\"Sentinel配置\"><a href=\"#Sentinel配置\" class=\"headerlink\" title=\"Sentinel配置\"></a>Sentinel配置</h2><p>sentinel的配置文件为 sentinel.conf,以下列出其中的关键配置：    </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 哨兵通信端口</span></span><br><span class=\"line\">port 26379</span><br><span class=\"line\"><span class=\"comment\"># 监控主节点名称/端口 以及多少个节点同意方可故障转移</span></span><br><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2  </span><br><span class=\"line\"><span class=\"comment\"># Sentinel认为它已关闭时，实例不应访问的时间</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 60000  </span><br><span class=\"line\"><span class=\"comment\"># 多长时间内不再对同一节点重试故障转移</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 180000  </span><br><span class=\"line\"><span class=\"comment\"># 故障转移后，可以重新配置为同时使用新主服务器的副本数量</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：多个</p>\n</blockquote>\n<p>启动哨兵:<br><code>redis-sentinel /path/to/sentinel.conf</code>   或<br><code>redis-server /path/to/sentinel.conf --sentinel</code></p>\n<h1 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h1><p>基于以上Redis及哨兵配置启动的知识，编辑启动Redis哨兵集群脚本：  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># config 2 slave</span></span><br><span class=\"line\">cp redis.conf redis6380.conf</span><br><span class=\"line\">cp redis.conf redis6381.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 6379#<span class=\"variable\">$port</span> 6380#g&quot;</span>  redis6380.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 6379#<span class=\"variable\">$port</span> 6381#g&quot;</span>  redis6381.conf</span><br><span class=\"line\"><span class=\"comment\"># 在5以下，旧的版本中为 slaveof </span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;replicaof 127.0.0.1 6379&quot;</span> &gt;&gt; redis6380.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;replicaof 127.0.0.1 6379&quot;</span> &gt;&gt; redis6381.conf</span><br><span class=\"line\"><span class=\"comment\"># run 1 master and 2 slave</span></span><br><span class=\"line\">nohup redis-server redis.conf &amp;</span><br><span class=\"line\">nohup redis-server redis6380.conf &amp;</span><br><span class=\"line\">nohup redis-server redis6381.conf &amp;</span><br><span class=\"line\"><span class=\"comment\"># config 2 sentinel</span></span><br><span class=\"line\">cp sentinel.conf sentinel6380.conf</span><br><span class=\"line\">cp sentinel.conf sentinel6381.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 26379#<span class=\"variable\">$port</span> 26380#g&quot;</span>  sentinel6380.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 26379#<span class=\"variable\">$port</span> 26381#g&quot;</span>  sentinel6381.conf</span><br><span class=\"line\"><span class=\"comment\"># run 3 sentinel</span></span><br><span class=\"line\">nohup redis-sentinel  sentinel.conf &amp;</span><br><span class=\"line\">nohup redis-sentinel  sentinel6380.conf &amp;</span><br><span class=\"line\">nohup redis-sentinel  sentinel6381.conf &amp;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看集群状态：\"><a href=\"#查看集群状态：\" class=\"headerlink\" title=\"查看集群状态：\"></a>查看集群状态：</h2><ul>\n<li>主节点<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -h localhost -p 6379</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6381,state=online,offset=17714,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6380,state=online,offset=17714,lag=1</span><br></pre></td></tr></table></figure></li>\n<li>从结点<br>如果是连接到从节点，那么角色就是slave，并且只读不可写  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:6380&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:slave</span><br><span class=\"line\">master_host:127.0.0.1</span><br><span class=\"line\">master_port:6379</span><br><span class=\"line\">master_link_status:up</span><br><span class=\"line\">...</span><br><span class=\"line\">localhost:6380&gt; get <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">localhost:6380&gt; <span class=\"built_in\">set</span> <span class=\"string\">&#x27;a&#x27;</span> 2</span><br><span class=\"line\">(error) READONLY You can<span class=\"string\">&#x27;t write against a read only replica.</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"故障切换\"><a href=\"#故障切换\" class=\"headerlink\" title=\"故障切换\"></a>故障切换</h1><h2 id=\"主节点挂掉\"><a href=\"#主节点挂掉\" class=\"headerlink\" title=\"主节点挂掉\"></a>主节点挂掉</h2><p>现在测试下哨兵的故障切换，连上6379，并执行shutdown  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; shutdown</span><br><span class=\"line\">not connected&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在从节点看下集群信息，发现主已经切换到6381了：  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:6380&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:slave</span><br><span class=\"line\">master_host:127.0.0.1</span><br><span class=\"line\">master_port:6381</span><br><span class=\"line\">master_link_status:up</span><br></pre></td></tr></table></figure>\n<p>它其实是动态地修改了配置信息的。可以重新查看下redis节点的配置文件和哨兵的sentinel.conf配置文件中的，已经将主节点改为了6381  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 节点配置文件</span></span><br><span class=\"line\">replicaof 127.0.0.1 6381</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 哨兵配置文件</span></span><br><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6381 2</span><br></pre></td></tr></table></figure>\n\n<p>此时故障切换测试完成。 也可以再连上6381验证读写和info信息。  </p>\n<p>此时，如果主再挂掉，剩下的一个将处于只读不可写状态，因为配置文件中配置了quorum 参数（故障转移需要投票同意的节点数）为2</p>\n<h2 id=\"自动发现\"><a href=\"#自动发现\" class=\"headerlink\" title=\"自动发现\"></a>自动发现</h2><p>另外， 我想测试下哨兵模式 的服务自动发现。 此处按照上面的脚本，同样准备一段执行代码  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">cp redis.conf redis6382.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 6379#<span class=\"variable\">$port</span> 6382#g&quot;</span>  redis6382.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;replicaof 127.0.0.1 6381&quot;</span> &gt;&gt; redis6382.conf</span><br><span class=\"line\">nohup redis-server redis6382.conf &amp;</span><br><span class=\"line\">cp sentinel.conf sentinel6382.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 26379#<span class=\"variable\">$port</span> 26382#g&quot;</span>  sentinel6382.conf</span><br><span class=\"line\">nohup redis-sentinel  sentinel6382.conf &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意： 这里sentinel.conf自动对齐了主节点，<br><code>sentinel monitor mymaster 127.0.0.1 6381 2</code><br>但是redis.conf中的端口还是6379，所以脚本略有变更  </p>\n</blockquote>\n<p>然后，在主节点6381下查看集群信息。可以看到6382确实是自动加入进来了。  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6381&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6380,state=online,offset=610579,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6382,state=online,offset=610579,lag=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动恢复\"><a href=\"#自动恢复\" class=\"headerlink\" title=\"自动恢复\"></a>自动恢复</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新启动6379结点，预期中它应该重新连上集群，并成为Redis从节点</span></span><br><span class=\"line\">nohup redis-server redis.conf &amp;</span><br></pre></td></tr></table></figure>\n<p>然后在主节点查看集群信息  </p>\n<pre><code class=\"sh\">127.0.0.1:6381&gt; info replication\n# Replication\nrole:master\nconnected_slaves:3\nslave0:ip=127.0.0.1,port=6380,state=online,offset=722511,lag=1\nslave1:ip=127.0.0.1,port=6382,state=online,offset=722511,lag=1\nslave2:ip=127.0.0.1,port=6379,state=online,offset=722644,lag=1\n</code></pre>\n<blockquote>\n<p>如果想更仔细观察，建议配置日志 。默认<code>logfile</code>为空，意思是输出丢弃</p>\n</blockquote>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>redis哨兵模式实现了redis基本的高可用</p>","more":"<h1 id=\"理解哨兵集群结构\"><a href=\"#理解哨兵集群结构\" class=\"headerlink\" title=\"理解哨兵集群结构\"></a>理解哨兵集群结构</h1><p><a href=\"https://redis.io/docs/management/sentinel/\">理解sentinel集群</a><br>一个典型的哨兵集群：1主(M)2从(R)  3哨兵(S)​​  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      +----+</span><br><span class=\"line\">       | M1 |</span><br><span class=\"line\">       | S1 |</span><br><span class=\"line\">       +----+</span><br><span class=\"line\">          |</span><br><span class=\"line\">+----+    |    +----+</span><br><span class=\"line\">| R2 |----+----| R3 |</span><br><span class=\"line\">| S2 |         | S3 |</span><br><span class=\"line\">+----+         +----+</span><br><span class=\"line\"></span><br><span class=\"line\">Configuration: quorum = 2</span><br></pre></td></tr></table></figure>\n<p>故障转移检测配置：  </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 至少 1 个副本同步写不成功</span></span><br><span class=\"line\">min-replicas-to-write 1</span><br><span class=\"line\"><span class=\"comment\"># 超过max-lag秒数的时间内没有向主发送异步确认</span></span><br><span class=\"line\">min-replicas-max-lag 10</span><br></pre></td></tr></table></figure>\n<p>如果主 M1 发生故障，S2 和 S3 将就故障达成一致，并能够授权故障转移，使客户端能够继续。  </p>\n<h1 id=\"Redis及Sentinel配置\"><a href=\"#Redis及Sentinel配置\" class=\"headerlink\" title=\"Redis及Sentinel配置\"></a>Redis及Sentinel配置</h1><h2 id=\"Redis从节点配置\"><a href=\"#Redis从节点配置\" class=\"headerlink\" title=\"Redis从节点配置\"></a>Redis从节点配置</h2><p>redis主节点配置不需要变更，从节点只需要声明是主节点的备份<br><code>replicaof 127.0.0.1 6379</code><br>在5.0或更早的版本中的命令是<br><code>slaveof 127.0.0.1 6379</code>  </p>\n<blockquote>\n<p>注意每个redis节点占用不同端口  </p>\n</blockquote>\n<h2 id=\"Sentinel配置\"><a href=\"#Sentinel配置\" class=\"headerlink\" title=\"Sentinel配置\"></a>Sentinel配置</h2><p>sentinel的配置文件为 sentinel.conf,以下列出其中的关键配置：    </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 哨兵通信端口</span></span><br><span class=\"line\">port 26379</span><br><span class=\"line\"><span class=\"comment\"># 监控主节点名称/端口 以及多少个节点同意方可故障转移</span></span><br><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2  </span><br><span class=\"line\"><span class=\"comment\"># Sentinel认为它已关闭时，实例不应访问的时间</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 60000  </span><br><span class=\"line\"><span class=\"comment\"># 多长时间内不再对同一节点重试故障转移</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 180000  </span><br><span class=\"line\"><span class=\"comment\"># 故障转移后，可以重新配置为同时使用新主服务器的副本数量</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：多个</p>\n</blockquote>\n<p>启动哨兵:<br><code>redis-sentinel /path/to/sentinel.conf</code>   或<br><code>redis-server /path/to/sentinel.conf --sentinel</code></p>\n<h1 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h1><p>基于以上Redis及哨兵配置启动的知识，编辑启动Redis哨兵集群脚本：  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># config 2 slave</span></span><br><span class=\"line\">cp redis.conf redis6380.conf</span><br><span class=\"line\">cp redis.conf redis6381.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 6379#<span class=\"variable\">$port</span> 6380#g&quot;</span>  redis6380.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 6379#<span class=\"variable\">$port</span> 6381#g&quot;</span>  redis6381.conf</span><br><span class=\"line\"><span class=\"comment\"># 在5以下，旧的版本中为 slaveof </span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;replicaof 127.0.0.1 6379&quot;</span> &gt;&gt; redis6380.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;replicaof 127.0.0.1 6379&quot;</span> &gt;&gt; redis6381.conf</span><br><span class=\"line\"><span class=\"comment\"># run 1 master and 2 slave</span></span><br><span class=\"line\">nohup redis-server redis.conf &amp;</span><br><span class=\"line\">nohup redis-server redis6380.conf &amp;</span><br><span class=\"line\">nohup redis-server redis6381.conf &amp;</span><br><span class=\"line\"><span class=\"comment\"># config 2 sentinel</span></span><br><span class=\"line\">cp sentinel.conf sentinel6380.conf</span><br><span class=\"line\">cp sentinel.conf sentinel6381.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 26379#<span class=\"variable\">$port</span> 26380#g&quot;</span>  sentinel6380.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 26379#<span class=\"variable\">$port</span> 26381#g&quot;</span>  sentinel6381.conf</span><br><span class=\"line\"><span class=\"comment\"># run 3 sentinel</span></span><br><span class=\"line\">nohup redis-sentinel  sentinel.conf &amp;</span><br><span class=\"line\">nohup redis-sentinel  sentinel6380.conf &amp;</span><br><span class=\"line\">nohup redis-sentinel  sentinel6381.conf &amp;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看集群状态：\"><a href=\"#查看集群状态：\" class=\"headerlink\" title=\"查看集群状态：\"></a>查看集群状态：</h2><ul>\n<li>主节点<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -h localhost -p 6379</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6381,state=online,offset=17714,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6380,state=online,offset=17714,lag=1</span><br></pre></td></tr></table></figure></li>\n<li>从结点<br>如果是连接到从节点，那么角色就是slave，并且只读不可写  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:6380&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:slave</span><br><span class=\"line\">master_host:127.0.0.1</span><br><span class=\"line\">master_port:6379</span><br><span class=\"line\">master_link_status:up</span><br><span class=\"line\">...</span><br><span class=\"line\">localhost:6380&gt; get <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">localhost:6380&gt; <span class=\"built_in\">set</span> <span class=\"string\">&#x27;a&#x27;</span> 2</span><br><span class=\"line\">(error) READONLY You can<span class=\"string\">&#x27;t write against a read only replica.</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"故障切换\"><a href=\"#故障切换\" class=\"headerlink\" title=\"故障切换\"></a>故障切换</h1><h2 id=\"主节点挂掉\"><a href=\"#主节点挂掉\" class=\"headerlink\" title=\"主节点挂掉\"></a>主节点挂掉</h2><p>现在测试下哨兵的故障切换，连上6379，并执行shutdown  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; shutdown</span><br><span class=\"line\">not connected&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在从节点看下集群信息，发现主已经切换到6381了：  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:6380&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:slave</span><br><span class=\"line\">master_host:127.0.0.1</span><br><span class=\"line\">master_port:6381</span><br><span class=\"line\">master_link_status:up</span><br></pre></td></tr></table></figure>\n<p>它其实是动态地修改了配置信息的。可以重新查看下redis节点的配置文件和哨兵的sentinel.conf配置文件中的，已经将主节点改为了6381  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 节点配置文件</span></span><br><span class=\"line\">replicaof 127.0.0.1 6381</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 哨兵配置文件</span></span><br><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6381 2</span><br></pre></td></tr></table></figure>\n\n<p>此时故障切换测试完成。 也可以再连上6381验证读写和info信息。  </p>\n<p>此时，如果主再挂掉，剩下的一个将处于只读不可写状态，因为配置文件中配置了quorum 参数（故障转移需要投票同意的节点数）为2</p>\n<h2 id=\"自动发现\"><a href=\"#自动发现\" class=\"headerlink\" title=\"自动发现\"></a>自动发现</h2><p>另外， 我想测试下哨兵模式 的服务自动发现。 此处按照上面的脚本，同样准备一段执行代码  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">cp redis.conf redis6382.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 6379#<span class=\"variable\">$port</span> 6382#g&quot;</span>  redis6382.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;replicaof 127.0.0.1 6381&quot;</span> &gt;&gt; redis6382.conf</span><br><span class=\"line\">nohup redis-server redis6382.conf &amp;</span><br><span class=\"line\">cp sentinel.conf sentinel6382.conf</span><br><span class=\"line\">sed -i <span class=\"string\">&quot;s#<span class=\"variable\">$port</span> 26379#<span class=\"variable\">$port</span> 26382#g&quot;</span>  sentinel6382.conf</span><br><span class=\"line\">nohup redis-sentinel  sentinel6382.conf &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意： 这里sentinel.conf自动对齐了主节点，<br><code>sentinel monitor mymaster 127.0.0.1 6381 2</code><br>但是redis.conf中的端口还是6379，所以脚本略有变更  </p>\n</blockquote>\n<p>然后，在主节点6381下查看集群信息。可以看到6382确实是自动加入进来了。  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6381&gt; info replication</span><br><span class=\"line\"><span class=\"comment\"># Replication</span></span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6380,state=online,offset=610579,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6382,state=online,offset=610579,lag=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动恢复\"><a href=\"#自动恢复\" class=\"headerlink\" title=\"自动恢复\"></a>自动恢复</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新启动6379结点，预期中它应该重新连上集群，并成为Redis从节点</span></span><br><span class=\"line\">nohup redis-server redis.conf &amp;</span><br></pre></td></tr></table></figure>\n<p>然后在主节点查看集群信息  </p>\n<pre><code class=\"sh\">127.0.0.1:6381&gt; info replication\n# Replication\nrole:master\nconnected_slaves:3\nslave0:ip=127.0.0.1,port=6380,state=online,offset=722511,lag=1\nslave1:ip=127.0.0.1,port=6382,state=online,offset=722511,lag=1\nslave2:ip=127.0.0.1,port=6379,state=online,offset=722644,lag=1\n</code></pre>\n<blockquote>\n<p>如果想更仔细观察，建议配置日志 。默认<code>logfile</code>为空，意思是输出丢弃</p>\n</blockquote>\n<p>‍</p>"},{"title":"skywalking与分布式链路追踪","date":"2023-09-26T03:03:39.000Z","_content":"Skywalking是一款由国人主导开发的分布式链路追踪系统，它支持多种语言的探针，对国产开源软件有全面的支持，使用ES作为底层存储，具有强大的检索能力，而且有非常活跃的中文社区。¹³⁴\n<!--more-->\n\n# 一 分布式链路追踪系统异同\n\n其他的分布式链路追踪系统有很多，比如谷歌的Dapper，韩国的Pinpoint，Twitter的Zipkin，以及Jaeger等。²³ 它们各有各的优缺点，比如：\n\n- Dapper是链路追踪领域的始祖，它提出了基于采样的跟踪方法，以及跨进程传递Trace ID和Span ID的机制。² 但是Dapper并没有开源，只是公开了它的设计思想和架构。²\n- Pinpoint是一款功能强大的APM软件，它支持Java和PHP语言，使用HBase作为存储，具有海量存储能力，而且跟踪数据粒度非常细，用户界面也很友好。² 但是Pinpoint在社区交流上会有一定滞后，而且需要运维住一套HBase集群。²\n- Zipkin是一款基于Dapper论文实现的开源链路追踪系统，它支持多种语言和存储方式，而且有很多社区贡献的插件和扩展。² 但是Zipkin对代码有一定的侵入性，而且用户界面比较简陋。²\n- Jaeger是一款由Uber开源的链路追踪系统，它也是基于Dapper论文实现的，但是加入了一些新的特性，比如自适应采样和OpenTracing支持。² Jaeger使用Cassandra或ES作为存储，具有良好的可扩展性和查询能力，而且用户界面也比较美观。²\n\n总之，skywalking与其他分布式链路追踪系统的异同主要体现在以下几个方面：\n\n- 代码侵入性：skywalking和Pinpoint都是基于字节码注入技术实现的代码无侵入性，而Zipkin则需要在代码中添加注解或拦截器等。²\n- 存储方式：skywalking使用ES作为存储，具有强大的检索能力，而Pinpoint使用HBase作为存储，具有海量存储能力。Zipkin和Jaeger则支持多种存储方式。²\n- 用户界面：Pinpoint和Jaeger都有功能强大和美观的用户界面，而skywalking和Zipkin则相对简单。不过skywalking有一款第三方定制UI，做得比Pinpoint更漂亮。²\n- 社区活跃度：skywalking在国内社区非常活跃，可以与项目发起人零距离沟通，而Pinpoint在社区交流上会有一定滞后。Zipkin和Jaeger则在国外社区比较活跃。²\n- 支持语言：skywalking支持5种语言：Java, C#, PHP, Node.js, Go。Pinpoint只支持Java和PHP。Zipkin和Jaeger则支持多种语言。²³\n- 跟踪粒度：Pinpoint在跟踪粒度方面做得非常好，可以显示每个方法的调用时间和参数等信息。而skywalking则只显示服务之间的调用关系和时间等信息。²\n\n> 参考:  \n(1) 全网最详细的Skywalking分布式链路追踪 - 掘金. https://juejin.cn/post/7072709231949905957.  \n(2) SkyWalking最全详解(作用原理及使用流程) – mikechen. https://mikechen.cc/21974.html.  \n(3) 几款符合 OpenTracing 规范的分布式链路追踪组件介绍与 .... https://cloud.tencent.com/developer/article/1781084.  \n(4) 全链路追踪技术选型：pinpoint vs skywalking - 知乎. https://zhuanlan.zhihu.com/p/436018582.\n\n# 二 docker安装\n## 2.1 安装依赖\n``` sh\nsudo apt update\nsudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n```\n\n## 2.2 导入仓库源\n``` sh\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n## 2.3 安装最新版本\n``` sh\nsudo apt update\nsudo apt install docker-ce docker-ce-cli containerd.io\n```\n\n> 参考: https://zhuanlan.zhihu.com/p/143156163\n\n\n# 三 skywalking安装\nskywalking中数据存储有两种方式， ES和默认的H2，由于ES同时有强大的分析能力，因此各类都会建议你使用ES的安装方式。  \n例如：https://juejin.cn/post/7058129741554909197 ， 然而，实际上我使用docker安装ES，安装后总是会莫名崩溃；使用docker查看log日志，也是看不个所以然，甚至跟踪到skywalking本身的bug。其实，对于入门者体验为先。下面是H2存储的安装方式：  \n\n\n## 3.1 拉取镜像\n``` sh\ndocker pull apache/skywalking-oap-server:9.2.0\ndocker pull apache/skywalking-ui:9.2.0\n```\n\n## 3.2 安装skywalking-oap\n``` sh\ndocker run --name skywalking-oap -e TZ=Asia/Shanghai -p 12800:12800 -p 11800:11800 --restart always -d apache/skywalking-oap-server:9.2.0\n```\n\n## 3.3 安装skywalking-ui\n```\ndocker run -d --name skywalking-ui \\\n --restart=always \\\n -e TZ=Asia/Shanghai \\\n -p 8088:8080 \\\n --link skywalking-oap:oap \\\n -e SW_OAP_ADDRESS=http://oap:12800 \\\n apache/skywalking-ui:9.2.0\n```\n> 由于skywalking-ui默认的8080端口很容易跟很多web服务冲突，此处docker映射到外面的8088端口  \n访问 http://{安装服务器的ip}:8088 可以看到skywalking的监控界面就安装成功了!  \n\n# 四 应用接入\nspring项目的接入方式一般都是修改java应用的启动参数，附加agent。  \n## 4.1 agent下载\n找到两个cdn地址，都可以。src为源码，sha为校验文件，下载另外一种压缩包：\nhttps://archive.apache.org/dist/skywalking/java-agent/9.0.0/  \nhttps://dlcdn.apache.org/skywalking/java-agent/9.0.0/\n\n## 4.2 应用接入\n需要添加agent地址 / 应用名称 / skywalking-oap的连接地址  \n参数示例：  \n``` ini\n-javaagent:D:\\\\soft\\\\skywalking-agent\\\\skywalking-agent.jar\n-Dskywalking.agent.service_name=shorturl\n-Dskywalking.collector.backend_service=172.16.90.164:11800\n```\n> 如果是放到tomcat中启动，修改tomcat下的`bin/catalida.sh`，将JAVA_OPS变量附加以上参数即可。效果如下：    \n![](/images/skywalking1.png)\n![](/images/skywalking2.png)\n上面可以看到每次请求的耗时，点进去则是trace每次。可以看到，当前agent可识别http/rpc请求，sql执行，druid拦截器等。\n\n# 五 skywalking自定义扩展\n\n## 5.1 自定义方法Trace\n在实际业务监控中，不仅是各类组合外部调用会被Trace到一次Api中，有时候一些复杂方法也会希望被集成为一个Span放进去。这时通过插件`apm-toolkit-trace`可以完成。  \n\n1. 需要接入的应用中新增依赖  \n``` xml\n   <dependency>\n      <groupId>org.apache.skywalking</groupId>\n      <artifactId>apm-toolkit-trace</artifactId>\n      // 版本尽量和skywalking版本一致\n      <version>${skywalking.version}</version>\n   </dependency>\n```\n\n2. 在方法上加注解  \n``` java\n    @Trace\n    @Tags({@Tag(key = \"originalURL\", value = \"arg[0]\"),\n            @Tag(key = \"tenantId\", value = \"arg[2]\")})\n    public String generateUrlMap(String originalURL, String expireDate, String tenantId, String status, String note) {\n        ...\n    }\n```\n被`@Trace`修饰的方法会形成一个span放到外层接口Trace中。  \n![](/images/skywalking3.png)  \n- 可以看到新增修饰的方法已经被标记到接口请求的trace中\n\n> 非代码侵入的trace方式参考： https://blog.csdn.net/zxh1991811/article/details/115379470  \n\n\n## 5.2 输出Span日志到skywalking\n\n- skywalking的自定义Trace可以帮助我们融入业务指标，定位到业务异常。但是，如果还需要反过来去日志服务中寻找相关异常，岂不是很浪费时间。这一节就是要解决这个痛点!  \nhttps://blog.csdn.net/wb4927598/article/details/119192594\n\n\n\n\n\n\n\n\n","source":"_posts/skywalking与分布式链路追踪.md","raw":"---\ntitle: skywalking与分布式链路追踪\ndate: 2023-09-26 11:03:39\ntags: skywalking\ncategories: 中间件\n---\nSkywalking是一款由国人主导开发的分布式链路追踪系统，它支持多种语言的探针，对国产开源软件有全面的支持，使用ES作为底层存储，具有强大的检索能力，而且有非常活跃的中文社区。¹³⁴\n<!--more-->\n\n# 一 分布式链路追踪系统异同\n\n其他的分布式链路追踪系统有很多，比如谷歌的Dapper，韩国的Pinpoint，Twitter的Zipkin，以及Jaeger等。²³ 它们各有各的优缺点，比如：\n\n- Dapper是链路追踪领域的始祖，它提出了基于采样的跟踪方法，以及跨进程传递Trace ID和Span ID的机制。² 但是Dapper并没有开源，只是公开了它的设计思想和架构。²\n- Pinpoint是一款功能强大的APM软件，它支持Java和PHP语言，使用HBase作为存储，具有海量存储能力，而且跟踪数据粒度非常细，用户界面也很友好。² 但是Pinpoint在社区交流上会有一定滞后，而且需要运维住一套HBase集群。²\n- Zipkin是一款基于Dapper论文实现的开源链路追踪系统，它支持多种语言和存储方式，而且有很多社区贡献的插件和扩展。² 但是Zipkin对代码有一定的侵入性，而且用户界面比较简陋。²\n- Jaeger是一款由Uber开源的链路追踪系统，它也是基于Dapper论文实现的，但是加入了一些新的特性，比如自适应采样和OpenTracing支持。² Jaeger使用Cassandra或ES作为存储，具有良好的可扩展性和查询能力，而且用户界面也比较美观。²\n\n总之，skywalking与其他分布式链路追踪系统的异同主要体现在以下几个方面：\n\n- 代码侵入性：skywalking和Pinpoint都是基于字节码注入技术实现的代码无侵入性，而Zipkin则需要在代码中添加注解或拦截器等。²\n- 存储方式：skywalking使用ES作为存储，具有强大的检索能力，而Pinpoint使用HBase作为存储，具有海量存储能力。Zipkin和Jaeger则支持多种存储方式。²\n- 用户界面：Pinpoint和Jaeger都有功能强大和美观的用户界面，而skywalking和Zipkin则相对简单。不过skywalking有一款第三方定制UI，做得比Pinpoint更漂亮。²\n- 社区活跃度：skywalking在国内社区非常活跃，可以与项目发起人零距离沟通，而Pinpoint在社区交流上会有一定滞后。Zipkin和Jaeger则在国外社区比较活跃。²\n- 支持语言：skywalking支持5种语言：Java, C#, PHP, Node.js, Go。Pinpoint只支持Java和PHP。Zipkin和Jaeger则支持多种语言。²³\n- 跟踪粒度：Pinpoint在跟踪粒度方面做得非常好，可以显示每个方法的调用时间和参数等信息。而skywalking则只显示服务之间的调用关系和时间等信息。²\n\n> 参考:  \n(1) 全网最详细的Skywalking分布式链路追踪 - 掘金. https://juejin.cn/post/7072709231949905957.  \n(2) SkyWalking最全详解(作用原理及使用流程) – mikechen. https://mikechen.cc/21974.html.  \n(3) 几款符合 OpenTracing 规范的分布式链路追踪组件介绍与 .... https://cloud.tencent.com/developer/article/1781084.  \n(4) 全链路追踪技术选型：pinpoint vs skywalking - 知乎. https://zhuanlan.zhihu.com/p/436018582.\n\n# 二 docker安装\n## 2.1 安装依赖\n``` sh\nsudo apt update\nsudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n```\n\n## 2.2 导入仓库源\n``` sh\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n## 2.3 安装最新版本\n``` sh\nsudo apt update\nsudo apt install docker-ce docker-ce-cli containerd.io\n```\n\n> 参考: https://zhuanlan.zhihu.com/p/143156163\n\n\n# 三 skywalking安装\nskywalking中数据存储有两种方式， ES和默认的H2，由于ES同时有强大的分析能力，因此各类都会建议你使用ES的安装方式。  \n例如：https://juejin.cn/post/7058129741554909197 ， 然而，实际上我使用docker安装ES，安装后总是会莫名崩溃；使用docker查看log日志，也是看不个所以然，甚至跟踪到skywalking本身的bug。其实，对于入门者体验为先。下面是H2存储的安装方式：  \n\n\n## 3.1 拉取镜像\n``` sh\ndocker pull apache/skywalking-oap-server:9.2.0\ndocker pull apache/skywalking-ui:9.2.0\n```\n\n## 3.2 安装skywalking-oap\n``` sh\ndocker run --name skywalking-oap -e TZ=Asia/Shanghai -p 12800:12800 -p 11800:11800 --restart always -d apache/skywalking-oap-server:9.2.0\n```\n\n## 3.3 安装skywalking-ui\n```\ndocker run -d --name skywalking-ui \\\n --restart=always \\\n -e TZ=Asia/Shanghai \\\n -p 8088:8080 \\\n --link skywalking-oap:oap \\\n -e SW_OAP_ADDRESS=http://oap:12800 \\\n apache/skywalking-ui:9.2.0\n```\n> 由于skywalking-ui默认的8080端口很容易跟很多web服务冲突，此处docker映射到外面的8088端口  \n访问 http://{安装服务器的ip}:8088 可以看到skywalking的监控界面就安装成功了!  \n\n# 四 应用接入\nspring项目的接入方式一般都是修改java应用的启动参数，附加agent。  \n## 4.1 agent下载\n找到两个cdn地址，都可以。src为源码，sha为校验文件，下载另外一种压缩包：\nhttps://archive.apache.org/dist/skywalking/java-agent/9.0.0/  \nhttps://dlcdn.apache.org/skywalking/java-agent/9.0.0/\n\n## 4.2 应用接入\n需要添加agent地址 / 应用名称 / skywalking-oap的连接地址  \n参数示例：  \n``` ini\n-javaagent:D:\\\\soft\\\\skywalking-agent\\\\skywalking-agent.jar\n-Dskywalking.agent.service_name=shorturl\n-Dskywalking.collector.backend_service=172.16.90.164:11800\n```\n> 如果是放到tomcat中启动，修改tomcat下的`bin/catalida.sh`，将JAVA_OPS变量附加以上参数即可。效果如下：    \n![](/images/skywalking1.png)\n![](/images/skywalking2.png)\n上面可以看到每次请求的耗时，点进去则是trace每次。可以看到，当前agent可识别http/rpc请求，sql执行，druid拦截器等。\n\n# 五 skywalking自定义扩展\n\n## 5.1 自定义方法Trace\n在实际业务监控中，不仅是各类组合外部调用会被Trace到一次Api中，有时候一些复杂方法也会希望被集成为一个Span放进去。这时通过插件`apm-toolkit-trace`可以完成。  \n\n1. 需要接入的应用中新增依赖  \n``` xml\n   <dependency>\n      <groupId>org.apache.skywalking</groupId>\n      <artifactId>apm-toolkit-trace</artifactId>\n      // 版本尽量和skywalking版本一致\n      <version>${skywalking.version}</version>\n   </dependency>\n```\n\n2. 在方法上加注解  \n``` java\n    @Trace\n    @Tags({@Tag(key = \"originalURL\", value = \"arg[0]\"),\n            @Tag(key = \"tenantId\", value = \"arg[2]\")})\n    public String generateUrlMap(String originalURL, String expireDate, String tenantId, String status, String note) {\n        ...\n    }\n```\n被`@Trace`修饰的方法会形成一个span放到外层接口Trace中。  \n![](/images/skywalking3.png)  \n- 可以看到新增修饰的方法已经被标记到接口请求的trace中\n\n> 非代码侵入的trace方式参考： https://blog.csdn.net/zxh1991811/article/details/115379470  \n\n\n## 5.2 输出Span日志到skywalking\n\n- skywalking的自定义Trace可以帮助我们融入业务指标，定位到业务异常。但是，如果还需要反过来去日志服务中寻找相关异常，岂不是很浪费时间。这一节就是要解决这个痛点!  \nhttps://blog.csdn.net/wb4927598/article/details/119192594\n\n\n\n\n\n\n\n\n","slug":"skywalking与分布式链路追踪","published":1,"updated":"2024-02-18T08:29:31.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6ozi004dqwvd85bm0isj","content":"<p>Skywalking是一款由国人主导开发的分布式链路追踪系统，它支持多种语言的探针，对国产开源软件有全面的支持，使用ES作为底层存储，具有强大的检索能力，而且有非常活跃的中文社区。¹³⁴</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一-分布式链路追踪系统异同\"><a href=\"#一-分布式链路追踪系统异同\" class=\"headerlink\" title=\"一 分布式链路追踪系统异同\"></a>一 分布式链路追踪系统异同</h1><p>其他的分布式链路追踪系统有很多，比如谷歌的Dapper，韩国的Pinpoint，Twitter的Zipkin，以及Jaeger等。²³ 它们各有各的优缺点，比如：</p>\n<ul>\n<li>Dapper是链路追踪领域的始祖，它提出了基于采样的跟踪方法，以及跨进程传递Trace ID和Span ID的机制。² 但是Dapper并没有开源，只是公开了它的设计思想和架构。²</li>\n<li>Pinpoint是一款功能强大的APM软件，它支持Java和PHP语言，使用HBase作为存储，具有海量存储能力，而且跟踪数据粒度非常细，用户界面也很友好。² 但是Pinpoint在社区交流上会有一定滞后，而且需要运维住一套HBase集群。²</li>\n<li>Zipkin是一款基于Dapper论文实现的开源链路追踪系统，它支持多种语言和存储方式，而且有很多社区贡献的插件和扩展。² 但是Zipkin对代码有一定的侵入性，而且用户界面比较简陋。²</li>\n<li>Jaeger是一款由Uber开源的链路追踪系统，它也是基于Dapper论文实现的，但是加入了一些新的特性，比如自适应采样和OpenTracing支持。² Jaeger使用Cassandra或ES作为存储，具有良好的可扩展性和查询能力，而且用户界面也比较美观。²</li>\n</ul>\n<p>总之，skywalking与其他分布式链路追踪系统的异同主要体现在以下几个方面：</p>\n<ul>\n<li>代码侵入性：skywalking和Pinpoint都是基于字节码注入技术实现的代码无侵入性，而Zipkin则需要在代码中添加注解或拦截器等。²</li>\n<li>存储方式：skywalking使用ES作为存储，具有强大的检索能力，而Pinpoint使用HBase作为存储，具有海量存储能力。Zipkin和Jaeger则支持多种存储方式。²</li>\n<li>用户界面：Pinpoint和Jaeger都有功能强大和美观的用户界面，而skywalking和Zipkin则相对简单。不过skywalking有一款第三方定制UI，做得比Pinpoint更漂亮。²</li>\n<li>社区活跃度：skywalking在国内社区非常活跃，可以与项目发起人零距离沟通，而Pinpoint在社区交流上会有一定滞后。Zipkin和Jaeger则在国外社区比较活跃。²</li>\n<li>支持语言：skywalking支持5种语言：Java, C#, PHP, Node.js, Go。Pinpoint只支持Java和PHP。Zipkin和Jaeger则支持多种语言。²³</li>\n<li>跟踪粒度：Pinpoint在跟踪粒度方面做得非常好，可以显示每个方法的调用时间和参数等信息。而skywalking则只显示服务之间的调用关系和时间等信息。²</li>\n</ul>\n<blockquote>\n<p>参考:<br>(1) 全网最详细的Skywalking分布式链路追踪 - 掘金. <a href=\"https://juejin.cn/post/7072709231949905957\">https://juejin.cn/post/7072709231949905957</a>.<br>(2) SkyWalking最全详解(作用原理及使用流程) – mikechen. <a href=\"https://mikechen.cc/21974.html\">https://mikechen.cc/21974.html</a>.<br>(3) 几款符合 OpenTracing 规范的分布式链路追踪组件介绍与 …. <a href=\"https://cloud.tencent.com/developer/article/1781084\">https://cloud.tencent.com/developer/article/1781084</a>.<br>(4) 全链路追踪技术选型：pinpoint vs skywalking - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/436018582\">https://zhuanlan.zhihu.com/p/436018582</a>.</p>\n</blockquote>\n<h1 id=\"二-docker安装\"><a href=\"#二-docker安装\" class=\"headerlink\" title=\"二 docker安装\"></a>二 docker安装</h1><h2 id=\"2-1-安装依赖\"><a href=\"#2-1-安装依赖\" class=\"headerlink\" title=\"2.1 安装依赖\"></a>2.1 安装依赖</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-导入仓库源\"><a href=\"#2-2-导入仓库源\" class=\"headerlink\" title=\"2.2 导入仓库源\"></a>2.2 导入仓库源</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class=\"line\">sudo add-apt-repository <span class=\"string\">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class=\"subst\">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-安装最新版本\"><a href=\"#2-3-安装最新版本\" class=\"headerlink\" title=\"2.3 安装最新版本\"></a>2.3 安装最新版本</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考: <a href=\"https://zhuanlan.zhihu.com/p/143156163\">https://zhuanlan.zhihu.com/p/143156163</a></p>\n</blockquote>\n<h1 id=\"三-skywalking安装\"><a href=\"#三-skywalking安装\" class=\"headerlink\" title=\"三 skywalking安装\"></a>三 skywalking安装</h1><p>skywalking中数据存储有两种方式， ES和默认的H2，由于ES同时有强大的分析能力，因此各类都会建议你使用ES的安装方式。<br>例如：<a href=\"https://juejin.cn/post/7058129741554909197\">https://juejin.cn/post/7058129741554909197</a> ， 然而，实际上我使用docker安装ES，安装后总是会莫名崩溃；使用docker查看log日志，也是看不个所以然，甚至跟踪到skywalking本身的bug。其实，对于入门者体验为先。下面是H2存储的安装方式：  </p>\n<h2 id=\"3-1-拉取镜像\"><a href=\"#3-1-拉取镜像\" class=\"headerlink\" title=\"3.1 拉取镜像\"></a>3.1 拉取镜像</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull apache/skywalking-oap-server:9.2.0</span><br><span class=\"line\">docker pull apache/skywalking-ui:9.2.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-安装skywalking-oap\"><a href=\"#3-2-安装skywalking-oap\" class=\"headerlink\" title=\"3.2 安装skywalking-oap\"></a>3.2 安装skywalking-oap</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name skywalking-oap -e TZ=Asia/Shanghai -p 12800:12800 -p 11800:11800 --restart always -d apache/skywalking-oap-server:9.2.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-安装skywalking-ui\"><a href=\"#3-3-安装skywalking-ui\" class=\"headerlink\" title=\"3.3 安装skywalking-ui\"></a>3.3 安装skywalking-ui</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name skywalking-ui \\</span><br><span class=\"line\"> --restart=always \\</span><br><span class=\"line\"> -e TZ=Asia/Shanghai \\</span><br><span class=\"line\"> -p 8088:8080 \\</span><br><span class=\"line\"> --link skywalking-oap:oap \\</span><br><span class=\"line\"> -e SW_OAP_ADDRESS=http://oap:12800 \\</span><br><span class=\"line\"> apache/skywalking-ui:9.2.0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于skywalking-ui默认的8080端口很容易跟很多web服务冲突，此处docker映射到外面的8088端口<br>访问 http:&#x2F;&#x2F;{安装服务器的ip}:8088 可以看到skywalking的监控界面就安装成功了!  </p>\n</blockquote>\n<h1 id=\"四-应用接入\"><a href=\"#四-应用接入\" class=\"headerlink\" title=\"四 应用接入\"></a>四 应用接入</h1><p>spring项目的接入方式一般都是修改java应用的启动参数，附加agent。  </p>\n<h2 id=\"4-1-agent下载\"><a href=\"#4-1-agent下载\" class=\"headerlink\" title=\"4.1 agent下载\"></a>4.1 agent下载</h2><p>找到两个cdn地址，都可以。src为源码，sha为校验文件，下载另外一种压缩包：<br><a href=\"https://archive.apache.org/dist/skywalking/java-agent/9.0.0/\">https://archive.apache.org/dist/skywalking/java-agent/9.0.0/</a><br><a href=\"https://dlcdn.apache.org/skywalking/java-agent/9.0.0/\">https://dlcdn.apache.org/skywalking/java-agent/9.0.0/</a></p>\n<h2 id=\"4-2-应用接入\"><a href=\"#4-2-应用接入\" class=\"headerlink\" title=\"4.2 应用接入\"></a>4.2 应用接入</h2><p>需要添加agent地址 &#x2F; 应用名称 &#x2F; skywalking-oap的连接地址<br>参数示例：  </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-javaagent:D:\\\\soft\\\\skywalking-agent\\\\skywalking-agent.jar</span><br><span class=\"line\"><span class=\"attr\">-Dskywalking.agent.service_name</span>=shorturl</span><br><span class=\"line\"><span class=\"attr\">-Dskywalking.collector.backend_service</span>=<span class=\"number\">172.16</span>.<span class=\"number\">90.164</span>:<span class=\"number\">11800</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果是放到tomcat中启动，修改tomcat下的<code>bin/catalida.sh</code>，将JAVA_OPS变量附加以上参数即可。效果如下：<br><img src=\"/images/skywalking1.png\"><br><img src=\"/images/skywalking2.png\"><br>上面可以看到每次请求的耗时，点进去则是trace每次。可以看到，当前agent可识别http&#x2F;rpc请求，sql执行，druid拦截器等。</p>\n</blockquote>\n<h1 id=\"五-skywalking自定义扩展\"><a href=\"#五-skywalking自定义扩展\" class=\"headerlink\" title=\"五 skywalking自定义扩展\"></a>五 skywalking自定义扩展</h1><h2 id=\"5-1-自定义方法Trace\"><a href=\"#5-1-自定义方法Trace\" class=\"headerlink\" title=\"5.1 自定义方法Trace\"></a>5.1 自定义方法Trace</h2><p>在实际业务监控中，不仅是各类组合外部调用会被Trace到一次Api中，有时候一些复杂方法也会希望被集成为一个Span放进去。这时通过插件<code>apm-toolkit-trace</code>可以完成。  </p>\n<ol>\n<li><p>需要接入的应用中新增依赖  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.skywalking<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>apm-toolkit-trace<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   // 版本尽量和skywalking版本一致</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;skywalking.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在方法上加注解  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Trace</span></span><br><span class=\"line\"><span class=\"meta\">@Tags(&#123;@Tag(key = &quot;originalURL&quot;, value = &quot;arg[0]&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">        @Tag(key = &quot;tenantId&quot;, value = &quot;arg[2]&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">generateUrlMap</span><span class=\"params\">(String originalURL, String expireDate, String tenantId, String status, String note)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被<code>@Trace</code>修饰的方法会形成一个span放到外层接口Trace中。<br><img src=\"/images/skywalking3.png\"></p>\n</li>\n</ol>\n<ul>\n<li>可以看到新增修饰的方法已经被标记到接口请求的trace中</li>\n</ul>\n<blockquote>\n<p>非代码侵入的trace方式参考： <a href=\"https://blog.csdn.net/zxh1991811/article/details/115379470\">https://blog.csdn.net/zxh1991811/article/details/115379470</a>  </p>\n</blockquote>\n<h2 id=\"5-2-输出Span日志到skywalking\"><a href=\"#5-2-输出Span日志到skywalking\" class=\"headerlink\" title=\"5.2 输出Span日志到skywalking\"></a>5.2 输出Span日志到skywalking</h2><ul>\n<li>skywalking的自定义Trace可以帮助我们融入业务指标，定位到业务异常。但是，如果还需要反过来去日志服务中寻找相关异常，岂不是很浪费时间。这一节就是要解决这个痛点!<br><a href=\"https://blog.csdn.net/wb4927598/article/details/119192594\">https://blog.csdn.net/wb4927598/article/details/119192594</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Skywalking是一款由国人主导开发的分布式链路追踪系统，它支持多种语言的探针，对国产开源软件有全面的支持，使用ES作为底层存储，具有强大的检索能力，而且有非常活跃的中文社区。¹³⁴</p>","more":"<h1 id=\"一-分布式链路追踪系统异同\"><a href=\"#一-分布式链路追踪系统异同\" class=\"headerlink\" title=\"一 分布式链路追踪系统异同\"></a>一 分布式链路追踪系统异同</h1><p>其他的分布式链路追踪系统有很多，比如谷歌的Dapper，韩国的Pinpoint，Twitter的Zipkin，以及Jaeger等。²³ 它们各有各的优缺点，比如：</p>\n<ul>\n<li>Dapper是链路追踪领域的始祖，它提出了基于采样的跟踪方法，以及跨进程传递Trace ID和Span ID的机制。² 但是Dapper并没有开源，只是公开了它的设计思想和架构。²</li>\n<li>Pinpoint是一款功能强大的APM软件，它支持Java和PHP语言，使用HBase作为存储，具有海量存储能力，而且跟踪数据粒度非常细，用户界面也很友好。² 但是Pinpoint在社区交流上会有一定滞后，而且需要运维住一套HBase集群。²</li>\n<li>Zipkin是一款基于Dapper论文实现的开源链路追踪系统，它支持多种语言和存储方式，而且有很多社区贡献的插件和扩展。² 但是Zipkin对代码有一定的侵入性，而且用户界面比较简陋。²</li>\n<li>Jaeger是一款由Uber开源的链路追踪系统，它也是基于Dapper论文实现的，但是加入了一些新的特性，比如自适应采样和OpenTracing支持。² Jaeger使用Cassandra或ES作为存储，具有良好的可扩展性和查询能力，而且用户界面也比较美观。²</li>\n</ul>\n<p>总之，skywalking与其他分布式链路追踪系统的异同主要体现在以下几个方面：</p>\n<ul>\n<li>代码侵入性：skywalking和Pinpoint都是基于字节码注入技术实现的代码无侵入性，而Zipkin则需要在代码中添加注解或拦截器等。²</li>\n<li>存储方式：skywalking使用ES作为存储，具有强大的检索能力，而Pinpoint使用HBase作为存储，具有海量存储能力。Zipkin和Jaeger则支持多种存储方式。²</li>\n<li>用户界面：Pinpoint和Jaeger都有功能强大和美观的用户界面，而skywalking和Zipkin则相对简单。不过skywalking有一款第三方定制UI，做得比Pinpoint更漂亮。²</li>\n<li>社区活跃度：skywalking在国内社区非常活跃，可以与项目发起人零距离沟通，而Pinpoint在社区交流上会有一定滞后。Zipkin和Jaeger则在国外社区比较活跃。²</li>\n<li>支持语言：skywalking支持5种语言：Java, C#, PHP, Node.js, Go。Pinpoint只支持Java和PHP。Zipkin和Jaeger则支持多种语言。²³</li>\n<li>跟踪粒度：Pinpoint在跟踪粒度方面做得非常好，可以显示每个方法的调用时间和参数等信息。而skywalking则只显示服务之间的调用关系和时间等信息。²</li>\n</ul>\n<blockquote>\n<p>参考:<br>(1) 全网最详细的Skywalking分布式链路追踪 - 掘金. <a href=\"https://juejin.cn/post/7072709231949905957\">https://juejin.cn/post/7072709231949905957</a>.<br>(2) SkyWalking最全详解(作用原理及使用流程) – mikechen. <a href=\"https://mikechen.cc/21974.html\">https://mikechen.cc/21974.html</a>.<br>(3) 几款符合 OpenTracing 规范的分布式链路追踪组件介绍与 …. <a href=\"https://cloud.tencent.com/developer/article/1781084\">https://cloud.tencent.com/developer/article/1781084</a>.<br>(4) 全链路追踪技术选型：pinpoint vs skywalking - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/436018582\">https://zhuanlan.zhihu.com/p/436018582</a>.</p>\n</blockquote>\n<h1 id=\"二-docker安装\"><a href=\"#二-docker安装\" class=\"headerlink\" title=\"二 docker安装\"></a>二 docker安装</h1><h2 id=\"2-1-安装依赖\"><a href=\"#2-1-安装依赖\" class=\"headerlink\" title=\"2.1 安装依赖\"></a>2.1 安装依赖</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-导入仓库源\"><a href=\"#2-2-导入仓库源\" class=\"headerlink\" title=\"2.2 导入仓库源\"></a>2.2 导入仓库源</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class=\"line\">sudo add-apt-repository <span class=\"string\">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class=\"subst\">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-安装最新版本\"><a href=\"#2-3-安装最新版本\" class=\"headerlink\" title=\"2.3 安装最新版本\"></a>2.3 安装最新版本</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考: <a href=\"https://zhuanlan.zhihu.com/p/143156163\">https://zhuanlan.zhihu.com/p/143156163</a></p>\n</blockquote>\n<h1 id=\"三-skywalking安装\"><a href=\"#三-skywalking安装\" class=\"headerlink\" title=\"三 skywalking安装\"></a>三 skywalking安装</h1><p>skywalking中数据存储有两种方式， ES和默认的H2，由于ES同时有强大的分析能力，因此各类都会建议你使用ES的安装方式。<br>例如：<a href=\"https://juejin.cn/post/7058129741554909197\">https://juejin.cn/post/7058129741554909197</a> ， 然而，实际上我使用docker安装ES，安装后总是会莫名崩溃；使用docker查看log日志，也是看不个所以然，甚至跟踪到skywalking本身的bug。其实，对于入门者体验为先。下面是H2存储的安装方式：  </p>\n<h2 id=\"3-1-拉取镜像\"><a href=\"#3-1-拉取镜像\" class=\"headerlink\" title=\"3.1 拉取镜像\"></a>3.1 拉取镜像</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull apache/skywalking-oap-server:9.2.0</span><br><span class=\"line\">docker pull apache/skywalking-ui:9.2.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-安装skywalking-oap\"><a href=\"#3-2-安装skywalking-oap\" class=\"headerlink\" title=\"3.2 安装skywalking-oap\"></a>3.2 安装skywalking-oap</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name skywalking-oap -e TZ=Asia/Shanghai -p 12800:12800 -p 11800:11800 --restart always -d apache/skywalking-oap-server:9.2.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-安装skywalking-ui\"><a href=\"#3-3-安装skywalking-ui\" class=\"headerlink\" title=\"3.3 安装skywalking-ui\"></a>3.3 安装skywalking-ui</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name skywalking-ui \\</span><br><span class=\"line\"> --restart=always \\</span><br><span class=\"line\"> -e TZ=Asia/Shanghai \\</span><br><span class=\"line\"> -p 8088:8080 \\</span><br><span class=\"line\"> --link skywalking-oap:oap \\</span><br><span class=\"line\"> -e SW_OAP_ADDRESS=http://oap:12800 \\</span><br><span class=\"line\"> apache/skywalking-ui:9.2.0</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于skywalking-ui默认的8080端口很容易跟很多web服务冲突，此处docker映射到外面的8088端口<br>访问 http:&#x2F;&#x2F;{安装服务器的ip}:8088 可以看到skywalking的监控界面就安装成功了!  </p>\n</blockquote>\n<h1 id=\"四-应用接入\"><a href=\"#四-应用接入\" class=\"headerlink\" title=\"四 应用接入\"></a>四 应用接入</h1><p>spring项目的接入方式一般都是修改java应用的启动参数，附加agent。  </p>\n<h2 id=\"4-1-agent下载\"><a href=\"#4-1-agent下载\" class=\"headerlink\" title=\"4.1 agent下载\"></a>4.1 agent下载</h2><p>找到两个cdn地址，都可以。src为源码，sha为校验文件，下载另外一种压缩包：<br><a href=\"https://archive.apache.org/dist/skywalking/java-agent/9.0.0/\">https://archive.apache.org/dist/skywalking/java-agent/9.0.0/</a><br><a href=\"https://dlcdn.apache.org/skywalking/java-agent/9.0.0/\">https://dlcdn.apache.org/skywalking/java-agent/9.0.0/</a></p>\n<h2 id=\"4-2-应用接入\"><a href=\"#4-2-应用接入\" class=\"headerlink\" title=\"4.2 应用接入\"></a>4.2 应用接入</h2><p>需要添加agent地址 &#x2F; 应用名称 &#x2F; skywalking-oap的连接地址<br>参数示例：  </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-javaagent:D:\\\\soft\\\\skywalking-agent\\\\skywalking-agent.jar</span><br><span class=\"line\"><span class=\"attr\">-Dskywalking.agent.service_name</span>=shorturl</span><br><span class=\"line\"><span class=\"attr\">-Dskywalking.collector.backend_service</span>=<span class=\"number\">172.16</span>.<span class=\"number\">90.164</span>:<span class=\"number\">11800</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果是放到tomcat中启动，修改tomcat下的<code>bin/catalida.sh</code>，将JAVA_OPS变量附加以上参数即可。效果如下：<br><img src=\"/images/skywalking1.png\"><br><img src=\"/images/skywalking2.png\"><br>上面可以看到每次请求的耗时，点进去则是trace每次。可以看到，当前agent可识别http&#x2F;rpc请求，sql执行，druid拦截器等。</p>\n</blockquote>\n<h1 id=\"五-skywalking自定义扩展\"><a href=\"#五-skywalking自定义扩展\" class=\"headerlink\" title=\"五 skywalking自定义扩展\"></a>五 skywalking自定义扩展</h1><h2 id=\"5-1-自定义方法Trace\"><a href=\"#5-1-自定义方法Trace\" class=\"headerlink\" title=\"5.1 自定义方法Trace\"></a>5.1 自定义方法Trace</h2><p>在实际业务监控中，不仅是各类组合外部调用会被Trace到一次Api中，有时候一些复杂方法也会希望被集成为一个Span放进去。这时通过插件<code>apm-toolkit-trace</code>可以完成。  </p>\n<ol>\n<li><p>需要接入的应用中新增依赖  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.skywalking<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>apm-toolkit-trace<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   // 版本尽量和skywalking版本一致</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;skywalking.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在方法上加注解  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Trace</span></span><br><span class=\"line\"><span class=\"meta\">@Tags(&#123;@Tag(key = &quot;originalURL&quot;, value = &quot;arg[0]&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">        @Tag(key = &quot;tenantId&quot;, value = &quot;arg[2]&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">generateUrlMap</span><span class=\"params\">(String originalURL, String expireDate, String tenantId, String status, String note)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被<code>@Trace</code>修饰的方法会形成一个span放到外层接口Trace中。<br><img src=\"/images/skywalking3.png\"></p>\n</li>\n</ol>\n<ul>\n<li>可以看到新增修饰的方法已经被标记到接口请求的trace中</li>\n</ul>\n<blockquote>\n<p>非代码侵入的trace方式参考： <a href=\"https://blog.csdn.net/zxh1991811/article/details/115379470\">https://blog.csdn.net/zxh1991811/article/details/115379470</a>  </p>\n</blockquote>\n<h2 id=\"5-2-输出Span日志到skywalking\"><a href=\"#5-2-输出Span日志到skywalking\" class=\"headerlink\" title=\"5.2 输出Span日志到skywalking\"></a>5.2 输出Span日志到skywalking</h2><ul>\n<li>skywalking的自定义Trace可以帮助我们融入业务指标，定位到业务异常。但是，如果还需要反过来去日志服务中寻找相关异常，岂不是很浪费时间。这一节就是要解决这个痛点!<br><a href=\"https://blog.csdn.net/wb4927598/article/details/119192594\">https://blog.csdn.net/wb4927598/article/details/119192594</a></li>\n</ul>"},{"title":"一次OOM分析","date":"2024-01-04T08:28:59.000Z","_content":"世界上没有无缘无故的爱，也没有无缘无故的恨。  \nOOM了，肯定是要找到元凶的！\n<!--more-->\n\n# 一、问题描述\n（tomcat的OOM信息会在catalina.log日志文件和catalina.out日志文件打印）\n​![image](/images/assets/image-20240104152220-2izpt7h.png)​\n\n\nOOM的时候记录并dump堆文件，JVM启动参数需要加上：\n```java\n  # 指定生成Dump文件的异常类型\n  -XX:+HeapDumpOnOutOfMemoryError\n\n  # 指定Dump文件生成的位置\n  -XX:HeapDumpPath=/data/log/erp.hprof\n```\n\n> 如果是运行中需要分析堆，也可以使用jmap主动生成\n>\n> jmap -dump:format=b,file=heap_dump.hprof  $PID\n\n# 二、问题思路\n生成堆文件后，需要分析工具。可以采用开源的[Mat](https://eclipse.dev/mat/previousReleases.php)\n\n> 注意：\n>\n> 1. 最新版本的1.15要求最少是JDK17, 我用的是1.10 可以在JDK8上运行\n> 2. Mat运行要求的内存空间较大，实际根据堆文件大小来调整 MemoryAnalyzer.ini 配置文件 。\n>\n>     我堆文件有25G，实际我分配了20G的最大堆才导入成功\n\n如果服务器上内存够用的话，可以直接生成相关报告：\n\n> ./ParseHeapDump.sh /data/log/erp_202312.hprof   org.eclipse.mat.api:suspects  org.eclipse.mat.api:overview   org.eclipse.mat.api:top_components\n\n‍\n# 三、问题分析\n好不容易导入堆文件后没找到重点，在参考一下别人怎么玩的之后，通两个功能（排列大对象+内存泄露分析）就找到元凶。  \n\n​![image](/images/assets/image-20240104154329-g9hnw90.png)​\n\n\n## 3.1 锁定上下文\n首先，对象名称是一个定时任务线程池的线程。在圆饼上左键看看大对象的上下文信息，可以找到这个定时任务具体执行类是哪个\n\n​![image](/images/assets/image-20240104155246-fieh1f7.png)​\n\n​![image](/images/assets/image-20240104160611-xmslynf.png)​\n\n‍\n## 3.2 大对象分析\n然后，选择大对象分析，发现两个List占用了11.5G，我最大堆分配的是15G。这里估计就是原因所在了\n\n​![image](/images/assets/image-20240104155650-95jxrin.png)​\n\n‍\n## 3.3 内存泄露分析\n使用内存泄露分析，发现大对象List是哪里出现的\n\n​![image](/images/assets/image-20240104160141-n1db8go.png)​\n\n‍\n## 3.4 结合代码验证\n反过来再参考代码和日志 ，印证了服务挂掉的就是这个位置  \n（这里看起来只取了一堆ID，实际上每个值都是一个LinkedHashMap，数据中大概每个List都是2000w）：\n​![image](/images/assets/image-20240104155916-dw9zsud.png)​\n\n\n# 四、问题解决\n原代码的JdbcService其实还是使用Jdbctemplate的RowMapper进行行数据提取，生成了大量的中间Map。  \n可以使用`query(String sql, RowCallbackHandler rch)`, 也可以自定义ResultSetExtractor，主动提取id，省掉中间Map\n\n参考：\n> [Dump文件分析工具 - MAT图文解析_dump mat-CSDN博客](https://blog.csdn.net/F1004145107/article/details/106365672)\n\n‍\n","source":"_posts/一次OOM分析.md","raw":"---\ntitle: 一次OOM分析\ndate: 2024-01-04 16:28:59\ntags: OOM\ncategories: troubleshooting\n---\n世界上没有无缘无故的爱，也没有无缘无故的恨。  \nOOM了，肯定是要找到元凶的！\n<!--more-->\n\n# 一、问题描述\n（tomcat的OOM信息会在catalina.log日志文件和catalina.out日志文件打印）\n​![image](/images/assets/image-20240104152220-2izpt7h.png)​\n\n\nOOM的时候记录并dump堆文件，JVM启动参数需要加上：\n```java\n  # 指定生成Dump文件的异常类型\n  -XX:+HeapDumpOnOutOfMemoryError\n\n  # 指定Dump文件生成的位置\n  -XX:HeapDumpPath=/data/log/erp.hprof\n```\n\n> 如果是运行中需要分析堆，也可以使用jmap主动生成\n>\n> jmap -dump:format=b,file=heap_dump.hprof  $PID\n\n# 二、问题思路\n生成堆文件后，需要分析工具。可以采用开源的[Mat](https://eclipse.dev/mat/previousReleases.php)\n\n> 注意：\n>\n> 1. 最新版本的1.15要求最少是JDK17, 我用的是1.10 可以在JDK8上运行\n> 2. Mat运行要求的内存空间较大，实际根据堆文件大小来调整 MemoryAnalyzer.ini 配置文件 。\n>\n>     我堆文件有25G，实际我分配了20G的最大堆才导入成功\n\n如果服务器上内存够用的话，可以直接生成相关报告：\n\n> ./ParseHeapDump.sh /data/log/erp_202312.hprof   org.eclipse.mat.api:suspects  org.eclipse.mat.api:overview   org.eclipse.mat.api:top_components\n\n‍\n# 三、问题分析\n好不容易导入堆文件后没找到重点，在参考一下别人怎么玩的之后，通两个功能（排列大对象+内存泄露分析）就找到元凶。  \n\n​![image](/images/assets/image-20240104154329-g9hnw90.png)​\n\n\n## 3.1 锁定上下文\n首先，对象名称是一个定时任务线程池的线程。在圆饼上左键看看大对象的上下文信息，可以找到这个定时任务具体执行类是哪个\n\n​![image](/images/assets/image-20240104155246-fieh1f7.png)​\n\n​![image](/images/assets/image-20240104160611-xmslynf.png)​\n\n‍\n## 3.2 大对象分析\n然后，选择大对象分析，发现两个List占用了11.5G，我最大堆分配的是15G。这里估计就是原因所在了\n\n​![image](/images/assets/image-20240104155650-95jxrin.png)​\n\n‍\n## 3.3 内存泄露分析\n使用内存泄露分析，发现大对象List是哪里出现的\n\n​![image](/images/assets/image-20240104160141-n1db8go.png)​\n\n‍\n## 3.4 结合代码验证\n反过来再参考代码和日志 ，印证了服务挂掉的就是这个位置  \n（这里看起来只取了一堆ID，实际上每个值都是一个LinkedHashMap，数据中大概每个List都是2000w）：\n​![image](/images/assets/image-20240104155916-dw9zsud.png)​\n\n\n# 四、问题解决\n原代码的JdbcService其实还是使用Jdbctemplate的RowMapper进行行数据提取，生成了大量的中间Map。  \n可以使用`query(String sql, RowCallbackHandler rch)`, 也可以自定义ResultSetExtractor，主动提取id，省掉中间Map\n\n参考：\n> [Dump文件分析工具 - MAT图文解析_dump mat-CSDN博客](https://blog.csdn.net/F1004145107/article/details/106365672)\n\n‍\n","slug":"一次OOM分析","published":1,"updated":"2024-04-11T03:38:10.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6ozi004eqwvdet7q60pg","content":"<p>世界上没有无缘无故的爱，也没有无缘无故的恨。<br>OOM了，肯定是要找到元凶的！</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一、问题描述\"><a href=\"#一、问题描述\" class=\"headerlink\" title=\"一、问题描述\"></a>一、问题描述</h1><p>（tomcat的OOM信息会在catalina.log日志文件和catalina.out日志文件打印）<br>​<img src=\"/images/assets/image-20240104152220-2izpt7h.png\" alt=\"image\">​</p>\n<p>OOM的时候记录并dump堆文件，JVM启动参数需要加上：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 指定生成Dump文件的异常类型</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定Dump文件生成的位置</span><br><span class=\"line\">-XX:HeapDumpPath=/data/log/erp.hprof</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果是运行中需要分析堆，也可以使用jmap主动生成</p>\n<p>jmap -dump:format&#x3D;b,file&#x3D;heap_dump.hprof  $PID</p>\n</blockquote>\n<h1 id=\"二、问题思路\"><a href=\"#二、问题思路\" class=\"headerlink\" title=\"二、问题思路\"></a>二、问题思路</h1><p>生成堆文件后，需要分析工具。可以采用开源的<a href=\"https://eclipse.dev/mat/previousReleases.php\">Mat</a></p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li><p>最新版本的1.15要求最少是JDK17, 我用的是1.10 可以在JDK8上运行</p>\n</li>\n<li><p>Mat运行要求的内存空间较大，实际根据堆文件大小来调整 MemoryAnalyzer.ini 配置文件 。</p>\n<p> 我堆文件有25G，实际我分配了20G的最大堆才导入成功</p>\n</li>\n</ol>\n</blockquote>\n<p>如果服务器上内存够用的话，可以直接生成相关报告：</p>\n<blockquote>\n<p>.&#x2F;ParseHeapDump.sh &#x2F;data&#x2F;log&#x2F;erp_202312.hprof   org.eclipse.mat.api:suspects  org.eclipse.mat.api:overview   org.eclipse.mat.api:top_components</p>\n</blockquote>\n<p>‍</p>\n<h1 id=\"三、问题分析\"><a href=\"#三、问题分析\" class=\"headerlink\" title=\"三、问题分析\"></a>三、问题分析</h1><p>好不容易导入堆文件后没找到重点，在参考一下别人怎么玩的之后，通两个功能（排列大对象+内存泄露分析）就找到元凶。  </p>\n<p>​<img src=\"/images/assets/image-20240104154329-g9hnw90.png\" alt=\"image\">​</p>\n<h2 id=\"3-1-锁定上下文\"><a href=\"#3-1-锁定上下文\" class=\"headerlink\" title=\"3.1 锁定上下文\"></a>3.1 锁定上下文</h2><p>首先，对象名称是一个定时任务线程池的线程。在圆饼上左键看看大对象的上下文信息，可以找到这个定时任务具体执行类是哪个</p>\n<p>​<img src=\"/images/assets/image-20240104155246-fieh1f7.png\" alt=\"image\">​</p>\n<p>​<img src=\"/images/assets/image-20240104160611-xmslynf.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"3-2-大对象分析\"><a href=\"#3-2-大对象分析\" class=\"headerlink\" title=\"3.2 大对象分析\"></a>3.2 大对象分析</h2><p>然后，选择大对象分析，发现两个List占用了11.5G，我最大堆分配的是15G。这里估计就是原因所在了</p>\n<p>​<img src=\"/images/assets/image-20240104155650-95jxrin.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"3-3-内存泄露分析\"><a href=\"#3-3-内存泄露分析\" class=\"headerlink\" title=\"3.3 内存泄露分析\"></a>3.3 内存泄露分析</h2><p>使用内存泄露分析，发现大对象List是哪里出现的</p>\n<p>​<img src=\"/images/assets/image-20240104160141-n1db8go.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"3-4-结合代码验证\"><a href=\"#3-4-结合代码验证\" class=\"headerlink\" title=\"3.4 结合代码验证\"></a>3.4 结合代码验证</h2><p>反过来再参考代码和日志 ，印证了服务挂掉的就是这个位置<br>（这里看起来只取了一堆ID，实际上每个值都是一个LinkedHashMap，数据中大概每个List都是2000w）：<br>​<img src=\"/images/assets/image-20240104155916-dw9zsud.png\" alt=\"image\">​</p>\n<h1 id=\"四、问题解决\"><a href=\"#四、问题解决\" class=\"headerlink\" title=\"四、问题解决\"></a>四、问题解决</h1><p>原代码的JdbcService其实还是使用Jdbctemplate的RowMapper进行行数据提取，生成了大量的中间Map。<br>可以使用<code>query(String sql, RowCallbackHandler rch)</code>, 也可以自定义ResultSetExtractor，主动提取id，省掉中间Map</p>\n<p>参考：</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/F1004145107/article/details/106365672\">Dump文件分析工具 - MAT图文解析_dump mat-CSDN博客</a></p>\n</blockquote>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>世界上没有无缘无故的爱，也没有无缘无故的恨。<br>OOM了，肯定是要找到元凶的！</p>","more":"<h1 id=\"一、问题描述\"><a href=\"#一、问题描述\" class=\"headerlink\" title=\"一、问题描述\"></a>一、问题描述</h1><p>（tomcat的OOM信息会在catalina.log日志文件和catalina.out日志文件打印）<br>​<img src=\"/images/assets/image-20240104152220-2izpt7h.png\" alt=\"image\">​</p>\n<p>OOM的时候记录并dump堆文件，JVM启动参数需要加上：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 指定生成Dump文件的异常类型</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定Dump文件生成的位置</span><br><span class=\"line\">-XX:HeapDumpPath=/data/log/erp.hprof</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果是运行中需要分析堆，也可以使用jmap主动生成</p>\n<p>jmap -dump:format&#x3D;b,file&#x3D;heap_dump.hprof  $PID</p>\n</blockquote>\n<h1 id=\"二、问题思路\"><a href=\"#二、问题思路\" class=\"headerlink\" title=\"二、问题思路\"></a>二、问题思路</h1><p>生成堆文件后，需要分析工具。可以采用开源的<a href=\"https://eclipse.dev/mat/previousReleases.php\">Mat</a></p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li><p>最新版本的1.15要求最少是JDK17, 我用的是1.10 可以在JDK8上运行</p>\n</li>\n<li><p>Mat运行要求的内存空间较大，实际根据堆文件大小来调整 MemoryAnalyzer.ini 配置文件 。</p>\n<p> 我堆文件有25G，实际我分配了20G的最大堆才导入成功</p>\n</li>\n</ol>\n</blockquote>\n<p>如果服务器上内存够用的话，可以直接生成相关报告：</p>\n<blockquote>\n<p>.&#x2F;ParseHeapDump.sh &#x2F;data&#x2F;log&#x2F;erp_202312.hprof   org.eclipse.mat.api:suspects  org.eclipse.mat.api:overview   org.eclipse.mat.api:top_components</p>\n</blockquote>\n<p>‍</p>\n<h1 id=\"三、问题分析\"><a href=\"#三、问题分析\" class=\"headerlink\" title=\"三、问题分析\"></a>三、问题分析</h1><p>好不容易导入堆文件后没找到重点，在参考一下别人怎么玩的之后，通两个功能（排列大对象+内存泄露分析）就找到元凶。  </p>\n<p>​<img src=\"/images/assets/image-20240104154329-g9hnw90.png\" alt=\"image\">​</p>\n<h2 id=\"3-1-锁定上下文\"><a href=\"#3-1-锁定上下文\" class=\"headerlink\" title=\"3.1 锁定上下文\"></a>3.1 锁定上下文</h2><p>首先，对象名称是一个定时任务线程池的线程。在圆饼上左键看看大对象的上下文信息，可以找到这个定时任务具体执行类是哪个</p>\n<p>​<img src=\"/images/assets/image-20240104155246-fieh1f7.png\" alt=\"image\">​</p>\n<p>​<img src=\"/images/assets/image-20240104160611-xmslynf.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"3-2-大对象分析\"><a href=\"#3-2-大对象分析\" class=\"headerlink\" title=\"3.2 大对象分析\"></a>3.2 大对象分析</h2><p>然后，选择大对象分析，发现两个List占用了11.5G，我最大堆分配的是15G。这里估计就是原因所在了</p>\n<p>​<img src=\"/images/assets/image-20240104155650-95jxrin.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"3-3-内存泄露分析\"><a href=\"#3-3-内存泄露分析\" class=\"headerlink\" title=\"3.3 内存泄露分析\"></a>3.3 内存泄露分析</h2><p>使用内存泄露分析，发现大对象List是哪里出现的</p>\n<p>​<img src=\"/images/assets/image-20240104160141-n1db8go.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"3-4-结合代码验证\"><a href=\"#3-4-结合代码验证\" class=\"headerlink\" title=\"3.4 结合代码验证\"></a>3.4 结合代码验证</h2><p>反过来再参考代码和日志 ，印证了服务挂掉的就是这个位置<br>（这里看起来只取了一堆ID，实际上每个值都是一个LinkedHashMap，数据中大概每个List都是2000w）：<br>​<img src=\"/images/assets/image-20240104155916-dw9zsud.png\" alt=\"image\">​</p>\n<h1 id=\"四、问题解决\"><a href=\"#四、问题解决\" class=\"headerlink\" title=\"四、问题解决\"></a>四、问题解决</h1><p>原代码的JdbcService其实还是使用Jdbctemplate的RowMapper进行行数据提取，生成了大量的中间Map。<br>可以使用<code>query(String sql, RowCallbackHandler rch)</code>, 也可以自定义ResultSetExtractor，主动提取id，省掉中间Map</p>\n<p>参考：</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/F1004145107/article/details/106365672\">Dump文件分析工具 - MAT图文解析_dump mat-CSDN博客</a></p>\n</blockquote>\n<p>‍</p>"},{"title":"从Docker到Kubernetes","date":"2023-09-26T06:58:33.000Z","_content":"docker作为容器虚拟化技术，用起来是真的香。谁用谁知道...  \n知道什么是趋势，我们就知道到底要不要去学一样东西。\n<!--more-->\n\n# 一 认识Docker\nDocker 是一种开源的软件平台，用于创建、运行和管理容器化的应用程序。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。要了解 Docker 的工作原理，你需要了解以下几个概念：\n\n- **镜像**：镜像是一个包含应用程序代码、库、环境变量和配置文件的只读模板。你可以使用镜像来创建和启动容器。\n- **容器**：容器是一个镜像的运行实例。你可以创建、启动、停止、移动或删除容器，使用 Docker API 或 CLI 进行操作。容器可以在本地机器、虚拟机或云端运行。\n- **仓库**：仓库是一个存储和共享镜像的地方。你可以使用公共或私有仓库来推送或拉取镜像。Docker Hub 是一个流行的公共仓库，提供了数百万的镜像。\n- **Dockerfile**：Dockerfile 是一个文本文件，用于定义如何从一个基础镜像构建一个自定义镜像。你可以在 Dockerfile 中指定要添加的文件、要执行的命令、要暴露的端口等。\n- **Docker Compose**：Docker Compose 是一个工具，用于定义和运行由多个容器组成的应用程序。你可以使用 YAML 文件来配置应用程序的服务、网络和卷，然后使用一个命令来启动所有的容器。\n\n如果你想学习如何使用 Docker 来构建和运行容器化的应用程序，你可以参考以下一些教程：\n\n- [Docker 101 Tutorial](https://www.docker.com/101-tutorial/)(^1^)：这是一个自学的教程，教你如何构建镜像、运行容器、使用卷来持久化数据和挂载源代码，以及使用 Docker Compose 来定义应用程序。你还可以学习一些高级主题，如网络和镜像构建最佳实践。\n- [Overview of the get started guide](https://docs.docker.com/get-started/)(^2^)：这是一个分步的指南，教你如何开始使用 Docker。这个指南向你展示如何构建和运行一个镜像作为一个容器，如何使用 Docker Hub 来共享镜像，如何使用多个容器和数据库来部署 Docker 应用程序，以及如何使用 Docker Compose 来运行应用程序。\n- [Learn Docker Tutorial](https://www.javatpoint.com/docker-tutorial)(^3^)：这是一个涵盖了 Docker 的基本概念、特性、架构、安装、镜像和容器等方面的教程。你还可以学习如何使用 Dockerfile 和 Docker Compose 来创建和管理自己的应用程序，并查看一些不同编程语言（如 Java, PHP, Python, Scala, Perl, Ruby, Swift, Ubuntu 等）的示例。\n\n源: 与必应的对话， 2023/9/26\n(1) Docker 101 Tutorial | Docker. https://www.docker.com/101-tutorial/.\n(2) Overview of the get started guide | Docker Docs. https://docs.docker.com/get-started/.\n(3) Learn Docker Tutorial - javatpoint. https://www.javatpoint.com/docker-tutorial.\n(4) play-with-docker. https://labs.play-with-docker.com/.\n\n\n## 1.1 docker容器基本命令\n``` sh\n# 根据镜像启动容器\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n# 例如，以交互模式启动一个 ubuntu 容器，并执行 bash 命令\ndocker run -it ubuntu bash\n\n# 显示主机中的容器，不加选项默认只列出运行中的容器\ndocker ps [OPTIONS]\n# 例如，显示所有容器，包括已停止的\ndocker ps -a\n\n# 启动容器\ndocker start CONTAINER\n# 例如，启动一个名为 mycontainer 的容器\ndocker start mycontainer\n\n# 停止容器\ndocker stop CONTAINER\n# 例如，停止一个名为 mycontainer 的容器\ndocker stop mycontainer\n\n# 重启容器\ndocker restart CONTAINER\n# 例如，重启一个名为 mycontainer 的容器\ndocker restart mycontainer\n\n# 进入正在运行的容器，有两种方式\n# 方式一：使用 docker exec 命令，在容器中执行一个新的进程\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n# 例如，以交互模式在一个名为 mycontainer 的容器中执行 bash 命令\ndocker exec -it mycontainer bash\n# 方式二：使用 docker attach 命令，连接到容器的主进程的标准输入、输出和错误流\ndocker attach [OPTIONS] CONTAINER\n# 例如，连接到一个名为 mycontainer 的容器\ndocker attach mycontainer\n\n# 退出容器，有两种方式\n# 方式一：在容器中执行 exit 命令，退出并停止容器\nexit\n# 方式二：按 Ctrl+P+Q 组合键，退出但不停止容器\n\n# 删除容器\ndocker rm [OPTIONS] CONTAINER [CONTAINER...]\n# 例如，删除一个名为 mycontainer 的容器\ndocker rm mycontainer\n\n```\n\n# 二 Docker运行原理\nDocker运行原理是利用Linux内核的特性，如cgroups、namespaces和AUFS等，来实现应用程序和系统资源的隔离和虚拟化。Docker的工作过程大致如下：\n\n- 用户通过Docker客户端向Docker守护进程发送命令，如创建、运行、停止、删除等。\n- Docker守护进程接收到命令后，会根据用户指定的镜像或者Dockerfile来创建或启动一个或多个容器。\n- 容器是一个运行时环境，包含了应用程序和其依赖的文件系统、网络和设备等。容器之间是相互隔离的，不会互相影响。\n- 容器可以访问宿主机上的资源，如文件系统、网络和设备等。容器也可以通过端口映射或者网络连接来与其他容器或外部系统进行通信。\n- 容器的运行状态可以通过Docker命令进行管理，如查看、停止、重启、删除等。容器的数据可以通过数据卷或者镜像提交来进行持久化或共享。\n\n如果你想了解更多关于Docker的原理和工作过程的细节，你可以参考以下一些网页：\n\n- [Docker技术核心原理讲解 - 知乎](^1^)：这是一个详细介绍了Docker的架构和工作原理的文章，包含了很多图解和示例。\n- [Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 ...](^2^)：这是一个用通俗易懂的语言讲解了Docker的基本概念、特性、架构、安装、镜像和容器等方面的博客。\n- [Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat](^3^)：这是一个简要介绍了Docker的简介、优势、应用场景和原理的网页。\n- [Docker 基本原理 - 知乎](^4^)：这是一个简单说明了Docker容器本质上是一个进程，运行于自己独立的命名空间中，所有的数据都存储在容器中的文章。\n- [docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云](^5^)：这是一个介绍了Docker容器启动过程和原理的网页，包含了一些代码和命令。\n\n\n(1) Docker技术核心原理讲解 - 知乎. https://zhuanlan.zhihu.com/p/144747363.\n(2) Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 .... https://blog.csdn.net/crazymakercircle/article/details/120747767.\n(3) Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat. https://www.redhat.com/zh/topics/containers/what-is-docker.\n(4) Docker 基本原理 - 知乎. https://zhuanlan.zhihu.com/p/31401897.\n(5) docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云. https://cloud.tencent.com/developer/article/2246223.\n(6) undefined. https://docs.docker.com/develop/sdk/%29.\n(7) undefined. https://bing.com/search?q=.\n\n# 三 Docker与Kubernetes\nKubernetes和Docker是两种不同但相关的技术，它们都属于容器化的领域。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。Docker是目前最流行的容器引擎，它可以创建、运行和管理容器。Kubernetes是一个开源的容器集群管理系统，它可以实现容器集群的自动化部署、自动扩缩容、维护等功能。\n\nKubernetes和Docker之间的关系可以说是相辅相成的。Docker为Kubernetes提供了强大的容器运行时环境，而Kubernetes则为Docker容器提供了自动化管理和编排的能力。简而言之，Docker解决了应用程序的打包和运行问题，而Kubernetes解决了应用程序的分布式管理和扩展问题。\n\n如果你想了解更多关于Kubernetes和Docker的知识，你可以参考以下一些网页：\n\n- [Kubernetes和Docker到底有啥关系？ - 知乎](^1^)：这是一个详细介绍了Kubernetes和Docker的架构和工作原理的文章，包含了很多图解和示例。\n- [简单聊聊k8s，和docker之间的关系 - 掘金](^2^)：这是一个简单聊聊Kubernetes和Docker之间的关系的博客，用通俗易懂的语言进行了解释。\n- [Kubernetes 和 Docker 的关系 - zourui4271 - 博客园](^3^)：这是一个从虚拟化角度和部署角度分析了Kubernetes和Docker之间的关系的博客，用两张图进行了对比。\n- [简单聊聊k8s，和docker之间的关系 - CSDN博客](^4^)：这是一个转载了掘金博客²的网页，内容与²相同。\n\n\n(1) Kubernetes和Docker到底有啥关系？ - 知乎. https://zhuanlan.zhihu.com/p/87186261.\n(2) 简单聊聊k8s，和docker之间的关系 - 掘金. https://juejin.cn/post/7224149297951195193.\n(3) Kubernetes 和 Docker 的关系 - zourui4271 - 博客园. https://www.cnblogs.com/zourui4271/p/14118708.html.\n(4) 简单聊聊k8s，和docker之间的关系 - CSDN博客. https://blog.csdn.net/qq_34050399/article/details/130279127.\n(5) 简单聊聊k8s，和docker之间的关系 - 掘金. https://juejin.cn/post/7224149297951195193.\n\n","source":"_posts/从Docker到Kubernetes.md","raw":"---\ntitle: 从Docker到Kubernetes\ndate: 2023-09-26 14:58:33\ntags: k8s\ncategories: 云原生\n---\ndocker作为容器虚拟化技术，用起来是真的香。谁用谁知道...  \n知道什么是趋势，我们就知道到底要不要去学一样东西。\n<!--more-->\n\n# 一 认识Docker\nDocker 是一种开源的软件平台，用于创建、运行和管理容器化的应用程序。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。要了解 Docker 的工作原理，你需要了解以下几个概念：\n\n- **镜像**：镜像是一个包含应用程序代码、库、环境变量和配置文件的只读模板。你可以使用镜像来创建和启动容器。\n- **容器**：容器是一个镜像的运行实例。你可以创建、启动、停止、移动或删除容器，使用 Docker API 或 CLI 进行操作。容器可以在本地机器、虚拟机或云端运行。\n- **仓库**：仓库是一个存储和共享镜像的地方。你可以使用公共或私有仓库来推送或拉取镜像。Docker Hub 是一个流行的公共仓库，提供了数百万的镜像。\n- **Dockerfile**：Dockerfile 是一个文本文件，用于定义如何从一个基础镜像构建一个自定义镜像。你可以在 Dockerfile 中指定要添加的文件、要执行的命令、要暴露的端口等。\n- **Docker Compose**：Docker Compose 是一个工具，用于定义和运行由多个容器组成的应用程序。你可以使用 YAML 文件来配置应用程序的服务、网络和卷，然后使用一个命令来启动所有的容器。\n\n如果你想学习如何使用 Docker 来构建和运行容器化的应用程序，你可以参考以下一些教程：\n\n- [Docker 101 Tutorial](https://www.docker.com/101-tutorial/)(^1^)：这是一个自学的教程，教你如何构建镜像、运行容器、使用卷来持久化数据和挂载源代码，以及使用 Docker Compose 来定义应用程序。你还可以学习一些高级主题，如网络和镜像构建最佳实践。\n- [Overview of the get started guide](https://docs.docker.com/get-started/)(^2^)：这是一个分步的指南，教你如何开始使用 Docker。这个指南向你展示如何构建和运行一个镜像作为一个容器，如何使用 Docker Hub 来共享镜像，如何使用多个容器和数据库来部署 Docker 应用程序，以及如何使用 Docker Compose 来运行应用程序。\n- [Learn Docker Tutorial](https://www.javatpoint.com/docker-tutorial)(^3^)：这是一个涵盖了 Docker 的基本概念、特性、架构、安装、镜像和容器等方面的教程。你还可以学习如何使用 Dockerfile 和 Docker Compose 来创建和管理自己的应用程序，并查看一些不同编程语言（如 Java, PHP, Python, Scala, Perl, Ruby, Swift, Ubuntu 等）的示例。\n\n源: 与必应的对话， 2023/9/26\n(1) Docker 101 Tutorial | Docker. https://www.docker.com/101-tutorial/.\n(2) Overview of the get started guide | Docker Docs. https://docs.docker.com/get-started/.\n(3) Learn Docker Tutorial - javatpoint. https://www.javatpoint.com/docker-tutorial.\n(4) play-with-docker. https://labs.play-with-docker.com/.\n\n\n## 1.1 docker容器基本命令\n``` sh\n# 根据镜像启动容器\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n# 例如，以交互模式启动一个 ubuntu 容器，并执行 bash 命令\ndocker run -it ubuntu bash\n\n# 显示主机中的容器，不加选项默认只列出运行中的容器\ndocker ps [OPTIONS]\n# 例如，显示所有容器，包括已停止的\ndocker ps -a\n\n# 启动容器\ndocker start CONTAINER\n# 例如，启动一个名为 mycontainer 的容器\ndocker start mycontainer\n\n# 停止容器\ndocker stop CONTAINER\n# 例如，停止一个名为 mycontainer 的容器\ndocker stop mycontainer\n\n# 重启容器\ndocker restart CONTAINER\n# 例如，重启一个名为 mycontainer 的容器\ndocker restart mycontainer\n\n# 进入正在运行的容器，有两种方式\n# 方式一：使用 docker exec 命令，在容器中执行一个新的进程\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n# 例如，以交互模式在一个名为 mycontainer 的容器中执行 bash 命令\ndocker exec -it mycontainer bash\n# 方式二：使用 docker attach 命令，连接到容器的主进程的标准输入、输出和错误流\ndocker attach [OPTIONS] CONTAINER\n# 例如，连接到一个名为 mycontainer 的容器\ndocker attach mycontainer\n\n# 退出容器，有两种方式\n# 方式一：在容器中执行 exit 命令，退出并停止容器\nexit\n# 方式二：按 Ctrl+P+Q 组合键，退出但不停止容器\n\n# 删除容器\ndocker rm [OPTIONS] CONTAINER [CONTAINER...]\n# 例如，删除一个名为 mycontainer 的容器\ndocker rm mycontainer\n\n```\n\n# 二 Docker运行原理\nDocker运行原理是利用Linux内核的特性，如cgroups、namespaces和AUFS等，来实现应用程序和系统资源的隔离和虚拟化。Docker的工作过程大致如下：\n\n- 用户通过Docker客户端向Docker守护进程发送命令，如创建、运行、停止、删除等。\n- Docker守护进程接收到命令后，会根据用户指定的镜像或者Dockerfile来创建或启动一个或多个容器。\n- 容器是一个运行时环境，包含了应用程序和其依赖的文件系统、网络和设备等。容器之间是相互隔离的，不会互相影响。\n- 容器可以访问宿主机上的资源，如文件系统、网络和设备等。容器也可以通过端口映射或者网络连接来与其他容器或外部系统进行通信。\n- 容器的运行状态可以通过Docker命令进行管理，如查看、停止、重启、删除等。容器的数据可以通过数据卷或者镜像提交来进行持久化或共享。\n\n如果你想了解更多关于Docker的原理和工作过程的细节，你可以参考以下一些网页：\n\n- [Docker技术核心原理讲解 - 知乎](^1^)：这是一个详细介绍了Docker的架构和工作原理的文章，包含了很多图解和示例。\n- [Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 ...](^2^)：这是一个用通俗易懂的语言讲解了Docker的基本概念、特性、架构、安装、镜像和容器等方面的博客。\n- [Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat](^3^)：这是一个简要介绍了Docker的简介、优势、应用场景和原理的网页。\n- [Docker 基本原理 - 知乎](^4^)：这是一个简单说明了Docker容器本质上是一个进程，运行于自己独立的命名空间中，所有的数据都存储在容器中的文章。\n- [docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云](^5^)：这是一个介绍了Docker容器启动过程和原理的网页，包含了一些代码和命令。\n\n\n(1) Docker技术核心原理讲解 - 知乎. https://zhuanlan.zhihu.com/p/144747363.\n(2) Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 .... https://blog.csdn.net/crazymakercircle/article/details/120747767.\n(3) Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat. https://www.redhat.com/zh/topics/containers/what-is-docker.\n(4) Docker 基本原理 - 知乎. https://zhuanlan.zhihu.com/p/31401897.\n(5) docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云. https://cloud.tencent.com/developer/article/2246223.\n(6) undefined. https://docs.docker.com/develop/sdk/%29.\n(7) undefined. https://bing.com/search?q=.\n\n# 三 Docker与Kubernetes\nKubernetes和Docker是两种不同但相关的技术，它们都属于容器化的领域。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。Docker是目前最流行的容器引擎，它可以创建、运行和管理容器。Kubernetes是一个开源的容器集群管理系统，它可以实现容器集群的自动化部署、自动扩缩容、维护等功能。\n\nKubernetes和Docker之间的关系可以说是相辅相成的。Docker为Kubernetes提供了强大的容器运行时环境，而Kubernetes则为Docker容器提供了自动化管理和编排的能力。简而言之，Docker解决了应用程序的打包和运行问题，而Kubernetes解决了应用程序的分布式管理和扩展问题。\n\n如果你想了解更多关于Kubernetes和Docker的知识，你可以参考以下一些网页：\n\n- [Kubernetes和Docker到底有啥关系？ - 知乎](^1^)：这是一个详细介绍了Kubernetes和Docker的架构和工作原理的文章，包含了很多图解和示例。\n- [简单聊聊k8s，和docker之间的关系 - 掘金](^2^)：这是一个简单聊聊Kubernetes和Docker之间的关系的博客，用通俗易懂的语言进行了解释。\n- [Kubernetes 和 Docker 的关系 - zourui4271 - 博客园](^3^)：这是一个从虚拟化角度和部署角度分析了Kubernetes和Docker之间的关系的博客，用两张图进行了对比。\n- [简单聊聊k8s，和docker之间的关系 - CSDN博客](^4^)：这是一个转载了掘金博客²的网页，内容与²相同。\n\n\n(1) Kubernetes和Docker到底有啥关系？ - 知乎. https://zhuanlan.zhihu.com/p/87186261.\n(2) 简单聊聊k8s，和docker之间的关系 - 掘金. https://juejin.cn/post/7224149297951195193.\n(3) Kubernetes 和 Docker 的关系 - zourui4271 - 博客园. https://www.cnblogs.com/zourui4271/p/14118708.html.\n(4) 简单聊聊k8s，和docker之间的关系 - CSDN博客. https://blog.csdn.net/qq_34050399/article/details/130279127.\n(5) 简单聊聊k8s，和docker之间的关系 - 掘金. https://juejin.cn/post/7224149297951195193.\n\n","slug":"从Docker到Kubernetes","published":1,"updated":"2024-02-18T07:34:30.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6ozj004gqwvdc6ho3sqr","content":"<p>docker作为容器虚拟化技术，用起来是真的香。谁用谁知道…<br>知道什么是趋势，我们就知道到底要不要去学一样东西。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一-认识Docker\"><a href=\"#一-认识Docker\" class=\"headerlink\" title=\"一 认识Docker\"></a>一 认识Docker</h1><p>Docker 是一种开源的软件平台，用于创建、运行和管理容器化的应用程序。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。要了解 Docker 的工作原理，你需要了解以下几个概念：</p>\n<ul>\n<li><strong>镜像</strong>：镜像是一个包含应用程序代码、库、环境变量和配置文件的只读模板。你可以使用镜像来创建和启动容器。</li>\n<li><strong>容器</strong>：容器是一个镜像的运行实例。你可以创建、启动、停止、移动或删除容器，使用 Docker API 或 CLI 进行操作。容器可以在本地机器、虚拟机或云端运行。</li>\n<li><strong>仓库</strong>：仓库是一个存储和共享镜像的地方。你可以使用公共或私有仓库来推送或拉取镜像。Docker Hub 是一个流行的公共仓库，提供了数百万的镜像。</li>\n<li><strong>Dockerfile</strong>：Dockerfile 是一个文本文件，用于定义如何从一个基础镜像构建一个自定义镜像。你可以在 Dockerfile 中指定要添加的文件、要执行的命令、要暴露的端口等。</li>\n<li><strong>Docker Compose</strong>：Docker Compose 是一个工具，用于定义和运行由多个容器组成的应用程序。你可以使用 YAML 文件来配置应用程序的服务、网络和卷，然后使用一个命令来启动所有的容器。</li>\n</ul>\n<p>如果你想学习如何使用 Docker 来构建和运行容器化的应用程序，你可以参考以下一些教程：</p>\n<ul>\n<li><a href=\"https://www.docker.com/101-tutorial/\">Docker 101 Tutorial</a>(^1^)：这是一个自学的教程，教你如何构建镜像、运行容器、使用卷来持久化数据和挂载源代码，以及使用 Docker Compose 来定义应用程序。你还可以学习一些高级主题，如网络和镜像构建最佳实践。</li>\n<li><a href=\"https://docs.docker.com/get-started/\">Overview of the get started guide</a>(^2^)：这是一个分步的指南，教你如何开始使用 Docker。这个指南向你展示如何构建和运行一个镜像作为一个容器，如何使用 Docker Hub 来共享镜像，如何使用多个容器和数据库来部署 Docker 应用程序，以及如何使用 Docker Compose 来运行应用程序。</li>\n<li><a href=\"https://www.javatpoint.com/docker-tutorial\">Learn Docker Tutorial</a>(^3^)：这是一个涵盖了 Docker 的基本概念、特性、架构、安装、镜像和容器等方面的教程。你还可以学习如何使用 Dockerfile 和 Docker Compose 来创建和管理自己的应用程序，并查看一些不同编程语言（如 Java, PHP, Python, Scala, Perl, Ruby, Swift, Ubuntu 等）的示例。</li>\n</ul>\n<p>源: 与必应的对话， 2023&#x2F;9&#x2F;26<br>(1) Docker 101 Tutorial | Docker. <a href=\"https://www.docker.com/101-tutorial/\">https://www.docker.com/101-tutorial/</a>.<br>(2) Overview of the get started guide | Docker Docs. <a href=\"https://docs.docker.com/get-started/\">https://docs.docker.com/get-started/</a>.<br>(3) Learn Docker Tutorial - javatpoint. <a href=\"https://www.javatpoint.com/docker-tutorial\">https://www.javatpoint.com/docker-tutorial</a>.<br>(4) play-with-docker. <a href=\"https://labs.play-with-docker.com/\">https://labs.play-with-docker.com/</a>.</p>\n<h2 id=\"1-1-docker容器基本命令\"><a href=\"#1-1-docker容器基本命令\" class=\"headerlink\" title=\"1.1 docker容器基本命令\"></a>1.1 docker容器基本命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根据镜像启动容器</span></span><br><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class=\"line\"><span class=\"comment\"># 例如，以交互模式启动一个 ubuntu 容器，并执行 bash 命令</span></span><br><span class=\"line\">docker run -it ubuntu bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示主机中的容器，不加选项默认只列出运行中的容器</span></span><br><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"><span class=\"comment\"># 例如，显示所有容器，包括已停止的</span></span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">docker start CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，启动一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker start mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止容器</span></span><br><span class=\"line\">docker stop CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，停止一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker stop mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启容器</span></span><br><span class=\"line\">docker restart CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，重启一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker restart mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入正在运行的容器，有两种方式</span></span><br><span class=\"line\"><span class=\"comment\"># 方式一：使用 docker exec 命令，在容器中执行一个新的进程</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class=\"line\"><span class=\"comment\"># 例如，以交互模式在一个名为 mycontainer 的容器中执行 bash 命令</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it mycontainer bash</span><br><span class=\"line\"><span class=\"comment\"># 方式二：使用 docker attach 命令，连接到容器的主进程的标准输入、输出和错误流</span></span><br><span class=\"line\">docker attach [OPTIONS] CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，连接到一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker attach mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出容器，有两种方式</span></span><br><span class=\"line\"><span class=\"comment\"># 方式一：在容器中执行 exit 命令，退出并停止容器</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span></span><br><span class=\"line\"><span class=\"comment\"># 方式二：按 Ctrl+P+Q 组合键，退出但不停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除容器</span></span><br><span class=\"line\">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"><span class=\"comment\"># 例如，删除一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker rm mycontainer</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二-Docker运行原理\"><a href=\"#二-Docker运行原理\" class=\"headerlink\" title=\"二 Docker运行原理\"></a>二 Docker运行原理</h1><p>Docker运行原理是利用Linux内核的特性，如cgroups、namespaces和AUFS等，来实现应用程序和系统资源的隔离和虚拟化。Docker的工作过程大致如下：</p>\n<ul>\n<li>用户通过Docker客户端向Docker守护进程发送命令，如创建、运行、停止、删除等。</li>\n<li>Docker守护进程接收到命令后，会根据用户指定的镜像或者Dockerfile来创建或启动一个或多个容器。</li>\n<li>容器是一个运行时环境，包含了应用程序和其依赖的文件系统、网络和设备等。容器之间是相互隔离的，不会互相影响。</li>\n<li>容器可以访问宿主机上的资源，如文件系统、网络和设备等。容器也可以通过端口映射或者网络连接来与其他容器或外部系统进行通信。</li>\n<li>容器的运行状态可以通过Docker命令进行管理，如查看、停止、重启、删除等。容器的数据可以通过数据卷或者镜像提交来进行持久化或共享。</li>\n</ul>\n<p>如果你想了解更多关于Docker的原理和工作过程的细节，你可以参考以下一些网页：</p>\n<ul>\n<li><a href=\"%5E1%5E\">Docker技术核心原理讲解 - 知乎</a>：这是一个详细介绍了Docker的架构和工作原理的文章，包含了很多图解和示例。</li>\n<li><a href=\"%5E2%5E\">Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 …</a>：这是一个用通俗易懂的语言讲解了Docker的基本概念、特性、架构、安装、镜像和容器等方面的博客。</li>\n<li><a href=\"%5E3%5E\">Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat</a>：这是一个简要介绍了Docker的简介、优势、应用场景和原理的网页。</li>\n<li><a href=\"%5E4%5E\">Docker 基本原理 - 知乎</a>：这是一个简单说明了Docker容器本质上是一个进程，运行于自己独立的命名空间中，所有的数据都存储在容器中的文章。</li>\n<li><a href=\"%5E5%5E\">docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云</a>：这是一个介绍了Docker容器启动过程和原理的网页，包含了一些代码和命令。</li>\n</ul>\n<p>(1) Docker技术核心原理讲解 - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/144747363\">https://zhuanlan.zhihu.com/p/144747363</a>.<br>(2) Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 …. <a href=\"https://blog.csdn.net/crazymakercircle/article/details/120747767\">https://blog.csdn.net/crazymakercircle/article/details/120747767</a>.<br>(3) Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat. <a href=\"https://www.redhat.com/zh/topics/containers/what-is-docker\">https://www.redhat.com/zh/topics/containers/what-is-docker</a>.<br>(4) Docker 基本原理 - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/31401897\">https://zhuanlan.zhihu.com/p/31401897</a>.<br>(5) docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云. <a href=\"https://cloud.tencent.com/developer/article/2246223\">https://cloud.tencent.com/developer/article/2246223</a>.<br>(6) undefined. <a href=\"https://docs.docker.com/develop/sdk/%29\">https://docs.docker.com/develop/sdk/%29</a>.<br>(7) undefined. <a href=\"https://bing.com/search?q=\">https://bing.com/search?q=</a>.</p>\n<h1 id=\"三-Docker与Kubernetes\"><a href=\"#三-Docker与Kubernetes\" class=\"headerlink\" title=\"三 Docker与Kubernetes\"></a>三 Docker与Kubernetes</h1><p>Kubernetes和Docker是两种不同但相关的技术，它们都属于容器化的领域。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。Docker是目前最流行的容器引擎，它可以创建、运行和管理容器。Kubernetes是一个开源的容器集群管理系统，它可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</p>\n<p>Kubernetes和Docker之间的关系可以说是相辅相成的。Docker为Kubernetes提供了强大的容器运行时环境，而Kubernetes则为Docker容器提供了自动化管理和编排的能力。简而言之，Docker解决了应用程序的打包和运行问题，而Kubernetes解决了应用程序的分布式管理和扩展问题。</p>\n<p>如果你想了解更多关于Kubernetes和Docker的知识，你可以参考以下一些网页：</p>\n<ul>\n<li><a href=\"%5E1%5E\">Kubernetes和Docker到底有啥关系？ - 知乎</a>：这是一个详细介绍了Kubernetes和Docker的架构和工作原理的文章，包含了很多图解和示例。</li>\n<li><a href=\"%5E2%5E\">简单聊聊k8s，和docker之间的关系 - 掘金</a>：这是一个简单聊聊Kubernetes和Docker之间的关系的博客，用通俗易懂的语言进行了解释。</li>\n<li><a href=\"%5E3%5E\">Kubernetes 和 Docker 的关系 - zourui4271 - 博客园</a>：这是一个从虚拟化角度和部署角度分析了Kubernetes和Docker之间的关系的博客，用两张图进行了对比。</li>\n<li><a href=\"%5E4%5E\">简单聊聊k8s，和docker之间的关系 - CSDN博客</a>：这是一个转载了掘金博客²的网页，内容与²相同。</li>\n</ul>\n<p>(1) Kubernetes和Docker到底有啥关系？ - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/87186261\">https://zhuanlan.zhihu.com/p/87186261</a>.<br>(2) 简单聊聊k8s，和docker之间的关系 - 掘金. <a href=\"https://juejin.cn/post/7224149297951195193\">https://juejin.cn/post/7224149297951195193</a>.<br>(3) Kubernetes 和 Docker 的关系 - zourui4271 - 博客园. <a href=\"https://www.cnblogs.com/zourui4271/p/14118708.html\">https://www.cnblogs.com/zourui4271/p/14118708.html</a>.<br>(4) 简单聊聊k8s，和docker之间的关系 - CSDN博客. <a href=\"https://blog.csdn.net/qq_34050399/article/details/130279127\">https://blog.csdn.net/qq_34050399/article/details/130279127</a>.<br>(5) 简单聊聊k8s，和docker之间的关系 - 掘金. <a href=\"https://juejin.cn/post/7224149297951195193\">https://juejin.cn/post/7224149297951195193</a>.</p>\n","site":{"data":{}},"excerpt":"<p>docker作为容器虚拟化技术，用起来是真的香。谁用谁知道…<br>知道什么是趋势，我们就知道到底要不要去学一样东西。</p>","more":"<h1 id=\"一-认识Docker\"><a href=\"#一-认识Docker\" class=\"headerlink\" title=\"一 认识Docker\"></a>一 认识Docker</h1><p>Docker 是一种开源的软件平台，用于创建、运行和管理容器化的应用程序。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。要了解 Docker 的工作原理，你需要了解以下几个概念：</p>\n<ul>\n<li><strong>镜像</strong>：镜像是一个包含应用程序代码、库、环境变量和配置文件的只读模板。你可以使用镜像来创建和启动容器。</li>\n<li><strong>容器</strong>：容器是一个镜像的运行实例。你可以创建、启动、停止、移动或删除容器，使用 Docker API 或 CLI 进行操作。容器可以在本地机器、虚拟机或云端运行。</li>\n<li><strong>仓库</strong>：仓库是一个存储和共享镜像的地方。你可以使用公共或私有仓库来推送或拉取镜像。Docker Hub 是一个流行的公共仓库，提供了数百万的镜像。</li>\n<li><strong>Dockerfile</strong>：Dockerfile 是一个文本文件，用于定义如何从一个基础镜像构建一个自定义镜像。你可以在 Dockerfile 中指定要添加的文件、要执行的命令、要暴露的端口等。</li>\n<li><strong>Docker Compose</strong>：Docker Compose 是一个工具，用于定义和运行由多个容器组成的应用程序。你可以使用 YAML 文件来配置应用程序的服务、网络和卷，然后使用一个命令来启动所有的容器。</li>\n</ul>\n<p>如果你想学习如何使用 Docker 来构建和运行容器化的应用程序，你可以参考以下一些教程：</p>\n<ul>\n<li><a href=\"https://www.docker.com/101-tutorial/\">Docker 101 Tutorial</a>(^1^)：这是一个自学的教程，教你如何构建镜像、运行容器、使用卷来持久化数据和挂载源代码，以及使用 Docker Compose 来定义应用程序。你还可以学习一些高级主题，如网络和镜像构建最佳实践。</li>\n<li><a href=\"https://docs.docker.com/get-started/\">Overview of the get started guide</a>(^2^)：这是一个分步的指南，教你如何开始使用 Docker。这个指南向你展示如何构建和运行一个镜像作为一个容器，如何使用 Docker Hub 来共享镜像，如何使用多个容器和数据库来部署 Docker 应用程序，以及如何使用 Docker Compose 来运行应用程序。</li>\n<li><a href=\"https://www.javatpoint.com/docker-tutorial\">Learn Docker Tutorial</a>(^3^)：这是一个涵盖了 Docker 的基本概念、特性、架构、安装、镜像和容器等方面的教程。你还可以学习如何使用 Dockerfile 和 Docker Compose 来创建和管理自己的应用程序，并查看一些不同编程语言（如 Java, PHP, Python, Scala, Perl, Ruby, Swift, Ubuntu 等）的示例。</li>\n</ul>\n<p>源: 与必应的对话， 2023&#x2F;9&#x2F;26<br>(1) Docker 101 Tutorial | Docker. <a href=\"https://www.docker.com/101-tutorial/\">https://www.docker.com/101-tutorial/</a>.<br>(2) Overview of the get started guide | Docker Docs. <a href=\"https://docs.docker.com/get-started/\">https://docs.docker.com/get-started/</a>.<br>(3) Learn Docker Tutorial - javatpoint. <a href=\"https://www.javatpoint.com/docker-tutorial\">https://www.javatpoint.com/docker-tutorial</a>.<br>(4) play-with-docker. <a href=\"https://labs.play-with-docker.com/\">https://labs.play-with-docker.com/</a>.</p>\n<h2 id=\"1-1-docker容器基本命令\"><a href=\"#1-1-docker容器基本命令\" class=\"headerlink\" title=\"1.1 docker容器基本命令\"></a>1.1 docker容器基本命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根据镜像启动容器</span></span><br><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class=\"line\"><span class=\"comment\"># 例如，以交互模式启动一个 ubuntu 容器，并执行 bash 命令</span></span><br><span class=\"line\">docker run -it ubuntu bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示主机中的容器，不加选项默认只列出运行中的容器</span></span><br><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"><span class=\"comment\"># 例如，显示所有容器，包括已停止的</span></span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">docker start CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，启动一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker start mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止容器</span></span><br><span class=\"line\">docker stop CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，停止一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker stop mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启容器</span></span><br><span class=\"line\">docker restart CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，重启一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker restart mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入正在运行的容器，有两种方式</span></span><br><span class=\"line\"><span class=\"comment\"># 方式一：使用 docker exec 命令，在容器中执行一个新的进程</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class=\"line\"><span class=\"comment\"># 例如，以交互模式在一个名为 mycontainer 的容器中执行 bash 命令</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it mycontainer bash</span><br><span class=\"line\"><span class=\"comment\"># 方式二：使用 docker attach 命令，连接到容器的主进程的标准输入、输出和错误流</span></span><br><span class=\"line\">docker attach [OPTIONS] CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 例如，连接到一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker attach mycontainer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出容器，有两种方式</span></span><br><span class=\"line\"><span class=\"comment\"># 方式一：在容器中执行 exit 命令，退出并停止容器</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span></span><br><span class=\"line\"><span class=\"comment\"># 方式二：按 Ctrl+P+Q 组合键，退出但不停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除容器</span></span><br><span class=\"line\">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"><span class=\"comment\"># 例如，删除一个名为 mycontainer 的容器</span></span><br><span class=\"line\">docker rm mycontainer</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二-Docker运行原理\"><a href=\"#二-Docker运行原理\" class=\"headerlink\" title=\"二 Docker运行原理\"></a>二 Docker运行原理</h1><p>Docker运行原理是利用Linux内核的特性，如cgroups、namespaces和AUFS等，来实现应用程序和系统资源的隔离和虚拟化。Docker的工作过程大致如下：</p>\n<ul>\n<li>用户通过Docker客户端向Docker守护进程发送命令，如创建、运行、停止、删除等。</li>\n<li>Docker守护进程接收到命令后，会根据用户指定的镜像或者Dockerfile来创建或启动一个或多个容器。</li>\n<li>容器是一个运行时环境，包含了应用程序和其依赖的文件系统、网络和设备等。容器之间是相互隔离的，不会互相影响。</li>\n<li>容器可以访问宿主机上的资源，如文件系统、网络和设备等。容器也可以通过端口映射或者网络连接来与其他容器或外部系统进行通信。</li>\n<li>容器的运行状态可以通过Docker命令进行管理，如查看、停止、重启、删除等。容器的数据可以通过数据卷或者镜像提交来进行持久化或共享。</li>\n</ul>\n<p>如果你想了解更多关于Docker的原理和工作过程的细节，你可以参考以下一些网页：</p>\n<ul>\n<li><a href=\"%5E1%5E\">Docker技术核心原理讲解 - 知乎</a>：这是一个详细介绍了Docker的架构和工作原理的文章，包含了很多图解和示例。</li>\n<li><a href=\"%5E2%5E\">Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 …</a>：这是一个用通俗易懂的语言讲解了Docker的基本概念、特性、架构、安装、镜像和容器等方面的博客。</li>\n<li><a href=\"%5E3%5E\">Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat</a>：这是一个简要介绍了Docker的简介、优势、应用场景和原理的网页。</li>\n<li><a href=\"%5E4%5E\">Docker 基本原理 - 知乎</a>：这是一个简单说明了Docker容器本质上是一个进程，运行于自己独立的命名空间中，所有的数据都存储在容器中的文章。</li>\n<li><a href=\"%5E5%5E\">docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云</a>：这是一个介绍了Docker容器启动过程和原理的网页，包含了一些代码和命令。</li>\n</ul>\n<p>(1) Docker技术核心原理讲解 - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/144747363\">https://zhuanlan.zhihu.com/p/144747363</a>.<br>(2) Docker原理（图解+秒懂+史上最全）_40岁资深老架构师尼 …. <a href=\"https://blog.csdn.net/crazymakercircle/article/details/120747767\">https://blog.csdn.net/crazymakercircle/article/details/120747767</a>.<br>(3) Docker 原理新手指南：一文看懂 Docker 是什么? - Red Hat. <a href=\"https://www.redhat.com/zh/topics/containers/what-is-docker\">https://www.redhat.com/zh/topics/containers/what-is-docker</a>.<br>(4) Docker 基本原理 - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/31401897\">https://zhuanlan.zhihu.com/p/31401897</a>.<br>(5) docker启动容器全过程以及原理-腾讯云开发者社区-腾讯云. <a href=\"https://cloud.tencent.com/developer/article/2246223\">https://cloud.tencent.com/developer/article/2246223</a>.<br>(6) undefined. <a href=\"https://docs.docker.com/develop/sdk/%29\">https://docs.docker.com/develop/sdk/%29</a>.<br>(7) undefined. <a href=\"https://bing.com/search?q=\">https://bing.com/search?q=</a>.</p>\n<h1 id=\"三-Docker与Kubernetes\"><a href=\"#三-Docker与Kubernetes\" class=\"headerlink\" title=\"三 Docker与Kubernetes\"></a>三 Docker与Kubernetes</h1><p>Kubernetes和Docker是两种不同但相关的技术，它们都属于容器化的领域。容器是一种轻量级的虚拟化技术，可以在隔离的环境中运行应用程序和其依赖项，从而提高可移植性、安全性和效率。Docker是目前最流行的容器引擎，它可以创建、运行和管理容器。Kubernetes是一个开源的容器集群管理系统，它可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</p>\n<p>Kubernetes和Docker之间的关系可以说是相辅相成的。Docker为Kubernetes提供了强大的容器运行时环境，而Kubernetes则为Docker容器提供了自动化管理和编排的能力。简而言之，Docker解决了应用程序的打包和运行问题，而Kubernetes解决了应用程序的分布式管理和扩展问题。</p>\n<p>如果你想了解更多关于Kubernetes和Docker的知识，你可以参考以下一些网页：</p>\n<ul>\n<li><a href=\"%5E1%5E\">Kubernetes和Docker到底有啥关系？ - 知乎</a>：这是一个详细介绍了Kubernetes和Docker的架构和工作原理的文章，包含了很多图解和示例。</li>\n<li><a href=\"%5E2%5E\">简单聊聊k8s，和docker之间的关系 - 掘金</a>：这是一个简单聊聊Kubernetes和Docker之间的关系的博客，用通俗易懂的语言进行了解释。</li>\n<li><a href=\"%5E3%5E\">Kubernetes 和 Docker 的关系 - zourui4271 - 博客园</a>：这是一个从虚拟化角度和部署角度分析了Kubernetes和Docker之间的关系的博客，用两张图进行了对比。</li>\n<li><a href=\"%5E4%5E\">简单聊聊k8s，和docker之间的关系 - CSDN博客</a>：这是一个转载了掘金博客²的网页，内容与²相同。</li>\n</ul>\n<p>(1) Kubernetes和Docker到底有啥关系？ - 知乎. <a href=\"https://zhuanlan.zhihu.com/p/87186261\">https://zhuanlan.zhihu.com/p/87186261</a>.<br>(2) 简单聊聊k8s，和docker之间的关系 - 掘金. <a href=\"https://juejin.cn/post/7224149297951195193\">https://juejin.cn/post/7224149297951195193</a>.<br>(3) Kubernetes 和 Docker 的关系 - zourui4271 - 博客园. <a href=\"https://www.cnblogs.com/zourui4271/p/14118708.html\">https://www.cnblogs.com/zourui4271/p/14118708.html</a>.<br>(4) 简单聊聊k8s，和docker之间的关系 - CSDN博客. <a href=\"https://blog.csdn.net/qq_34050399/article/details/130279127\">https://blog.csdn.net/qq_34050399/article/details/130279127</a>.<br>(5) 简单聊聊k8s，和docker之间的关系 - 掘金. <a href=\"https://juejin.cn/post/7224149297951195193\">https://juejin.cn/post/7224149297951195193</a>.</p>"},{"title":"分布式限流sentinel","date":"2024-04-24T10:00:37.000Z","_content":"单机限流可以采用以令牌桶、漏桶算法为基础的诸多实现，在分布式限流一般使用的是网关产品附带的一些限流功能。而Sentinel，提供了丰富的限流、熔断、降级等功能，更是提供了控制台系统展示、灵活控制这些规则，相当强大！\n<!--more-->\n# 一、限流简述\n限流定义：只允许指定数量的事件进入系统，超出部分将被拒绝服务、排队、降级等处理  \n限流目标： 保证一部分请求流量可以得到正常响应，避免系统雪崩  \n常说的限流，一般是单机限流。单机限流可以通过Guava的RateLimiter来实现，它使用的是令牌桶算法。  \n分布式限流以前使用的是nginx的限流模块，限制并发连接和限制同一IP的访问频次。可是，在实际引用中还远远不够，一般需要通过LUA来加入一些更灵活实用的功能。  \nSentinel作为AlibabaSrpingCloud的一部分，承接了阿里巴巴近10年的双十一大促流量的核心场景，有丰富的应用场景以及监控+开源生态。个人使用来看，个人认为sentinel的优势在于，除了提供全面的限流降级的接入方式，更在于提供了控制台，便于服务本身接入并自动采集Metrics，以及基于Metics（QPS，链路，内存，CPU等）的各类限流熔断，这些才是真实场景中实用的。  \n\n# 二、同类组件对比\n​![image](/images/assets/image-20240425162917-mdlq5qj.png)\n\n\n\n\n# 三、资源与规则\n\n[basic-api-resource-rule | Sentinel (sentinelguard.io)](https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html)\n\n‍\n\n### 定义资源\n\n* [主流框架接入](https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html)\n\n* 使用注解@SentinelResource\n* 自定义定义，包括 抛出异常、布尔值判断、异步异常捕获\n\n  ```java\n  /**\n   ----------1 抛出异常------------------\n  */\n  try (Entry entry = SphU.entry(\"resourceName\")) {\n    // 被保护的业务逻辑\n    // do something here...\n  } catch (BlockException ex) {\n    // 资源访问阻止，被限流或被降级\n    // 在此处进行相应的处理操作\n  }\n\n\n  /**\n    ----------1 布尔值判断------------------\n  */\n    // 资源名可使用任意有业务语义的字符串\n    if (SphO.entry(\"自定义资源名\")) {\n      // 务必保证finally会被执行\n      try {\n        /**\n        * 被保护的业务逻辑\n        */\n      } finally {\n        SphO.exit();\n      }\n    } else {\n      // 资源访问阻止，被限流或被降级\n      // 进行相应的处理操作\n    }\n  ```\n\n‍\n\n### 定义规则\n\n* 流量控制规则 (FlowRule)\n\n  基本场景，可针对QPS、线程数等资源，按照限流策略（直接、链路、关联），达到流控效果（直接拒绝 / 排队等待 / 慢启动模式）。\n* 熔断降级规则 (DegradeRule)\n\n  对于高并发场景的异常接口情况（慢调用比例 异常比例 异常数）进行限制，达到服务降级效果\n* 系统保护规则 (SystemRule)\n\n  结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡\n* 访问控制规则 (AuthorityRule)\n\n  根据调用方来限制资源是否通过，这个更多像一个网关的功能\n* 热点规则 (ParamFlowRule)\n\n  利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。这个针对高并发的细节控制有意想不到效果。\n\n经历过活动高并发的大流量直接把服务挂掉的经验，熔断、系统保护是必要的的，流控最为实用。\n\n‍\n\n#### 流控规则\n\n​![image](/images/assets/image-20240226173616-kau7kcb.png)​\n\n‍\n\n‍\n\n[流控规则详解](https://zhuanlan.zhihu.com/p/439916935)\n\n#### 流控模式\n\n1. 直接\n2. 关联\n    如果配置流控规则为关联模式，那么当 关联资源接口超过阈值过后，就会对 配置资源接口触发流控规则（*关联资源本身不受影响*）。\n3. 链路\n\n    设想存在以下业务场景：\n    链路1（接口1 -> 公共资源1）\n    链路2（接口2 -> 公共资源1）\n\n    如果只想对链路1部分的公共资源进行限制，那么需要用到链路模式。\n    >  [链路模式不生效](https://github.com/alibaba/sentinel/issues/1213)\n    >\n    > 如果修改完成不生效，@SentinelResource 注解生效基于SpringAop，那么就看看是否引用方式不对，类似事务注解不生效的场景。解决方式也类似。\n    >\n    所以，我们在设置链路流控规则的时候一定要设置 fallbackFactory。不然无法处理 FlowExecption 异常信息，造成系统出错\n\n#### 流控效果\n\n1. 快速失败  \n    抛出异常\n2. Warm Up\n    流量会被限制到设定QPS/3（coldFactor默认为3），经过设置的预热时间（s）后才达到设定QPS阈值。\n3. 排队等待（用的最多）\n\t丢到队列中异步执行，并设置最大等待时间\n\n#### 熔断规则\n​![image](/images/assets/image-20240226173645-8641hbr.png)​\n\n#### 测试代码支持  \nhttps://github.com/Hugh126/daydayup/tree/master/sentinel\n\n# 四、控制台  \n\n## 控制台使用:  \n\n```json\njava -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.6.jar\n// 如果希望换个端口， 且不希望控制台本身作为一个客户端接入\njava -Dserver.port=8989 -jar sentinel-dashboard-1.8.6.jar\n```\n> 注意： Point有流量请求才会显示在控制台中\n\n## 控制台规则推送模式\n\n[在生产环境中使用 Sentinel · alibaba/Sentinel Wiki (github.com)](https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel#%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E5%8F%8A%E6%8E%A8%E9%80%81)\n\n‍\n\n**Sentinel Dashboard 通过客户端自带的规则 API来实时查询和更改内存中的规则。**\n\n如果使用原始模式，非常的不方便，每次重启服务都把规则搞没了，要重新建立连接、重建规则。==>对接nacos，持久化到nacos，并动态推送\n\n[动态规则扩展 · alibaba/Sentinel Wiki (github.com)](https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95#%E6%8E%A8%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8-nacos-%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99)\n\n‍\n\n## 问题\n\n官方文档有点延迟， 说明也不够清晰。\n\n* 如果需要控制台新建规则持久化到Nacos，则需要对dashboard进行改造。 具体参考：\n\n[https://blog.csdn.net/qq_44870331/article/details/129886930](https://blog.csdn.net/qq_44870331/article/details/129886930)  \n\n\n* 如果只需要从Nacos数据源读取配置：\n\n  ```java\n          ReadableDataSource<String, List<FlowRule>> flowRuleDataSource =\n                  new NacosDataSource<>(\"localhost\", \"DEFAULT_GROUP\", \"test\",\n                  source -> JSON.parseObject(source, new TypeReference<List<FlowRule>>() {}));\n          FlowRuleManager.register2Property(flowRuleDataSource.getProperty());\n  ```\n\n---\n‍\n本人fork了sentinel，并对1.8.6分支进行了改造，可以直接使用支持集成Nacos的控制台：  \n [改造后项目地址](https://github.com/Hugh126/Sentinel/tree/Branch_1.8.6)\n\n‍\n","source":"_posts/分布式限流sentinel.md","raw":"---\ntitle: 分布式限流sentinel\ndate: 2024-04-24 18:00:37\ntags:\n- 限流\n- sentinel\ncategories: 中间件\n---\n单机限流可以采用以令牌桶、漏桶算法为基础的诸多实现，在分布式限流一般使用的是网关产品附带的一些限流功能。而Sentinel，提供了丰富的限流、熔断、降级等功能，更是提供了控制台系统展示、灵活控制这些规则，相当强大！\n<!--more-->\n# 一、限流简述\n限流定义：只允许指定数量的事件进入系统，超出部分将被拒绝服务、排队、降级等处理  \n限流目标： 保证一部分请求流量可以得到正常响应，避免系统雪崩  \n常说的限流，一般是单机限流。单机限流可以通过Guava的RateLimiter来实现，它使用的是令牌桶算法。  \n分布式限流以前使用的是nginx的限流模块，限制并发连接和限制同一IP的访问频次。可是，在实际引用中还远远不够，一般需要通过LUA来加入一些更灵活实用的功能。  \nSentinel作为AlibabaSrpingCloud的一部分，承接了阿里巴巴近10年的双十一大促流量的核心场景，有丰富的应用场景以及监控+开源生态。个人使用来看，个人认为sentinel的优势在于，除了提供全面的限流降级的接入方式，更在于提供了控制台，便于服务本身接入并自动采集Metrics，以及基于Metics（QPS，链路，内存，CPU等）的各类限流熔断，这些才是真实场景中实用的。  \n\n# 二、同类组件对比\n​![image](/images/assets/image-20240425162917-mdlq5qj.png)\n\n\n\n\n# 三、资源与规则\n\n[basic-api-resource-rule | Sentinel (sentinelguard.io)](https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html)\n\n‍\n\n### 定义资源\n\n* [主流框架接入](https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html)\n\n* 使用注解@SentinelResource\n* 自定义定义，包括 抛出异常、布尔值判断、异步异常捕获\n\n  ```java\n  /**\n   ----------1 抛出异常------------------\n  */\n  try (Entry entry = SphU.entry(\"resourceName\")) {\n    // 被保护的业务逻辑\n    // do something here...\n  } catch (BlockException ex) {\n    // 资源访问阻止，被限流或被降级\n    // 在此处进行相应的处理操作\n  }\n\n\n  /**\n    ----------1 布尔值判断------------------\n  */\n    // 资源名可使用任意有业务语义的字符串\n    if (SphO.entry(\"自定义资源名\")) {\n      // 务必保证finally会被执行\n      try {\n        /**\n        * 被保护的业务逻辑\n        */\n      } finally {\n        SphO.exit();\n      }\n    } else {\n      // 资源访问阻止，被限流或被降级\n      // 进行相应的处理操作\n    }\n  ```\n\n‍\n\n### 定义规则\n\n* 流量控制规则 (FlowRule)\n\n  基本场景，可针对QPS、线程数等资源，按照限流策略（直接、链路、关联），达到流控效果（直接拒绝 / 排队等待 / 慢启动模式）。\n* 熔断降级规则 (DegradeRule)\n\n  对于高并发场景的异常接口情况（慢调用比例 异常比例 异常数）进行限制，达到服务降级效果\n* 系统保护规则 (SystemRule)\n\n  结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡\n* 访问控制规则 (AuthorityRule)\n\n  根据调用方来限制资源是否通过，这个更多像一个网关的功能\n* 热点规则 (ParamFlowRule)\n\n  利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。这个针对高并发的细节控制有意想不到效果。\n\n经历过活动高并发的大流量直接把服务挂掉的经验，熔断、系统保护是必要的的，流控最为实用。\n\n‍\n\n#### 流控规则\n\n​![image](/images/assets/image-20240226173616-kau7kcb.png)​\n\n‍\n\n‍\n\n[流控规则详解](https://zhuanlan.zhihu.com/p/439916935)\n\n#### 流控模式\n\n1. 直接\n2. 关联\n    如果配置流控规则为关联模式，那么当 关联资源接口超过阈值过后，就会对 配置资源接口触发流控规则（*关联资源本身不受影响*）。\n3. 链路\n\n    设想存在以下业务场景：\n    链路1（接口1 -> 公共资源1）\n    链路2（接口2 -> 公共资源1）\n\n    如果只想对链路1部分的公共资源进行限制，那么需要用到链路模式。\n    >  [链路模式不生效](https://github.com/alibaba/sentinel/issues/1213)\n    >\n    > 如果修改完成不生效，@SentinelResource 注解生效基于SpringAop，那么就看看是否引用方式不对，类似事务注解不生效的场景。解决方式也类似。\n    >\n    所以，我们在设置链路流控规则的时候一定要设置 fallbackFactory。不然无法处理 FlowExecption 异常信息，造成系统出错\n\n#### 流控效果\n\n1. 快速失败  \n    抛出异常\n2. Warm Up\n    流量会被限制到设定QPS/3（coldFactor默认为3），经过设置的预热时间（s）后才达到设定QPS阈值。\n3. 排队等待（用的最多）\n\t丢到队列中异步执行，并设置最大等待时间\n\n#### 熔断规则\n​![image](/images/assets/image-20240226173645-8641hbr.png)​\n\n#### 测试代码支持  \nhttps://github.com/Hugh126/daydayup/tree/master/sentinel\n\n# 四、控制台  \n\n## 控制台使用:  \n\n```json\njava -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.6.jar\n// 如果希望换个端口， 且不希望控制台本身作为一个客户端接入\njava -Dserver.port=8989 -jar sentinel-dashboard-1.8.6.jar\n```\n> 注意： Point有流量请求才会显示在控制台中\n\n## 控制台规则推送模式\n\n[在生产环境中使用 Sentinel · alibaba/Sentinel Wiki (github.com)](https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel#%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E5%8F%8A%E6%8E%A8%E9%80%81)\n\n‍\n\n**Sentinel Dashboard 通过客户端自带的规则 API来实时查询和更改内存中的规则。**\n\n如果使用原始模式，非常的不方便，每次重启服务都把规则搞没了，要重新建立连接、重建规则。==>对接nacos，持久化到nacos，并动态推送\n\n[动态规则扩展 · alibaba/Sentinel Wiki (github.com)](https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95#%E6%8E%A8%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8-nacos-%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99)\n\n‍\n\n## 问题\n\n官方文档有点延迟， 说明也不够清晰。\n\n* 如果需要控制台新建规则持久化到Nacos，则需要对dashboard进行改造。 具体参考：\n\n[https://blog.csdn.net/qq_44870331/article/details/129886930](https://blog.csdn.net/qq_44870331/article/details/129886930)  \n\n\n* 如果只需要从Nacos数据源读取配置：\n\n  ```java\n          ReadableDataSource<String, List<FlowRule>> flowRuleDataSource =\n                  new NacosDataSource<>(\"localhost\", \"DEFAULT_GROUP\", \"test\",\n                  source -> JSON.parseObject(source, new TypeReference<List<FlowRule>>() {}));\n          FlowRuleManager.register2Property(flowRuleDataSource.getProperty());\n  ```\n\n---\n‍\n本人fork了sentinel，并对1.8.6分支进行了改造，可以直接使用支持集成Nacos的控制台：  \n [改造后项目地址](https://github.com/Hugh126/Sentinel/tree/Branch_1.8.6)\n\n‍\n","slug":"分布式限流sentinel","published":1,"updated":"2024-04-25T08:51:23.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6ozj004hqwvd9hned9zb","content":"<p>单机限流可以采用以令牌桶、漏桶算法为基础的诸多实现，在分布式限流一般使用的是网关产品附带的一些限流功能。而Sentinel，提供了丰富的限流、熔断、降级等功能，更是提供了控制台系统展示、灵活控制这些规则，相当强大！</p>\n<span id=\"more\"></span>\n<h1 id=\"一、限流简述\"><a href=\"#一、限流简述\" class=\"headerlink\" title=\"一、限流简述\"></a>一、限流简述</h1><p>限流定义：只允许指定数量的事件进入系统，超出部分将被拒绝服务、排队、降级等处理<br>限流目标： 保证一部分请求流量可以得到正常响应，避免系统雪崩<br>常说的限流，一般是单机限流。单机限流可以通过Guava的RateLimiter来实现，它使用的是令牌桶算法。<br>分布式限流以前使用的是nginx的限流模块，限制并发连接和限制同一IP的访问频次。可是，在实际引用中还远远不够，一般需要通过LUA来加入一些更灵活实用的功能。<br>Sentinel作为AlibabaSrpingCloud的一部分，承接了阿里巴巴近10年的双十一大促流量的核心场景，有丰富的应用场景以及监控+开源生态。个人使用来看，个人认为sentinel的优势在于，除了提供全面的限流降级的接入方式，更在于提供了控制台，便于服务本身接入并自动采集Metrics，以及基于Metics（QPS，链路，内存，CPU等）的各类限流熔断，这些才是真实场景中实用的。  </p>\n<h1 id=\"二、同类组件对比\"><a href=\"#二、同类组件对比\" class=\"headerlink\" title=\"二、同类组件对比\"></a>二、同类组件对比</h1><p>​<img src=\"/images/assets/image-20240425162917-mdlq5qj.png\" alt=\"image\"></p>\n<h1 id=\"三、资源与规则\"><a href=\"#三、资源与规则\" class=\"headerlink\" title=\"三、资源与规则\"></a>三、资源与规则</h1><p><a href=\"https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html\">basic-api-resource-rule | Sentinel (sentinelguard.io)</a></p>\n<p>‍</p>\n<h3 id=\"定义资源\"><a href=\"#定义资源\" class=\"headerlink\" title=\"定义资源\"></a>定义资源</h3><ul>\n<li><p><a href=\"https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html\">主流框架接入</a></p>\n</li>\n<li><p>使用注解@SentinelResource</p>\n</li>\n<li><p>自定义定义，包括 抛出异常、布尔值判断、异步异常捕获</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> ----------1 抛出异常------------------</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Entry entry = SphU.entry(<span class=\"string\">&quot;resourceName&quot;</span>)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 被保护的业务逻辑</span></span><br><span class=\"line\">  <span class=\"comment\">// do something here...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (BlockException ex) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 资源访问阻止，被限流或被降级</span></span><br><span class=\"line\">  <span class=\"comment\">// 在此处进行相应的处理操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ----------1 布尔值判断------------------</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 资源名可使用任意有业务语义的字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (SphO.entry(<span class=\"string\">&quot;自定义资源名&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 务必保证finally会被执行</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 被保护的业务逻辑</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      SphO.exit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 资源访问阻止，被限流或被降级</span></span><br><span class=\"line\">    <span class=\"comment\">// 进行相应的处理操作</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>‍</p>\n<h3 id=\"定义规则\"><a href=\"#定义规则\" class=\"headerlink\" title=\"定义规则\"></a>定义规则</h3><ul>\n<li><p>流量控制规则 (FlowRule)</p>\n<p>基本场景，可针对QPS、线程数等资源，按照限流策略（直接、链路、关联），达到流控效果（直接拒绝 &#x2F; 排队等待 &#x2F; 慢启动模式）。</p>\n</li>\n<li><p>熔断降级规则 (DegradeRule)</p>\n<p>对于高并发场景的异常接口情况（慢调用比例 异常比例 异常数）进行限制，达到服务降级效果</p>\n</li>\n<li><p>系统保护规则 (SystemRule)</p>\n<p>结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡</p>\n</li>\n<li><p>访问控制规则 (AuthorityRule)</p>\n<p>根据调用方来限制资源是否通过，这个更多像一个网关的功能</p>\n</li>\n<li><p>热点规则 (ParamFlowRule)</p>\n<p>利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。这个针对高并发的细节控制有意想不到效果。</p>\n</li>\n</ul>\n<p>经历过活动高并发的大流量直接把服务挂掉的经验，熔断、系统保护是必要的的，流控最为实用。</p>\n<p>‍</p>\n<h4 id=\"流控规则\"><a href=\"#流控规则\" class=\"headerlink\" title=\"流控规则\"></a>流控规则</h4><p>​<img src=\"/images/assets/image-20240226173616-kau7kcb.png\" alt=\"image\">​</p>\n<p>‍</p>\n<p>‍</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/439916935\">流控规则详解</a></p>\n<h4 id=\"流控模式\"><a href=\"#流控模式\" class=\"headerlink\" title=\"流控模式\"></a>流控模式</h4><ol>\n<li><p>直接</p>\n</li>\n<li><p>关联<br> 如果配置流控规则为关联模式，那么当 关联资源接口超过阈值过后，就会对 配置资源接口触发流控规则（<em>关联资源本身不受影响</em>）。</p>\n</li>\n<li><p>链路</p>\n<p> 设想存在以下业务场景：<br> 链路1（接口1 -&gt; 公共资源1）<br> 链路2（接口2 -&gt; 公共资源1）</p>\n<p> 如果只想对链路1部分的公共资源进行限制，那么需要用到链路模式。</p>\n<blockquote>\n<p> <a href=\"https://github.com/alibaba/sentinel/issues/1213\">链路模式不生效</a></p>\n<p>如果修改完成不生效，@SentinelResource 注解生效基于SpringAop，那么就看看是否引用方式不对，类似事务注解不生效的场景。解决方式也类似。</p>\n</blockquote>\n<p> 所以，我们在设置链路流控规则的时候一定要设置 fallbackFactory。不然无法处理 FlowExecption 异常信息，造成系统出错</p>\n</li>\n</ol>\n<h4 id=\"流控效果\"><a href=\"#流控效果\" class=\"headerlink\" title=\"流控效果\"></a>流控效果</h4><ol>\n<li>快速失败<br> 抛出异常</li>\n<li>Warm Up<br> 流量会被限制到设定QPS&#x2F;3（coldFactor默认为3），经过设置的预热时间（s）后才达到设定QPS阈值。</li>\n<li>排队等待（用的最多）<br> 丢到队列中异步执行，并设置最大等待时间</li>\n</ol>\n<h4 id=\"熔断规则\"><a href=\"#熔断规则\" class=\"headerlink\" title=\"熔断规则\"></a>熔断规则</h4><p>​<img src=\"/images/assets/image-20240226173645-8641hbr.png\" alt=\"image\">​</p>\n<h4 id=\"测试代码支持\"><a href=\"#测试代码支持\" class=\"headerlink\" title=\"测试代码支持\"></a>测试代码支持</h4><p><a href=\"https://github.com/Hugh126/daydayup/tree/master/sentinel\">https://github.com/Hugh126/daydayup/tree/master/sentinel</a></p>\n<h1 id=\"四、控制台\"><a href=\"#四、控制台\" class=\"headerlink\" title=\"四、控制台\"></a>四、控制台</h1><h2 id=\"控制台使用\"><a href=\"#控制台使用\" class=\"headerlink\" title=\"控制台使用:\"></a>控制台使用:</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Dserver.port=<span class=\"number\">8080</span> -Dcsp.sentinel.dashboard.server=localhost:<span class=\"number\">8080</span> -Dproject.name=sentinel-dashboard -jar sentinel-dashboard<span class=\"number\">-1.8</span><span class=\"number\">.6</span>.jar</span><br><span class=\"line\"><span class=\"comment\">// 如果希望换个端口， 且不希望控制台本身作为一个客户端接入</span></span><br><span class=\"line\">java -Dserver.port=<span class=\"number\">8989</span> -jar sentinel-dashboard<span class=\"number\">-1.8</span><span class=\"number\">.6</span>.jar</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意： Point有流量请求才会显示在控制台中</p>\n</blockquote>\n<h2 id=\"控制台规则推送模式\"><a href=\"#控制台规则推送模式\" class=\"headerlink\" title=\"控制台规则推送模式\"></a>控制台规则推送模式</h2><p><a href=\"https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel#%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E5%8F%8A%E6%8E%A8%E9%80%81\">在生产环境中使用 Sentinel · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>\n<p>‍</p>\n<p><strong>Sentinel Dashboard 通过客户端自带的规则 API来实时查询和更改内存中的规则。</strong></p>\n<p>如果使用原始模式，非常的不方便，每次重启服务都把规则搞没了，要重新建立连接、重建规则。&#x3D;&#x3D;&gt;对接nacos，持久化到nacos，并动态推送</p>\n<p><a href=\"https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95#%E6%8E%A8%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8-nacos-%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99\">动态规则扩展 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>\n<p>‍</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>官方文档有点延迟， 说明也不够清晰。</p>\n<ul>\n<li>如果需要控制台新建规则持久化到Nacos，则需要对dashboard进行改造。 具体参考：</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_44870331/article/details/129886930\">https://blog.csdn.net/qq_44870331&#x2F;article&#x2F;details&#x2F;129886930</a>  </p>\n<ul>\n<li><p>如果只需要从Nacos数据源读取配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> NacosDataSource&lt;&gt;(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"string\">&quot;DEFAULT_GROUP&quot;</span>, <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">        source -&gt; JSON.parseObject(source, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class=\"line\">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p>‍<br>本人fork了sentinel，并对1.8.6分支进行了改造，可以直接使用支持集成Nacos的控制台：<br> <a href=\"https://github.com/Hugh126/Sentinel/tree/Branch_1.8.6\">改造后项目地址</a></p>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>单机限流可以采用以令牌桶、漏桶算法为基础的诸多实现，在分布式限流一般使用的是网关产品附带的一些限流功能。而Sentinel，提供了丰富的限流、熔断、降级等功能，更是提供了控制台系统展示、灵活控制这些规则，相当强大！</p>","more":"<h1 id=\"一、限流简述\"><a href=\"#一、限流简述\" class=\"headerlink\" title=\"一、限流简述\"></a>一、限流简述</h1><p>限流定义：只允许指定数量的事件进入系统，超出部分将被拒绝服务、排队、降级等处理<br>限流目标： 保证一部分请求流量可以得到正常响应，避免系统雪崩<br>常说的限流，一般是单机限流。单机限流可以通过Guava的RateLimiter来实现，它使用的是令牌桶算法。<br>分布式限流以前使用的是nginx的限流模块，限制并发连接和限制同一IP的访问频次。可是，在实际引用中还远远不够，一般需要通过LUA来加入一些更灵活实用的功能。<br>Sentinel作为AlibabaSrpingCloud的一部分，承接了阿里巴巴近10年的双十一大促流量的核心场景，有丰富的应用场景以及监控+开源生态。个人使用来看，个人认为sentinel的优势在于，除了提供全面的限流降级的接入方式，更在于提供了控制台，便于服务本身接入并自动采集Metrics，以及基于Metics（QPS，链路，内存，CPU等）的各类限流熔断，这些才是真实场景中实用的。  </p>\n<h1 id=\"二、同类组件对比\"><a href=\"#二、同类组件对比\" class=\"headerlink\" title=\"二、同类组件对比\"></a>二、同类组件对比</h1><p>​<img src=\"/images/assets/image-20240425162917-mdlq5qj.png\" alt=\"image\"></p>\n<h1 id=\"三、资源与规则\"><a href=\"#三、资源与规则\" class=\"headerlink\" title=\"三、资源与规则\"></a>三、资源与规则</h1><p><a href=\"https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html\">basic-api-resource-rule | Sentinel (sentinelguard.io)</a></p>\n<p>‍</p>\n<h3 id=\"定义资源\"><a href=\"#定义资源\" class=\"headerlink\" title=\"定义资源\"></a>定义资源</h3><ul>\n<li><p><a href=\"https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html\">主流框架接入</a></p>\n</li>\n<li><p>使用注解@SentinelResource</p>\n</li>\n<li><p>自定义定义，包括 抛出异常、布尔值判断、异步异常捕获</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> ----------1 抛出异常------------------</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Entry entry = SphU.entry(<span class=\"string\">&quot;resourceName&quot;</span>)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 被保护的业务逻辑</span></span><br><span class=\"line\">  <span class=\"comment\">// do something here...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (BlockException ex) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 资源访问阻止，被限流或被降级</span></span><br><span class=\"line\">  <span class=\"comment\">// 在此处进行相应的处理操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ----------1 布尔值判断------------------</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 资源名可使用任意有业务语义的字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (SphO.entry(<span class=\"string\">&quot;自定义资源名&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 务必保证finally会被执行</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 被保护的业务逻辑</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      SphO.exit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 资源访问阻止，被限流或被降级</span></span><br><span class=\"line\">    <span class=\"comment\">// 进行相应的处理操作</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>‍</p>\n<h3 id=\"定义规则\"><a href=\"#定义规则\" class=\"headerlink\" title=\"定义规则\"></a>定义规则</h3><ul>\n<li><p>流量控制规则 (FlowRule)</p>\n<p>基本场景，可针对QPS、线程数等资源，按照限流策略（直接、链路、关联），达到流控效果（直接拒绝 &#x2F; 排队等待 &#x2F; 慢启动模式）。</p>\n</li>\n<li><p>熔断降级规则 (DegradeRule)</p>\n<p>对于高并发场景的异常接口情况（慢调用比例 异常比例 异常数）进行限制，达到服务降级效果</p>\n</li>\n<li><p>系统保护规则 (SystemRule)</p>\n<p>结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡</p>\n</li>\n<li><p>访问控制规则 (AuthorityRule)</p>\n<p>根据调用方来限制资源是否通过，这个更多像一个网关的功能</p>\n</li>\n<li><p>热点规则 (ParamFlowRule)</p>\n<p>利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。这个针对高并发的细节控制有意想不到效果。</p>\n</li>\n</ul>\n<p>经历过活动高并发的大流量直接把服务挂掉的经验，熔断、系统保护是必要的的，流控最为实用。</p>\n<p>‍</p>\n<h4 id=\"流控规则\"><a href=\"#流控规则\" class=\"headerlink\" title=\"流控规则\"></a>流控规则</h4><p>​<img src=\"/images/assets/image-20240226173616-kau7kcb.png\" alt=\"image\">​</p>\n<p>‍</p>\n<p>‍</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/439916935\">流控规则详解</a></p>\n<h4 id=\"流控模式\"><a href=\"#流控模式\" class=\"headerlink\" title=\"流控模式\"></a>流控模式</h4><ol>\n<li><p>直接</p>\n</li>\n<li><p>关联<br> 如果配置流控规则为关联模式，那么当 关联资源接口超过阈值过后，就会对 配置资源接口触发流控规则（<em>关联资源本身不受影响</em>）。</p>\n</li>\n<li><p>链路</p>\n<p> 设想存在以下业务场景：<br> 链路1（接口1 -&gt; 公共资源1）<br> 链路2（接口2 -&gt; 公共资源1）</p>\n<p> 如果只想对链路1部分的公共资源进行限制，那么需要用到链路模式。</p>\n<blockquote>\n<p> <a href=\"https://github.com/alibaba/sentinel/issues/1213\">链路模式不生效</a></p>\n<p>如果修改完成不生效，@SentinelResource 注解生效基于SpringAop，那么就看看是否引用方式不对，类似事务注解不生效的场景。解决方式也类似。</p>\n</blockquote>\n<p> 所以，我们在设置链路流控规则的时候一定要设置 fallbackFactory。不然无法处理 FlowExecption 异常信息，造成系统出错</p>\n</li>\n</ol>\n<h4 id=\"流控效果\"><a href=\"#流控效果\" class=\"headerlink\" title=\"流控效果\"></a>流控效果</h4><ol>\n<li>快速失败<br> 抛出异常</li>\n<li>Warm Up<br> 流量会被限制到设定QPS&#x2F;3（coldFactor默认为3），经过设置的预热时间（s）后才达到设定QPS阈值。</li>\n<li>排队等待（用的最多）<br> 丢到队列中异步执行，并设置最大等待时间</li>\n</ol>\n<h4 id=\"熔断规则\"><a href=\"#熔断规则\" class=\"headerlink\" title=\"熔断规则\"></a>熔断规则</h4><p>​<img src=\"/images/assets/image-20240226173645-8641hbr.png\" alt=\"image\">​</p>\n<h4 id=\"测试代码支持\"><a href=\"#测试代码支持\" class=\"headerlink\" title=\"测试代码支持\"></a>测试代码支持</h4><p><a href=\"https://github.com/Hugh126/daydayup/tree/master/sentinel\">https://github.com/Hugh126/daydayup/tree/master/sentinel</a></p>\n<h1 id=\"四、控制台\"><a href=\"#四、控制台\" class=\"headerlink\" title=\"四、控制台\"></a>四、控制台</h1><h2 id=\"控制台使用\"><a href=\"#控制台使用\" class=\"headerlink\" title=\"控制台使用:\"></a>控制台使用:</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Dserver.port=<span class=\"number\">8080</span> -Dcsp.sentinel.dashboard.server=localhost:<span class=\"number\">8080</span> -Dproject.name=sentinel-dashboard -jar sentinel-dashboard<span class=\"number\">-1.8</span><span class=\"number\">.6</span>.jar</span><br><span class=\"line\"><span class=\"comment\">// 如果希望换个端口， 且不希望控制台本身作为一个客户端接入</span></span><br><span class=\"line\">java -Dserver.port=<span class=\"number\">8989</span> -jar sentinel-dashboard<span class=\"number\">-1.8</span><span class=\"number\">.6</span>.jar</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意： Point有流量请求才会显示在控制台中</p>\n</blockquote>\n<h2 id=\"控制台规则推送模式\"><a href=\"#控制台规则推送模式\" class=\"headerlink\" title=\"控制台规则推送模式\"></a>控制台规则推送模式</h2><p><a href=\"https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel#%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E5%8F%8A%E6%8E%A8%E9%80%81\">在生产环境中使用 Sentinel · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>\n<p>‍</p>\n<p><strong>Sentinel Dashboard 通过客户端自带的规则 API来实时查询和更改内存中的规则。</strong></p>\n<p>如果使用原始模式，非常的不方便，每次重启服务都把规则搞没了，要重新建立连接、重建规则。&#x3D;&#x3D;&gt;对接nacos，持久化到nacos，并动态推送</p>\n<p><a href=\"https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95#%E6%8E%A8%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8-nacos-%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99\">动态规则扩展 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>\n<p>‍</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>官方文档有点延迟， 说明也不够清晰。</p>\n<ul>\n<li>如果需要控制台新建规则持久化到Nacos，则需要对dashboard进行改造。 具体参考：</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_44870331/article/details/129886930\">https://blog.csdn.net/qq_44870331&#x2F;article&#x2F;details&#x2F;129886930</a>  </p>\n<ul>\n<li><p>如果只需要从Nacos数据源读取配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> NacosDataSource&lt;&gt;(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"string\">&quot;DEFAULT_GROUP&quot;</span>, <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">        source -&gt; JSON.parseObject(source, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class=\"line\">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p>‍<br>本人fork了sentinel，并对1.8.6分支进行了改造，可以直接使用支持集成Nacos的控制台：<br> <a href=\"https://github.com/Hugh126/Sentinel/tree/Branch_1.8.6\">改造后项目地址</a></p>\n<p>‍</p>"},{"title":"压力测试","date":"2023-06-29T07:22:59.000Z","comments":1,"_content":"作为后端/架构人员，在技术选型、服务架构设计的时候，或是造完一个轮子的时候，总是想尝试下极限在哪。此刻压测必不可少，此文介绍各种常见压测工具优缺点，也记录下基本用法。\n<!--more-->\n\n# 序\n先说下结论\n---\n- 对于并发测试，首推Jmeter。原因：功能强大、可视化、速度很快。熟悉ab工具的，也可以使用ab，一行命令就搞定。 \n- 对于数据库测试，必用sysbench。原因：功能强大，可扩展，还可以造数据。`注意：不支持windows`  \n- 对于复杂一点的测试，很难找到现成工具，那就自己造轮子吧\n> 有人会说postman也可以测试，还支持前置脚本。其实那不是并发，而且也没有汇总结果。再说下国产新的`Apifox`，搜索Jmeter居然出来的是它，而且广告做的到处都是。我最近的测试首先就用了它，结果大失所望，功能配置好像是很强大的，集成了很多。可是，太慢了...可能，这也是国产软件的通病。  \n\n\n# 一、Jmeter\n[Jmeter](https://jmeter.apache.org)Jmeter是由Apache公司开发的一个纯Java的开源项目，即可以用于做接口测试也可以用于做性能测试。  \n\n## 1.1 安装使用步骤  \n[参考](https://zhuanlan.zhihu.com/p/142897766)  \n    基本使用步骤：\n    1. 测试计划 -> 添加 -> 线程（用户）-> 线程组\n    2. 线程组 -> 添加 -> 取样器 -> HTTP请求\n    3. HTTP请求 -> 添加 -> 监听器 -> 查看结果树\n    4. HTTP请求 -> 添加 -> 监听器 -> 汇总报告 \n\n## 1.2 汇总报告\n**汇总报告结果默认时间单位是ms**\n\n[Jmeter性能指标分析参考](https://developer.aliyun.com/article/797451)  \n\n\n# 二、Apache Benchmark\nApache 出品的一个 HTTP 服务器性能测试工具。使用它可以测试每秒请求数、吞吐率等参数。  \n\n## 2.1 基本用法  \n``` cmd\n# -c  设定并发数，默认并发数是 1\n# -n  设定压测的请求总数\n# -t  设定压测的时长，单位是秒\nab -c 10 -n 1000 http://example.com\n```\n\n## 2.2 汇总结果\n主要看两个参数`Requests per second`和`Percentage of the request`吧   \n[使用参考](https://blog.csdn.net/u011585609/article/details/104821068)\n\n\n# 三、sysbench\n## 3.1 简介\nsysbench内置的测试项包括内存/CPU/线程/事务/互斥锁，但是一般用来做数据库的测试。 它是全开源的`lua`写的，各种测试运行都基于lua脚本，可以很便捷的扩展。  \n它主要是三个阶段：  \nprepare（准备数据）/ run（执行测试）/ clean（清理测试数据）  \n\n## 3.2 基本使用 \n例如你只是想测试下新搭建的mysql集群读写性能，你可以：\n``` lua\n# 准备数据：创建5个表，每个表100条数据\nsysbench /usr/share/sysbench/oltp_read_write.lua --tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test prepare\n# 使用的线程数量为16个，使用的存储引擎为InnoDB，测试事务运行\nsysbench  --num-threads=16 --test=oltp --mysql-table-engine=innodb --tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test run\n```\n\n## 3.2 进阶\n可以发现，准备阶段给我们生成的测试数据结构是固定的。如果我们想更贴切地模拟想要测试的内容，可以像上一段中使用的LUA脚本地址：`/usr/share/sysbench/oltp_read_write.lua`。这个是自带的lua脚本，也可以自定义一套。  \n\n\n[sysbench使用参考](https://www.cnblogs.com/tangbinghaochi/p/6292905.html)\n\n# 四、java.jdk.concurrent\njdk并发包下有很多工具也可以实现并发请求，对于一些需要构造数据或有特定步骤的复杂测试，自己编码反而更为便利。这里以`CountDownLatch`为例：\n``` java\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Function<Integer, Thread> supplier = index -> (new Thread(()-> {\n            try {\n                countDownLatch.await();\n                // do something\n                log.warn(Thread.currentThread().getName() + \" : index \" + index + \" done\" );\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }));\n        IntStream.range(1, 11).mapToObj(x -> supplier.apply(x)).forEach(executorService::submit);\n        countDownLatch.countDown();\n        while (!executorService.awaitTermination(200L,TimeUnit.MILLISECONDS)) {\n            executorService.shutdown();\n        }\n```\n\n\n","source":"_posts/压力测试.md","raw":"---\ntitle: 压力测试\ndate: 2023-06-29 15:22:59\ncomments: true\ntags:\n- 压力测试\ncategories: 其他\n---\n作为后端/架构人员，在技术选型、服务架构设计的时候，或是造完一个轮子的时候，总是想尝试下极限在哪。此刻压测必不可少，此文介绍各种常见压测工具优缺点，也记录下基本用法。\n<!--more-->\n\n# 序\n先说下结论\n---\n- 对于并发测试，首推Jmeter。原因：功能强大、可视化、速度很快。熟悉ab工具的，也可以使用ab，一行命令就搞定。 \n- 对于数据库测试，必用sysbench。原因：功能强大，可扩展，还可以造数据。`注意：不支持windows`  \n- 对于复杂一点的测试，很难找到现成工具，那就自己造轮子吧\n> 有人会说postman也可以测试，还支持前置脚本。其实那不是并发，而且也没有汇总结果。再说下国产新的`Apifox`，搜索Jmeter居然出来的是它，而且广告做的到处都是。我最近的测试首先就用了它，结果大失所望，功能配置好像是很强大的，集成了很多。可是，太慢了...可能，这也是国产软件的通病。  \n\n\n# 一、Jmeter\n[Jmeter](https://jmeter.apache.org)Jmeter是由Apache公司开发的一个纯Java的开源项目，即可以用于做接口测试也可以用于做性能测试。  \n\n## 1.1 安装使用步骤  \n[参考](https://zhuanlan.zhihu.com/p/142897766)  \n    基本使用步骤：\n    1. 测试计划 -> 添加 -> 线程（用户）-> 线程组\n    2. 线程组 -> 添加 -> 取样器 -> HTTP请求\n    3. HTTP请求 -> 添加 -> 监听器 -> 查看结果树\n    4. HTTP请求 -> 添加 -> 监听器 -> 汇总报告 \n\n## 1.2 汇总报告\n**汇总报告结果默认时间单位是ms**\n\n[Jmeter性能指标分析参考](https://developer.aliyun.com/article/797451)  \n\n\n# 二、Apache Benchmark\nApache 出品的一个 HTTP 服务器性能测试工具。使用它可以测试每秒请求数、吞吐率等参数。  \n\n## 2.1 基本用法  \n``` cmd\n# -c  设定并发数，默认并发数是 1\n# -n  设定压测的请求总数\n# -t  设定压测的时长，单位是秒\nab -c 10 -n 1000 http://example.com\n```\n\n## 2.2 汇总结果\n主要看两个参数`Requests per second`和`Percentage of the request`吧   \n[使用参考](https://blog.csdn.net/u011585609/article/details/104821068)\n\n\n# 三、sysbench\n## 3.1 简介\nsysbench内置的测试项包括内存/CPU/线程/事务/互斥锁，但是一般用来做数据库的测试。 它是全开源的`lua`写的，各种测试运行都基于lua脚本，可以很便捷的扩展。  \n它主要是三个阶段：  \nprepare（准备数据）/ run（执行测试）/ clean（清理测试数据）  \n\n## 3.2 基本使用 \n例如你只是想测试下新搭建的mysql集群读写性能，你可以：\n``` lua\n# 准备数据：创建5个表，每个表100条数据\nsysbench /usr/share/sysbench/oltp_read_write.lua --tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test prepare\n# 使用的线程数量为16个，使用的存储引擎为InnoDB，测试事务运行\nsysbench  --num-threads=16 --test=oltp --mysql-table-engine=innodb --tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test run\n```\n\n## 3.2 进阶\n可以发现，准备阶段给我们生成的测试数据结构是固定的。如果我们想更贴切地模拟想要测试的内容，可以像上一段中使用的LUA脚本地址：`/usr/share/sysbench/oltp_read_write.lua`。这个是自带的lua脚本，也可以自定义一套。  \n\n\n[sysbench使用参考](https://www.cnblogs.com/tangbinghaochi/p/6292905.html)\n\n# 四、java.jdk.concurrent\njdk并发包下有很多工具也可以实现并发请求，对于一些需要构造数据或有特定步骤的复杂测试，自己编码反而更为便利。这里以`CountDownLatch`为例：\n``` java\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Function<Integer, Thread> supplier = index -> (new Thread(()-> {\n            try {\n                countDownLatch.await();\n                // do something\n                log.warn(Thread.currentThread().getName() + \" : index \" + index + \" done\" );\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }));\n        IntStream.range(1, 11).mapToObj(x -> supplier.apply(x)).forEach(executorService::submit);\n        countDownLatch.countDown();\n        while (!executorService.awaitTermination(200L,TimeUnit.MILLISECONDS)) {\n            executorService.shutdown();\n        }\n```\n\n\n","slug":"压力测试","published":1,"updated":"2024-04-11T03:37:57.898Z","layout":"post","photos":[],"link":"","_id":"clw5r6ozk004jqwvdg0go4eed","content":"<p>作为后端&#x2F;架构人员，在技术选型、服务架构设计的时候，或是造完一个轮子的时候，总是想尝试下极限在哪。此刻压测必不可少，此文介绍各种常见压测工具优缺点，也记录下基本用法。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><h2 id=\"先说下结论\"><a href=\"#先说下结论\" class=\"headerlink\" title=\"先说下结论\"></a>先说下结论</h2><ul>\n<li>对于并发测试，首推Jmeter。原因：功能强大、可视化、速度很快。熟悉ab工具的，也可以使用ab，一行命令就搞定。 </li>\n<li>对于数据库测试，必用sysbench。原因：功能强大，可扩展，还可以造数据。<code>注意：不支持windows</code>  </li>\n<li>对于复杂一点的测试，很难找到现成工具，那就自己造轮子吧<blockquote>\n<p>有人会说postman也可以测试，还支持前置脚本。其实那不是并发，而且也没有汇总结果。再说下国产新的<code>Apifox</code>，搜索Jmeter居然出来的是它，而且广告做的到处都是。我最近的测试首先就用了它，结果大失所望，功能配置好像是很强大的，集成了很多。可是，太慢了…可能，这也是国产软件的通病。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"一、Jmeter\"><a href=\"#一、Jmeter\" class=\"headerlink\" title=\"一、Jmeter\"></a>一、Jmeter</h1><p><a href=\"https://jmeter.apache.org/\">Jmeter</a>Jmeter是由Apache公司开发的一个纯Java的开源项目，即可以用于做接口测试也可以用于做性能测试。  </p>\n<h2 id=\"1-1-安装使用步骤\"><a href=\"#1-1-安装使用步骤\" class=\"headerlink\" title=\"1.1 安装使用步骤\"></a>1.1 安装使用步骤</h2><p><a href=\"https://zhuanlan.zhihu.com/p/142897766\">参考</a><br>    基本使用步骤：<br>    1. 测试计划 -&gt; 添加 -&gt; 线程（用户）-&gt; 线程组<br>    2. 线程组 -&gt; 添加 -&gt; 取样器 -&gt; HTTP请求<br>    3. HTTP请求 -&gt; 添加 -&gt; 监听器 -&gt; 查看结果树<br>    4. HTTP请求 -&gt; 添加 -&gt; 监听器 -&gt; 汇总报告 </p>\n<h2 id=\"1-2-汇总报告\"><a href=\"#1-2-汇总报告\" class=\"headerlink\" title=\"1.2 汇总报告\"></a>1.2 汇总报告</h2><p><strong>汇总报告结果默认时间单位是ms</strong></p>\n<p><a href=\"https://developer.aliyun.com/article/797451\">Jmeter性能指标分析参考</a>  </p>\n<h1 id=\"二、Apache-Benchmark\"><a href=\"#二、Apache-Benchmark\" class=\"headerlink\" title=\"二、Apache Benchmark\"></a>二、Apache Benchmark</h1><p>Apache 出品的一个 HTTP 服务器性能测试工具。使用它可以测试每秒请求数、吞吐率等参数。  </p>\n<h2 id=\"2-1-基本用法\"><a href=\"#2-1-基本用法\" class=\"headerlink\" title=\"2.1 基本用法\"></a>2.1 基本用法</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -c  设定并发数，默认并发数是 <span class=\"number\">1</span></span><br><span class=\"line\"># -n  设定压测的请求总数</span><br><span class=\"line\"># -t  设定压测的时长，单位是秒</span><br><span class=\"line\">ab -c <span class=\"number\">10</span> -n <span class=\"number\">1000</span> http://example.com</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-汇总结果\"><a href=\"#2-2-汇总结果\" class=\"headerlink\" title=\"2.2 汇总结果\"></a>2.2 汇总结果</h2><p>主要看两个参数<code>Requests per second</code>和<code>Percentage of the request</code>吧<br><a href=\"https://blog.csdn.net/u011585609/article/details/104821068\">使用参考</a></p>\n<h1 id=\"三、sysbench\"><a href=\"#三、sysbench\" class=\"headerlink\" title=\"三、sysbench\"></a>三、sysbench</h1><h2 id=\"3-1-简介\"><a href=\"#3-1-简介\" class=\"headerlink\" title=\"3.1 简介\"></a>3.1 简介</h2><p>sysbench内置的测试项包括内存&#x2F;CPU&#x2F;线程&#x2F;事务&#x2F;互斥锁，但是一般用来做数据库的测试。 它是全开源的<code>lua</code>写的，各种测试运行都基于lua脚本，可以很便捷的扩展。<br>它主要是三个阶段：<br>prepare（准备数据）&#x2F; run（执行测试）&#x2F; clean（清理测试数据）  </p>\n<h2 id=\"3-2-基本使用\"><a href=\"#3-2-基本使用\" class=\"headerlink\" title=\"3.2 基本使用\"></a>3.2 基本使用</h2><p>例如你只是想测试下新搭建的mysql集群读写性能，你可以：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 准备数据：创建<span class=\"number\">5</span>个表，每个表<span class=\"number\">100</span>条数据</span><br><span class=\"line\">sysbench /usr/share/sysbench/oltp_read_write.lua <span class=\"comment\">--tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test prepare</span></span><br><span class=\"line\"># 使用的线程数量为<span class=\"number\">16</span>个，使用的存储引擎为InnoDB，测试事务运行</span><br><span class=\"line\">sysbench  <span class=\"comment\">--num-threads=16 --test=oltp --mysql-table-engine=innodb --tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test run</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-进阶\"><a href=\"#3-2-进阶\" class=\"headerlink\" title=\"3.2 进阶\"></a>3.2 进阶</h2><p>可以发现，准备阶段给我们生成的测试数据结构是固定的。如果我们想更贴切地模拟想要测试的内容，可以像上一段中使用的LUA脚本地址：<code>/usr/share/sysbench/oltp_read_write.lua</code>。这个是自带的lua脚本，也可以自定义一套。  </p>\n<p><a href=\"https://www.cnblogs.com/tangbinghaochi/p/6292905.html\">sysbench使用参考</a></p>\n<h1 id=\"四、java-jdk-concurrent\"><a href=\"#四、java-jdk-concurrent\" class=\"headerlink\" title=\"四、java.jdk.concurrent\"></a>四、java.jdk.concurrent</h1><p>jdk并发包下有很多工具也可以实现并发请求，对于一些需要构造数据或有特定步骤的复杂测试，自己编码反而更为便利。这里以<code>CountDownLatch</code>为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">Function&lt;Integer, Thread&gt; supplier = index -&gt; (<span class=\"keyword\">new</span> Thread(()-&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">        log.warn(Thread.currentThread().getName() + <span class=\"string\">&quot; : index &quot;</span> + index + <span class=\"string\">&quot; done&quot;</span> );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">IntStream.range(<span class=\"number\">1</span>, <span class=\"number\">11</span>).mapToObj(x -&gt; supplier.apply(x)).forEach(executorService::submit);</span><br><span class=\"line\">countDownLatch.countDown();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!executorService.awaitTermination(<span class=\"number\">200L</span>,TimeUnit.MILLISECONDS)) &#123;</span><br><span class=\"line\">    executorService.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"<p>作为后端&#x2F;架构人员，在技术选型、服务架构设计的时候，或是造完一个轮子的时候，总是想尝试下极限在哪。此刻压测必不可少，此文介绍各种常见压测工具优缺点，也记录下基本用法。</p>","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><h2 id=\"先说下结论\"><a href=\"#先说下结论\" class=\"headerlink\" title=\"先说下结论\"></a>先说下结论</h2><ul>\n<li>对于并发测试，首推Jmeter。原因：功能强大、可视化、速度很快。熟悉ab工具的，也可以使用ab，一行命令就搞定。 </li>\n<li>对于数据库测试，必用sysbench。原因：功能强大，可扩展，还可以造数据。<code>注意：不支持windows</code>  </li>\n<li>对于复杂一点的测试，很难找到现成工具，那就自己造轮子吧<blockquote>\n<p>有人会说postman也可以测试，还支持前置脚本。其实那不是并发，而且也没有汇总结果。再说下国产新的<code>Apifox</code>，搜索Jmeter居然出来的是它，而且广告做的到处都是。我最近的测试首先就用了它，结果大失所望，功能配置好像是很强大的，集成了很多。可是，太慢了…可能，这也是国产软件的通病。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"一、Jmeter\"><a href=\"#一、Jmeter\" class=\"headerlink\" title=\"一、Jmeter\"></a>一、Jmeter</h1><p><a href=\"https://jmeter.apache.org/\">Jmeter</a>Jmeter是由Apache公司开发的一个纯Java的开源项目，即可以用于做接口测试也可以用于做性能测试。  </p>\n<h2 id=\"1-1-安装使用步骤\"><a href=\"#1-1-安装使用步骤\" class=\"headerlink\" title=\"1.1 安装使用步骤\"></a>1.1 安装使用步骤</h2><p><a href=\"https://zhuanlan.zhihu.com/p/142897766\">参考</a><br>    基本使用步骤：<br>    1. 测试计划 -&gt; 添加 -&gt; 线程（用户）-&gt; 线程组<br>    2. 线程组 -&gt; 添加 -&gt; 取样器 -&gt; HTTP请求<br>    3. HTTP请求 -&gt; 添加 -&gt; 监听器 -&gt; 查看结果树<br>    4. HTTP请求 -&gt; 添加 -&gt; 监听器 -&gt; 汇总报告 </p>\n<h2 id=\"1-2-汇总报告\"><a href=\"#1-2-汇总报告\" class=\"headerlink\" title=\"1.2 汇总报告\"></a>1.2 汇总报告</h2><p><strong>汇总报告结果默认时间单位是ms</strong></p>\n<p><a href=\"https://developer.aliyun.com/article/797451\">Jmeter性能指标分析参考</a>  </p>\n<h1 id=\"二、Apache-Benchmark\"><a href=\"#二、Apache-Benchmark\" class=\"headerlink\" title=\"二、Apache Benchmark\"></a>二、Apache Benchmark</h1><p>Apache 出品的一个 HTTP 服务器性能测试工具。使用它可以测试每秒请求数、吞吐率等参数。  </p>\n<h2 id=\"2-1-基本用法\"><a href=\"#2-1-基本用法\" class=\"headerlink\" title=\"2.1 基本用法\"></a>2.1 基本用法</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -c  设定并发数，默认并发数是 <span class=\"number\">1</span></span><br><span class=\"line\"># -n  设定压测的请求总数</span><br><span class=\"line\"># -t  设定压测的时长，单位是秒</span><br><span class=\"line\">ab -c <span class=\"number\">10</span> -n <span class=\"number\">1000</span> http://example.com</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-汇总结果\"><a href=\"#2-2-汇总结果\" class=\"headerlink\" title=\"2.2 汇总结果\"></a>2.2 汇总结果</h2><p>主要看两个参数<code>Requests per second</code>和<code>Percentage of the request</code>吧<br><a href=\"https://blog.csdn.net/u011585609/article/details/104821068\">使用参考</a></p>\n<h1 id=\"三、sysbench\"><a href=\"#三、sysbench\" class=\"headerlink\" title=\"三、sysbench\"></a>三、sysbench</h1><h2 id=\"3-1-简介\"><a href=\"#3-1-简介\" class=\"headerlink\" title=\"3.1 简介\"></a>3.1 简介</h2><p>sysbench内置的测试项包括内存&#x2F;CPU&#x2F;线程&#x2F;事务&#x2F;互斥锁，但是一般用来做数据库的测试。 它是全开源的<code>lua</code>写的，各种测试运行都基于lua脚本，可以很便捷的扩展。<br>它主要是三个阶段：<br>prepare（准备数据）&#x2F; run（执行测试）&#x2F; clean（清理测试数据）  </p>\n<h2 id=\"3-2-基本使用\"><a href=\"#3-2-基本使用\" class=\"headerlink\" title=\"3.2 基本使用\"></a>3.2 基本使用</h2><p>例如你只是想测试下新搭建的mysql集群读写性能，你可以：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 准备数据：创建<span class=\"number\">5</span>个表，每个表<span class=\"number\">100</span>条数据</span><br><span class=\"line\">sysbench /usr/share/sysbench/oltp_read_write.lua <span class=\"comment\">--tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test prepare</span></span><br><span class=\"line\"># 使用的线程数量为<span class=\"number\">16</span>个，使用的存储引擎为InnoDB，测试事务运行</span><br><span class=\"line\">sysbench  <span class=\"comment\">--num-threads=16 --test=oltp --mysql-table-engine=innodb --tables=5 --table_size=100 --mysql-user=root --mysql-password=xxx --mysql-host=192.168.0.103 --mysql-port=3306 --mysql-db=sysbench_test run</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-进阶\"><a href=\"#3-2-进阶\" class=\"headerlink\" title=\"3.2 进阶\"></a>3.2 进阶</h2><p>可以发现，准备阶段给我们生成的测试数据结构是固定的。如果我们想更贴切地模拟想要测试的内容，可以像上一段中使用的LUA脚本地址：<code>/usr/share/sysbench/oltp_read_write.lua</code>。这个是自带的lua脚本，也可以自定义一套。  </p>\n<p><a href=\"https://www.cnblogs.com/tangbinghaochi/p/6292905.html\">sysbench使用参考</a></p>\n<h1 id=\"四、java-jdk-concurrent\"><a href=\"#四、java-jdk-concurrent\" class=\"headerlink\" title=\"四、java.jdk.concurrent\"></a>四、java.jdk.concurrent</h1><p>jdk并发包下有很多工具也可以实现并发请求，对于一些需要构造数据或有特定步骤的复杂测试，自己编码反而更为便利。这里以<code>CountDownLatch</code>为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">Function&lt;Integer, Thread&gt; supplier = index -&gt; (<span class=\"keyword\">new</span> Thread(()-&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">        log.warn(Thread.currentThread().getName() + <span class=\"string\">&quot; : index &quot;</span> + index + <span class=\"string\">&quot; done&quot;</span> );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">IntStream.range(<span class=\"number\">1</span>, <span class=\"number\">11</span>).mapToObj(x -&gt; supplier.apply(x)).forEach(executorService::submit);</span><br><span class=\"line\">countDownLatch.countDown();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!executorService.awaitTermination(<span class=\"number\">200L</span>,TimeUnit.MILLISECONDS)) &#123;</span><br><span class=\"line\">    executorService.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"理解服务端推送与实践","date":"2023-07-10T07:40:53.000Z","_content":"在Web开发的时候，通常会需要服务端向客户端推送消息。技术选型可以选择Comet（基于Ajax或HTTP流）、SSE(Server-sent Events, 只能是服务端推送)、Websocket（应用于浏览器Socket，基于TCP的双向通信协议），但随着Websocket在浏览器中的广泛支持，一般首推Websocket，如果只有服务端推送的需求可以选用SSE,在古老的浏览器环境中才选用Comet或通过ajax轮询。\n<!--more-->\n\n# 一、Comet\nComet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求，目前有两种实现方式，长轮询和iframe流。  \n- 长轮询  \n长轮询不是长链接，是在打开一条连接以后保持，等待服务器推送来数据再关闭的方式。长轮询的实现需要借助异步请求来实现，比如`AsyncContext`或`DeferredResult`。  \nServlet3.0就引入了[异步上下文](https://zhuanlan.zhihu.com/p/121801714),只是大家使用的较少。关于长轮询，并不是什么过时的技术，现在的配置中心(Nacos和Apollo)使用的就是[长轮询来实现推送](https://zhuanlan.zhihu.com/p/351196920)。  \nDeferredResult使用示例：  \n``` java\n@RequestMapping(\"/polling\")\n@RestController\npublic class PollingController {\n\n    private final static Multimap<Integer, DeferredResult<String>> watchRequestMap = Multimaps.synchronizedMultimap(HashMultimap.create());\n    private static final Long TIME_OUT = 60000L;\n\n    @RequestMapping(\"watch/{id}\")\n    public DeferredResult<String> watch(@PathVariable Integer id) {\n        DeferredResult<String> result = new DeferredResult<>(TIME_OUT);\n        result.onTimeout(() -> {\n            System.err.println(\"Task time out.\");\n        });\n        result.onCompletion(() -> {\n            watchRequestMap.remove(id, result);\n        });\n        watchRequestMap.put(id, result);\n        return result;\n    }\n\n\n    @RequestMapping(\"publish/{id}\")\n    public void publish(@PathVariable Integer id) {\n        Collection<DeferredResult<String>> deferredResults = watchRequestMap.get(id);\n        deferredResults.forEach(item -> {\n            item.setResult(String.format(\"id=%d于%s更新完成\", id, DateUtil.now()));\n        });\n    }\n}\n```\n- iframe流  \niframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长链接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript,例如`<script type=\\\"text/javascript\\\">...</script>`），来实时更新页面。iframe流方式的优点是浏览器兼容好，Google公司在一些产品中使用了iframe流，如Google Talk。  \n\n\n# 二、SSE\nSSE其实就是基于comet搞出来一套规范的API，被纳入到HTML5规范，使用起来相对更简单了。  \n## SSE 客户端  \n\n浏览器端主要是[EventSource](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource)的使用：  \n\n附带一份SSE Demo的前端代码:  \n\n``` js\n    if (window.EventSource == null) {\n        alert('The browser does not support Server-Sent Events');\n    }else{\n        var source = new EventSource('http://localhost:8381/sse/subscribe?id=data001');\n        source.onmessage = function (event) {\n            refreshByData(event.data);\n        };\n        source.onopen = function (event) {\n            refreshByData('连接成功');\n        };\n        source.addEventListener(\"close\", (event) => {\n            source.close();\n            refreshByData('连接关闭');\n        });\n    }\n\n    function refreshByData(data) {\n        var text = document.getElementById('result').innerText;\n        text += '\\n' + data;\n        document.getElementById('result').innerText = text;\n    }\n```\n\n## SSE 服务端\n可以通过Spring自带的`SseEmitter`完成，主要是帮我们更容易实现SSE的协议:请求头和body格式。即必须有以下headers:  \n``` html\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n然后内容可以是以下几个，以`:`开头，以`\\n`分隔：  \n``` html\ndata\nevent\nid\nretry\n```\n> 注意:  \n    1. event即自定义监听事件类型，不传则为`message`  \n    2. `data`必传且不可为空\n附带一份SSE Demo的服务端代码：\n``` java\n@ResponseBody\n    @GetMapping(path = \"subscribe\", produces = {MediaType.TEXT_EVENT_STREAM_VALUE})\n    public SseEmitter push(String id) throws IOException {\n        SseEmitter sseEmitter = new SseEmitter(60000L);\n        sseEmitter.onCompletion(() -> log.warn(\"[推送完成]\"));\n        new Thread(() -> {\n            IntStream.range(1, 10).forEach(n -> {\n                try {\n                    sseEmitter.send(SseEmitter.event().data(\"推送消息 : \" + n ));\n                    TimeUnit.MILLISECONDS.sleep(500L);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            });\n\n            try {\n                // 注意消息的data是必须填的，也不能为空\n                sseEmitter.send(SseEmitter.event().name(\"close\").data(\"--anything but no null--\"));\n                // 这里完全不是关闭，只是清空异步响应DeferredResult\n                sseEmitter.complete();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }).start();\n        return sseEmitter;\n    }\n```\n附带谷歌浏览器中的`EventStream`信息：  \n![](/images/SSE浏览器请求.png)\n## SSE避坑指南\n1. 看了几篇blog，都没提及SSE中http流的关闭。不处理的话，看请求就是会不断的重连。流关闭是由客户端发起，调用close方法，但是内容由服务端发送，客户端肯定不知道啊，只能是服务端发送一个结束事件来触发。也可以是特定消息，由onmessage中判断。  \n\n2. 浏览器有个不可突破的限制，就是SSE请求同事只能有6个（基于HTTP1.1）。详见:https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource  \n\n# 三、WebSocket  \n\n## websocket协议\nwebsocket其实是一种双向通信协议，它是基于TCP协议的。有人说他是独立于HTTP的，并不准确，它握手使用的是HTTP的[协议升级机制](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism)，而后数据传输使用的才是websocket协议。  \n相较于HTTP协议，它的优势在于它支持[交换数据帧](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)（客户端或服务端都可以在任何时间点发送数据），实现了双向通信。因此，SSE能实现的功能，websocket也全部能做到，而且，相较于SSE，它还有以下优势：  \n- 支持客户端和服务端的双向通信\n- 浏览器没有连接数限制  \n- 相对SSE只支持UTF8文本，它还支持二进制数据\n\n## 客户端代码  \n依赖sockjs()完成websocket客户端的构建\n``` js\n// 引用socketjs\n<script src=\"https://cdn.bootcss.com/sockjs-client/0.3.4/sockjs.min.js\"></script>\n// 创建\n ws = new SockJS(targetUri);\n// 连接\nws.onopen = function () {\n    log('和服务端连接成功！');\n};\nws.onmessage = function (event) {\n    log('服务端说：' + event.data);\n};\nws.onclose = function () {\n    log('和服务端断开连接！')\n}\n// 发送数据\nfunction sent() {\n    if (ws != null) {\n        ws.send(text.value);\n        log('客户端说：' + text.value);\n    } else {\n        log('请先建立连接！')\n    }\n}\n// 关闭\nfunction disconnect() {\n    if (ws != null) {\n        ws.close();\n        ws = null;\n    }\n}\n```\n### 服务端代码\n服务端选择一种最简单的方式，依赖`spring-boot-starter-websocket`。  \n完成步骤可以大致分为以下几步：  \n1. pom新增websocket依赖：  \n``` xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-websocket</artifactId>\n    </dependency>\n```\n2. 开启`@EnableWebSocket`,通过`WebSocketConfigurer`注入`WebSocketHandler`。这里直接继承`TextWebSocketHandler`, 注意同时定义了客户端连接路径`/connect`\n``` java\n@Configuration\n@EnableWebSocket\npublic class WebSocketServerConfigure implements WebSocketConfigurer {\n    @Autowired\n    private MyTextSocketHandler textSocketHandler;\n    /**\n     * 效果类似 @ServerEndpoint\n     * @param registry\n     */\n    @Override\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\n        registry.addHandler(textSocketHandler, \"/connect\")\n                .setAllowedOriginPatterns(\"*\")  // setAllowedOrigins已过时\n                .withSockJS();\n    }\n}\n```\n\n3. 定义WebSocketHandler  \n``` java\n@Component\n@Slf4j\npublic class MyTextSocketHandler extends TextWebSocketHandler {\n\n    public static Map<String, WebSocketSession> connectManager = new ConcurrentHashMap<>();\n\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) {\n        log.info(\"和客户端建立连接\");\n        connectManager.put(session.getId(), session);\n    }\n\n    @Override\n    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n        session.close(CloseStatus.SERVER_ERROR);\n        connectManager.remove(session.getId());\n        log.error(\"连接异常\", exception);\n    }\n\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n        super.afterConnectionClosed(session, status);\n        connectManager.remove(session.getId());\n        log.info(\"和客户端断开连接\");\n    }\n\n    @Override\n    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n        // 获取到客户端发送过来的消息\n        String receiveMessage = message.getPayload();\n        log.info(receiveMessage);\n        // 发送消息给客户端\n        session.sendMessage(new TextMessage(fakeAi(receiveMessage)));\n        // 关闭连接\n        // session.close(CloseStatus.NORMAL);\n    }\n\n    private static String fakeAi(String input) {\n        if (input == null || \"\".equals(input)) {\n            return \"你说啥？\";\n        }\n        return \"收到消息 : \" +input;\n    }\n}\n```\n4. 注意到以上代码只有服务端响应，并返回客户端数据，没有服务端主动推送的。而服务端响应都是通过`WebSocketSession`来完成，因此，我们只要把`WebSocketSession`保存，在另一个地方就可以实现服务端push了。\n``` java\nCollection<WebSocketSession> values = MyTextSocketHandler.connectManager.values();\nfor (WebSocketSession session : values) {\n    socketHandler.handleTextMessage(session, new TextMessage(msg));\n}\n```\n如果不想依赖Springboot，那么需要引入`javax.websocket`。可以参考[A Guide to the Java API for WebSocket](https://www.baeldung.com/java-websockets)\n\n# 四、总结\n正如文章开头说的那样，web即时通讯中，commet是过时但稳定的技术；如果只考虑服务端推送，那么SSE也是可以的，基于HTTP流的它拥有着传统HTTP的优势，实现简便且能稳定处理网络异常；websocket随着日渐被广泛使用，已经被Html5说是未来的通信技术，而且已经被绝大多数的浏览器支持，比支持SSE的更多。如果你是应用于新的项目的话，那么放心地使用它吧。\n\n--- \n如果你想了解更多的comet技术细节，可以参阅：\nhttp://www.52im.net/thread-338-1-1.html  \n然后这篇文章对Comet、SSE、websocket进行了清晰的对比和说明：  \nhttps://blog.csdn.net/weixin_44739881/article/details/104072392  \n","source":"_posts/理解服务端推送与实践.md","raw":"---\ntitle: 理解服务端推送与实践\ndate: 2023-07-10 15:40:53\ntags:\n- SSE\n- websocket\n- comet\ncategories: Spring+\n---\n在Web开发的时候，通常会需要服务端向客户端推送消息。技术选型可以选择Comet（基于Ajax或HTTP流）、SSE(Server-sent Events, 只能是服务端推送)、Websocket（应用于浏览器Socket，基于TCP的双向通信协议），但随着Websocket在浏览器中的广泛支持，一般首推Websocket，如果只有服务端推送的需求可以选用SSE,在古老的浏览器环境中才选用Comet或通过ajax轮询。\n<!--more-->\n\n# 一、Comet\nComet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求，目前有两种实现方式，长轮询和iframe流。  \n- 长轮询  \n长轮询不是长链接，是在打开一条连接以后保持，等待服务器推送来数据再关闭的方式。长轮询的实现需要借助异步请求来实现，比如`AsyncContext`或`DeferredResult`。  \nServlet3.0就引入了[异步上下文](https://zhuanlan.zhihu.com/p/121801714),只是大家使用的较少。关于长轮询，并不是什么过时的技术，现在的配置中心(Nacos和Apollo)使用的就是[长轮询来实现推送](https://zhuanlan.zhihu.com/p/351196920)。  \nDeferredResult使用示例：  \n``` java\n@RequestMapping(\"/polling\")\n@RestController\npublic class PollingController {\n\n    private final static Multimap<Integer, DeferredResult<String>> watchRequestMap = Multimaps.synchronizedMultimap(HashMultimap.create());\n    private static final Long TIME_OUT = 60000L;\n\n    @RequestMapping(\"watch/{id}\")\n    public DeferredResult<String> watch(@PathVariable Integer id) {\n        DeferredResult<String> result = new DeferredResult<>(TIME_OUT);\n        result.onTimeout(() -> {\n            System.err.println(\"Task time out.\");\n        });\n        result.onCompletion(() -> {\n            watchRequestMap.remove(id, result);\n        });\n        watchRequestMap.put(id, result);\n        return result;\n    }\n\n\n    @RequestMapping(\"publish/{id}\")\n    public void publish(@PathVariable Integer id) {\n        Collection<DeferredResult<String>> deferredResults = watchRequestMap.get(id);\n        deferredResults.forEach(item -> {\n            item.setResult(String.format(\"id=%d于%s更新完成\", id, DateUtil.now()));\n        });\n    }\n}\n```\n- iframe流  \niframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长链接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript,例如`<script type=\\\"text/javascript\\\">...</script>`），来实时更新页面。iframe流方式的优点是浏览器兼容好，Google公司在一些产品中使用了iframe流，如Google Talk。  \n\n\n# 二、SSE\nSSE其实就是基于comet搞出来一套规范的API，被纳入到HTML5规范，使用起来相对更简单了。  \n## SSE 客户端  \n\n浏览器端主要是[EventSource](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource)的使用：  \n\n附带一份SSE Demo的前端代码:  \n\n``` js\n    if (window.EventSource == null) {\n        alert('The browser does not support Server-Sent Events');\n    }else{\n        var source = new EventSource('http://localhost:8381/sse/subscribe?id=data001');\n        source.onmessage = function (event) {\n            refreshByData(event.data);\n        };\n        source.onopen = function (event) {\n            refreshByData('连接成功');\n        };\n        source.addEventListener(\"close\", (event) => {\n            source.close();\n            refreshByData('连接关闭');\n        });\n    }\n\n    function refreshByData(data) {\n        var text = document.getElementById('result').innerText;\n        text += '\\n' + data;\n        document.getElementById('result').innerText = text;\n    }\n```\n\n## SSE 服务端\n可以通过Spring自带的`SseEmitter`完成，主要是帮我们更容易实现SSE的协议:请求头和body格式。即必须有以下headers:  \n``` html\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n然后内容可以是以下几个，以`:`开头，以`\\n`分隔：  \n``` html\ndata\nevent\nid\nretry\n```\n> 注意:  \n    1. event即自定义监听事件类型，不传则为`message`  \n    2. `data`必传且不可为空\n附带一份SSE Demo的服务端代码：\n``` java\n@ResponseBody\n    @GetMapping(path = \"subscribe\", produces = {MediaType.TEXT_EVENT_STREAM_VALUE})\n    public SseEmitter push(String id) throws IOException {\n        SseEmitter sseEmitter = new SseEmitter(60000L);\n        sseEmitter.onCompletion(() -> log.warn(\"[推送完成]\"));\n        new Thread(() -> {\n            IntStream.range(1, 10).forEach(n -> {\n                try {\n                    sseEmitter.send(SseEmitter.event().data(\"推送消息 : \" + n ));\n                    TimeUnit.MILLISECONDS.sleep(500L);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            });\n\n            try {\n                // 注意消息的data是必须填的，也不能为空\n                sseEmitter.send(SseEmitter.event().name(\"close\").data(\"--anything but no null--\"));\n                // 这里完全不是关闭，只是清空异步响应DeferredResult\n                sseEmitter.complete();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }).start();\n        return sseEmitter;\n    }\n```\n附带谷歌浏览器中的`EventStream`信息：  \n![](/images/SSE浏览器请求.png)\n## SSE避坑指南\n1. 看了几篇blog，都没提及SSE中http流的关闭。不处理的话，看请求就是会不断的重连。流关闭是由客户端发起，调用close方法，但是内容由服务端发送，客户端肯定不知道啊，只能是服务端发送一个结束事件来触发。也可以是特定消息，由onmessage中判断。  \n\n2. 浏览器有个不可突破的限制，就是SSE请求同事只能有6个（基于HTTP1.1）。详见:https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource  \n\n# 三、WebSocket  \n\n## websocket协议\nwebsocket其实是一种双向通信协议，它是基于TCP协议的。有人说他是独立于HTTP的，并不准确，它握手使用的是HTTP的[协议升级机制](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism)，而后数据传输使用的才是websocket协议。  \n相较于HTTP协议，它的优势在于它支持[交换数据帧](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)（客户端或服务端都可以在任何时间点发送数据），实现了双向通信。因此，SSE能实现的功能，websocket也全部能做到，而且，相较于SSE，它还有以下优势：  \n- 支持客户端和服务端的双向通信\n- 浏览器没有连接数限制  \n- 相对SSE只支持UTF8文本，它还支持二进制数据\n\n## 客户端代码  \n依赖sockjs()完成websocket客户端的构建\n``` js\n// 引用socketjs\n<script src=\"https://cdn.bootcss.com/sockjs-client/0.3.4/sockjs.min.js\"></script>\n// 创建\n ws = new SockJS(targetUri);\n// 连接\nws.onopen = function () {\n    log('和服务端连接成功！');\n};\nws.onmessage = function (event) {\n    log('服务端说：' + event.data);\n};\nws.onclose = function () {\n    log('和服务端断开连接！')\n}\n// 发送数据\nfunction sent() {\n    if (ws != null) {\n        ws.send(text.value);\n        log('客户端说：' + text.value);\n    } else {\n        log('请先建立连接！')\n    }\n}\n// 关闭\nfunction disconnect() {\n    if (ws != null) {\n        ws.close();\n        ws = null;\n    }\n}\n```\n### 服务端代码\n服务端选择一种最简单的方式，依赖`spring-boot-starter-websocket`。  \n完成步骤可以大致分为以下几步：  \n1. pom新增websocket依赖：  \n``` xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-websocket</artifactId>\n    </dependency>\n```\n2. 开启`@EnableWebSocket`,通过`WebSocketConfigurer`注入`WebSocketHandler`。这里直接继承`TextWebSocketHandler`, 注意同时定义了客户端连接路径`/connect`\n``` java\n@Configuration\n@EnableWebSocket\npublic class WebSocketServerConfigure implements WebSocketConfigurer {\n    @Autowired\n    private MyTextSocketHandler textSocketHandler;\n    /**\n     * 效果类似 @ServerEndpoint\n     * @param registry\n     */\n    @Override\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\n        registry.addHandler(textSocketHandler, \"/connect\")\n                .setAllowedOriginPatterns(\"*\")  // setAllowedOrigins已过时\n                .withSockJS();\n    }\n}\n```\n\n3. 定义WebSocketHandler  \n``` java\n@Component\n@Slf4j\npublic class MyTextSocketHandler extends TextWebSocketHandler {\n\n    public static Map<String, WebSocketSession> connectManager = new ConcurrentHashMap<>();\n\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) {\n        log.info(\"和客户端建立连接\");\n        connectManager.put(session.getId(), session);\n    }\n\n    @Override\n    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n        session.close(CloseStatus.SERVER_ERROR);\n        connectManager.remove(session.getId());\n        log.error(\"连接异常\", exception);\n    }\n\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n        super.afterConnectionClosed(session, status);\n        connectManager.remove(session.getId());\n        log.info(\"和客户端断开连接\");\n    }\n\n    @Override\n    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n        // 获取到客户端发送过来的消息\n        String receiveMessage = message.getPayload();\n        log.info(receiveMessage);\n        // 发送消息给客户端\n        session.sendMessage(new TextMessage(fakeAi(receiveMessage)));\n        // 关闭连接\n        // session.close(CloseStatus.NORMAL);\n    }\n\n    private static String fakeAi(String input) {\n        if (input == null || \"\".equals(input)) {\n            return \"你说啥？\";\n        }\n        return \"收到消息 : \" +input;\n    }\n}\n```\n4. 注意到以上代码只有服务端响应，并返回客户端数据，没有服务端主动推送的。而服务端响应都是通过`WebSocketSession`来完成，因此，我们只要把`WebSocketSession`保存，在另一个地方就可以实现服务端push了。\n``` java\nCollection<WebSocketSession> values = MyTextSocketHandler.connectManager.values();\nfor (WebSocketSession session : values) {\n    socketHandler.handleTextMessage(session, new TextMessage(msg));\n}\n```\n如果不想依赖Springboot，那么需要引入`javax.websocket`。可以参考[A Guide to the Java API for WebSocket](https://www.baeldung.com/java-websockets)\n\n# 四、总结\n正如文章开头说的那样，web即时通讯中，commet是过时但稳定的技术；如果只考虑服务端推送，那么SSE也是可以的，基于HTTP流的它拥有着传统HTTP的优势，实现简便且能稳定处理网络异常；websocket随着日渐被广泛使用，已经被Html5说是未来的通信技术，而且已经被绝大多数的浏览器支持，比支持SSE的更多。如果你是应用于新的项目的话，那么放心地使用它吧。\n\n--- \n如果你想了解更多的comet技术细节，可以参阅：\nhttp://www.52im.net/thread-338-1-1.html  \n然后这篇文章对Comet、SSE、websocket进行了清晰的对比和说明：  \nhttps://blog.csdn.net/weixin_44739881/article/details/104072392  \n","slug":"理解服务端推送与实践","published":1,"updated":"2024-02-18T07:51:02.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6ozk004nqwvd7p2i3n40","content":"<p>在Web开发的时候，通常会需要服务端向客户端推送消息。技术选型可以选择Comet（基于Ajax或HTTP流）、SSE(Server-sent Events, 只能是服务端推送)、Websocket（应用于浏览器Socket，基于TCP的双向通信协议），但随着Websocket在浏览器中的广泛支持，一般首推Websocket，如果只有服务端推送的需求可以选用SSE,在古老的浏览器环境中才选用Comet或通过ajax轮询。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一、Comet\"><a href=\"#一、Comet\" class=\"headerlink\" title=\"一、Comet\"></a>一、Comet</h1><p>Comet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求，目前有两种实现方式，长轮询和iframe流。  </p>\n<ul>\n<li>长轮询<br>长轮询不是长链接，是在打开一条连接以后保持，等待服务器推送来数据再关闭的方式。长轮询的实现需要借助异步请求来实现，比如<code>AsyncContext</code>或<code>DeferredResult</code>。<br>Servlet3.0就引入了<a href=\"https://zhuanlan.zhihu.com/p/121801714\">异步上下文</a>,只是大家使用的较少。关于长轮询，并不是什么过时的技术，现在的配置中心(Nacos和Apollo)使用的就是<a href=\"https://zhuanlan.zhihu.com/p/351196920\">长轮询来实现推送</a>。<br>DeferredResult使用示例：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/polling&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PollingController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Multimap&lt;Integer, DeferredResult&lt;String&gt;&gt; watchRequestMap = Multimaps.synchronizedMultimap(HashMultimap.create());</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long TIME_OUT = <span class=\"number\">60000L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;watch/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DeferredResult&lt;String&gt; <span class=\"title\">watch</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class=\"line\">        DeferredResult&lt;String&gt; result = <span class=\"keyword\">new</span> DeferredResult&lt;&gt;(TIME_OUT);</span><br><span class=\"line\">        result.onTimeout(() -&gt; &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;Task time out.&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        result.onCompletion(() -&gt; &#123;</span><br><span class=\"line\">            watchRequestMap.remove(id, result);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        watchRequestMap.put(id, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;publish/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">publish</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class=\"line\">        Collection&lt;DeferredResult&lt;String&gt;&gt; deferredResults = watchRequestMap.get(id);</span><br><span class=\"line\">        deferredResults.forEach(item -&gt; &#123;</span><br><span class=\"line\">            item.setResult(String.format(<span class=\"string\">&quot;id=%d于%s更新完成&quot;</span>, id, DateUtil.now()));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>iframe流<br>iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长链接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript,例如<code>&lt;script type=\\&quot;text/javascript\\&quot;&gt;...&lt;/script&gt;</code>），来实时更新页面。iframe流方式的优点是浏览器兼容好，Google公司在一些产品中使用了iframe流，如Google Talk。</li>\n</ul>\n<h1 id=\"二、SSE\"><a href=\"#二、SSE\" class=\"headerlink\" title=\"二、SSE\"></a>二、SSE</h1><p>SSE其实就是基于comet搞出来一套规范的API，被纳入到HTML5规范，使用起来相对更简单了。  </p>\n<h2 id=\"SSE-客户端\"><a href=\"#SSE-客户端\" class=\"headerlink\" title=\"SSE 客户端\"></a>SSE 客户端</h2><p>浏览器端主要是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource\">EventSource</a>的使用：  </p>\n<p>附带一份SSE Demo的前端代码:  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.EventSource == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;The browser does not support Server-Sent Events&#x27;</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> source = <span class=\"keyword\">new</span> EventSource(<span class=\"string\">&#x27;http://localhost:8381/sse/subscribe?id=data001&#x27;</span>);</span><br><span class=\"line\">    source.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        refreshByData(event.data);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    source.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        refreshByData(<span class=\"string\">&#x27;连接成功&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    source.addEventListener(<span class=\"string\">&quot;close&quot;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        source.close();</span><br><span class=\"line\">        refreshByData(<span class=\"string\">&#x27;连接关闭&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">refreshByData</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;result&#x27;</span>).innerText;</span><br><span class=\"line\">    text += <span class=\"string\">&#x27;\\n&#x27;</span> + data;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;result&#x27;</span>).innerText = text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SSE-服务端\"><a href=\"#SSE-服务端\" class=\"headerlink\" title=\"SSE 服务端\"></a>SSE 服务端</h2><p>可以通过Spring自带的<code>SseEmitter</code>完成，主要是帮我们更容易实现SSE的协议:请求头和body格式。即必须有以下headers:  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/event-stream</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure>\n<p>然后内容可以是以下几个，以<code>:</code>开头，以<code>\\n</code>分隔：  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data</span><br><span class=\"line\">event</span><br><span class=\"line\">id</span><br><span class=\"line\">retry</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意:<br>    1. event即自定义监听事件类型，不传则为<code>message</code><br>    2. <code>data</code>必传且不可为空<br>附带一份SSE Demo的服务端代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(path = &quot;subscribe&quot;, produces = &#123;MediaType.TEXT_EVENT_STREAM_VALUE&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SseEmitter <span class=\"title\">push</span><span class=\"params\">(String id)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        SseEmitter sseEmitter = <span class=\"keyword\">new</span> SseEmitter(<span class=\"number\">60000L</span>);</span><br><span class=\"line\">        sseEmitter.onCompletion(() -&gt; log.warn(<span class=\"string\">&quot;[推送完成]&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            IntStream.range(<span class=\"number\">1</span>, <span class=\"number\">10</span>).forEach(n -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sseEmitter.send(SseEmitter.event().data(<span class=\"string\">&quot;推送消息 : &quot;</span> + n ));</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(<span class=\"number\">500L</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 注意消息的data是必须填的，也不能为空</span></span><br><span class=\"line\">                sseEmitter.send(SseEmitter.event().name(<span class=\"string\">&quot;close&quot;</span>).data(<span class=\"string\">&quot;--anything but no null--&quot;</span>));</span><br><span class=\"line\">                <span class=\"comment\">// 这里完全不是关闭，只是清空异步响应DeferredResult</span></span><br><span class=\"line\">                sseEmitter.complete();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sseEmitter;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>附带谷歌浏览器中的<code>EventStream</code>信息：<br><img src=\"/images/SSE%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82.png\"></p>\n<h2 id=\"SSE避坑指南\"><a href=\"#SSE避坑指南\" class=\"headerlink\" title=\"SSE避坑指南\"></a>SSE避坑指南</h2><ol>\n<li><p>看了几篇blog，都没提及SSE中http流的关闭。不处理的话，看请求就是会不断的重连。流关闭是由客户端发起，调用close方法，但是内容由服务端发送，客户端肯定不知道啊，只能是服务端发送一个结束事件来触发。也可以是特定消息，由onmessage中判断。  </p>\n</li>\n<li><p>浏览器有个不可突破的限制，就是SSE请求同事只能有6个（基于HTTP1.1）。详见:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource\">https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource</a></p>\n</li>\n</ol>\n<h1 id=\"三、WebSocket\"><a href=\"#三、WebSocket\" class=\"headerlink\" title=\"三、WebSocket\"></a>三、WebSocket</h1><h2 id=\"websocket协议\"><a href=\"#websocket协议\" class=\"headerlink\" title=\"websocket协议\"></a>websocket协议</h2><p>websocket其实是一种双向通信协议，它是基于TCP协议的。有人说他是独立于HTTP的，并不准确，它握手使用的是HTTP的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism\">协议升级机制</a>，而后数据传输使用的才是websocket协议。<br>相较于HTTP协议，它的优势在于它支持<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers\">交换数据帧</a>（客户端或服务端都可以在任何时间点发送数据），实现了双向通信。因此，SSE能实现的功能，websocket也全部能做到，而且，相较于SSE，它还有以下优势：  </p>\n<ul>\n<li>支持客户端和服务端的双向通信</li>\n<li>浏览器没有连接数限制  </li>\n<li>相对SSE只支持UTF8文本，它还支持二进制数据</li>\n</ul>\n<h2 id=\"客户端代码\"><a href=\"#客户端代码\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h2><p>依赖sockjs()完成websocket客户端的构建</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用socketjs</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">&quot;https://cdn.bootcss.com/sockjs-client/0.3.4/sockjs.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"> ws = <span class=\"keyword\">new</span> SockJS(targetUri);</span><br><span class=\"line\"><span class=\"comment\">// 连接</span></span><br><span class=\"line\">ws.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    log(<span class=\"string\">&#x27;和服务端连接成功！&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ws.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    log(<span class=\"string\">&#x27;服务端说：&#x27;</span> + event.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ws.onclose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    log(<span class=\"string\">&#x27;和服务端断开连接！&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        ws.send(text.value);</span><br><span class=\"line\">        log(<span class=\"string\">&#x27;客户端说：&#x27;</span> + text.value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&#x27;请先建立连接！&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 关闭</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">disconnect</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        ws.close();</span><br><span class=\"line\">        ws = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端代码\"><a href=\"#服务端代码\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h3><p>服务端选择一种最简单的方式，依赖<code>spring-boot-starter-websocket</code>。<br>完成步骤可以大致分为以下几步：  </p>\n<ol>\n<li><p>pom新增websocket依赖：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>开启<code>@EnableWebSocket</code>,通过<code>WebSocketConfigurer</code>注入<code>WebSocketHandler</code>。这里直接继承<code>TextWebSocketHandler</code>, 注意同时定义了客户端连接路径<code>/connect</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSocket</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSocketServerConfigure</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebSocketConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyTextSocketHandler textSocketHandler;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 效果类似 <span class=\"doctag\">@ServerEndpoint</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> registry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerWebSocketHandlers</span><span class=\"params\">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        registry.addHandler(textSocketHandler, <span class=\"string\">&quot;/connect&quot;</span>)</span><br><span class=\"line\">                .setAllowedOriginPatterns(<span class=\"string\">&quot;*&quot;</span>)  <span class=\"comment\">// setAllowedOrigins已过时</span></span><br><span class=\"line\">                .withSockJS();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义WebSocketHandler  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTextSocketHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">TextWebSocketHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, WebSocketSession&gt; connectManager = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterConnectionEstablished</span><span class=\"params\">(WebSocketSession session)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;和客户端建立连接&quot;</span>);</span><br><span class=\"line\">        connectManager.put(session.getId(), session);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleTransportError</span><span class=\"params\">(WebSocketSession session, Throwable exception)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        session.close(CloseStatus.SERVER_ERROR);</span><br><span class=\"line\">        connectManager.remove(session.getId());</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;连接异常&quot;</span>, exception);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterConnectionClosed</span><span class=\"params\">(WebSocketSession session, CloseStatus status)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.afterConnectionClosed(session, status);</span><br><span class=\"line\">        connectManager.remove(session.getId());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;和客户端断开连接&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">handleTextMessage</span><span class=\"params\">(WebSocketSession session, TextMessage message)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取到客户端发送过来的消息</span></span><br><span class=\"line\">        String receiveMessage = message.getPayload();</span><br><span class=\"line\">        log.info(receiveMessage);</span><br><span class=\"line\">        <span class=\"comment\">// 发送消息给客户端</span></span><br><span class=\"line\">        session.sendMessage(<span class=\"keyword\">new</span> TextMessage(fakeAi(receiveMessage)));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        <span class=\"comment\">// session.close(CloseStatus.NORMAL);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">fakeAi</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (input == <span class=\"keyword\">null</span> || <span class=\"string\">&quot;&quot;</span>.equals(input)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;你说啥？&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;收到消息 : &quot;</span> +input;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>注意到以上代码只有服务端响应，并返回客户端数据，没有服务端主动推送的。而服务端响应都是通过<code>WebSocketSession</code>来完成，因此，我们只要把<code>WebSocketSession</code>保存，在另一个地方就可以实现服务端push了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection&lt;WebSocketSession&gt; values = MyTextSocketHandler.connectManager.values();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (WebSocketSession session : values) &#123;</span><br><span class=\"line\">    socketHandler.handleTextMessage(session, <span class=\"keyword\">new</span> TextMessage(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果不想依赖Springboot，那么需要引入<code>javax.websocket</code>。可以参考<a href=\"https://www.baeldung.com/java-websockets\">A Guide to the Java API for WebSocket</a></p>\n</li>\n</ol>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>正如文章开头说的那样，web即时通讯中，commet是过时但稳定的技术；如果只考虑服务端推送，那么SSE也是可以的，基于HTTP流的它拥有着传统HTTP的优势，实现简便且能稳定处理网络异常；websocket随着日渐被广泛使用，已经被Html5说是未来的通信技术，而且已经被绝大多数的浏览器支持，比支持SSE的更多。如果你是应用于新的项目的话，那么放心地使用它吧。</p>\n<hr>\n<p>如果你想了解更多的comet技术细节，可以参阅：<br><a href=\"http://www.52im.net/thread-338-1-1.html\">http://www.52im.net/thread-338-1-1.html</a><br>然后这篇文章对Comet、SSE、websocket进行了清晰的对比和说明：<br><a href=\"https://blog.csdn.net/weixin_44739881/article/details/104072392\">https://blog.csdn.net/weixin_44739881/article/details/104072392</a>  </p>\n","site":{"data":{}},"excerpt":"<p>在Web开发的时候，通常会需要服务端向客户端推送消息。技术选型可以选择Comet（基于Ajax或HTTP流）、SSE(Server-sent Events, 只能是服务端推送)、Websocket（应用于浏览器Socket，基于TCP的双向通信协议），但随着Websocket在浏览器中的广泛支持，一般首推Websocket，如果只有服务端推送的需求可以选用SSE,在古老的浏览器环境中才选用Comet或通过ajax轮询。</p>","more":"<h1 id=\"一、Comet\"><a href=\"#一、Comet\" class=\"headerlink\" title=\"一、Comet\"></a>一、Comet</h1><p>Comet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求，目前有两种实现方式，长轮询和iframe流。  </p>\n<ul>\n<li>长轮询<br>长轮询不是长链接，是在打开一条连接以后保持，等待服务器推送来数据再关闭的方式。长轮询的实现需要借助异步请求来实现，比如<code>AsyncContext</code>或<code>DeferredResult</code>。<br>Servlet3.0就引入了<a href=\"https://zhuanlan.zhihu.com/p/121801714\">异步上下文</a>,只是大家使用的较少。关于长轮询，并不是什么过时的技术，现在的配置中心(Nacos和Apollo)使用的就是<a href=\"https://zhuanlan.zhihu.com/p/351196920\">长轮询来实现推送</a>。<br>DeferredResult使用示例：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/polling&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PollingController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Multimap&lt;Integer, DeferredResult&lt;String&gt;&gt; watchRequestMap = Multimaps.synchronizedMultimap(HashMultimap.create());</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long TIME_OUT = <span class=\"number\">60000L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;watch/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DeferredResult&lt;String&gt; <span class=\"title\">watch</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class=\"line\">        DeferredResult&lt;String&gt; result = <span class=\"keyword\">new</span> DeferredResult&lt;&gt;(TIME_OUT);</span><br><span class=\"line\">        result.onTimeout(() -&gt; &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;Task time out.&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        result.onCompletion(() -&gt; &#123;</span><br><span class=\"line\">            watchRequestMap.remove(id, result);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        watchRequestMap.put(id, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;publish/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">publish</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class=\"line\">        Collection&lt;DeferredResult&lt;String&gt;&gt; deferredResults = watchRequestMap.get(id);</span><br><span class=\"line\">        deferredResults.forEach(item -&gt; &#123;</span><br><span class=\"line\">            item.setResult(String.format(<span class=\"string\">&quot;id=%d于%s更新完成&quot;</span>, id, DateUtil.now()));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>iframe流<br>iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长链接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript,例如<code>&lt;script type=\\&quot;text/javascript\\&quot;&gt;...&lt;/script&gt;</code>），来实时更新页面。iframe流方式的优点是浏览器兼容好，Google公司在一些产品中使用了iframe流，如Google Talk。</li>\n</ul>\n<h1 id=\"二、SSE\"><a href=\"#二、SSE\" class=\"headerlink\" title=\"二、SSE\"></a>二、SSE</h1><p>SSE其实就是基于comet搞出来一套规范的API，被纳入到HTML5规范，使用起来相对更简单了。  </p>\n<h2 id=\"SSE-客户端\"><a href=\"#SSE-客户端\" class=\"headerlink\" title=\"SSE 客户端\"></a>SSE 客户端</h2><p>浏览器端主要是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource\">EventSource</a>的使用：  </p>\n<p>附带一份SSE Demo的前端代码:  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.EventSource == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;The browser does not support Server-Sent Events&#x27;</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> source = <span class=\"keyword\">new</span> EventSource(<span class=\"string\">&#x27;http://localhost:8381/sse/subscribe?id=data001&#x27;</span>);</span><br><span class=\"line\">    source.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        refreshByData(event.data);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    source.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        refreshByData(<span class=\"string\">&#x27;连接成功&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    source.addEventListener(<span class=\"string\">&quot;close&quot;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        source.close();</span><br><span class=\"line\">        refreshByData(<span class=\"string\">&#x27;连接关闭&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">refreshByData</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;result&#x27;</span>).innerText;</span><br><span class=\"line\">    text += <span class=\"string\">&#x27;\\n&#x27;</span> + data;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;result&#x27;</span>).innerText = text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SSE-服务端\"><a href=\"#SSE-服务端\" class=\"headerlink\" title=\"SSE 服务端\"></a>SSE 服务端</h2><p>可以通过Spring自带的<code>SseEmitter</code>完成，主要是帮我们更容易实现SSE的协议:请求头和body格式。即必须有以下headers:  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/event-stream</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure>\n<p>然后内容可以是以下几个，以<code>:</code>开头，以<code>\\n</code>分隔：  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data</span><br><span class=\"line\">event</span><br><span class=\"line\">id</span><br><span class=\"line\">retry</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意:<br>    1. event即自定义监听事件类型，不传则为<code>message</code><br>    2. <code>data</code>必传且不可为空<br>附带一份SSE Demo的服务端代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(path = &quot;subscribe&quot;, produces = &#123;MediaType.TEXT_EVENT_STREAM_VALUE&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SseEmitter <span class=\"title\">push</span><span class=\"params\">(String id)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        SseEmitter sseEmitter = <span class=\"keyword\">new</span> SseEmitter(<span class=\"number\">60000L</span>);</span><br><span class=\"line\">        sseEmitter.onCompletion(() -&gt; log.warn(<span class=\"string\">&quot;[推送完成]&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            IntStream.range(<span class=\"number\">1</span>, <span class=\"number\">10</span>).forEach(n -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sseEmitter.send(SseEmitter.event().data(<span class=\"string\">&quot;推送消息 : &quot;</span> + n ));</span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(<span class=\"number\">500L</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 注意消息的data是必须填的，也不能为空</span></span><br><span class=\"line\">                sseEmitter.send(SseEmitter.event().name(<span class=\"string\">&quot;close&quot;</span>).data(<span class=\"string\">&quot;--anything but no null--&quot;</span>));</span><br><span class=\"line\">                <span class=\"comment\">// 这里完全不是关闭，只是清空异步响应DeferredResult</span></span><br><span class=\"line\">                sseEmitter.complete();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sseEmitter;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>附带谷歌浏览器中的<code>EventStream</code>信息：<br><img src=\"/images/SSE%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82.png\"></p>\n<h2 id=\"SSE避坑指南\"><a href=\"#SSE避坑指南\" class=\"headerlink\" title=\"SSE避坑指南\"></a>SSE避坑指南</h2><ol>\n<li><p>看了几篇blog，都没提及SSE中http流的关闭。不处理的话，看请求就是会不断的重连。流关闭是由客户端发起，调用close方法，但是内容由服务端发送，客户端肯定不知道啊，只能是服务端发送一个结束事件来触发。也可以是特定消息，由onmessage中判断。  </p>\n</li>\n<li><p>浏览器有个不可突破的限制，就是SSE请求同事只能有6个（基于HTTP1.1）。详见:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource\">https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource</a></p>\n</li>\n</ol>\n<h1 id=\"三、WebSocket\"><a href=\"#三、WebSocket\" class=\"headerlink\" title=\"三、WebSocket\"></a>三、WebSocket</h1><h2 id=\"websocket协议\"><a href=\"#websocket协议\" class=\"headerlink\" title=\"websocket协议\"></a>websocket协议</h2><p>websocket其实是一种双向通信协议，它是基于TCP协议的。有人说他是独立于HTTP的，并不准确，它握手使用的是HTTP的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism\">协议升级机制</a>，而后数据传输使用的才是websocket协议。<br>相较于HTTP协议，它的优势在于它支持<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers\">交换数据帧</a>（客户端或服务端都可以在任何时间点发送数据），实现了双向通信。因此，SSE能实现的功能，websocket也全部能做到，而且，相较于SSE，它还有以下优势：  </p>\n<ul>\n<li>支持客户端和服务端的双向通信</li>\n<li>浏览器没有连接数限制  </li>\n<li>相对SSE只支持UTF8文本，它还支持二进制数据</li>\n</ul>\n<h2 id=\"客户端代码\"><a href=\"#客户端代码\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h2><p>依赖sockjs()完成websocket客户端的构建</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用socketjs</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">&quot;https://cdn.bootcss.com/sockjs-client/0.3.4/sockjs.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"> ws = <span class=\"keyword\">new</span> SockJS(targetUri);</span><br><span class=\"line\"><span class=\"comment\">// 连接</span></span><br><span class=\"line\">ws.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    log(<span class=\"string\">&#x27;和服务端连接成功！&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ws.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    log(<span class=\"string\">&#x27;服务端说：&#x27;</span> + event.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ws.onclose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    log(<span class=\"string\">&#x27;和服务端断开连接！&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        ws.send(text.value);</span><br><span class=\"line\">        log(<span class=\"string\">&#x27;客户端说：&#x27;</span> + text.value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&#x27;请先建立连接！&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 关闭</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">disconnect</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        ws.close();</span><br><span class=\"line\">        ws = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端代码\"><a href=\"#服务端代码\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h3><p>服务端选择一种最简单的方式，依赖<code>spring-boot-starter-websocket</code>。<br>完成步骤可以大致分为以下几步：  </p>\n<ol>\n<li><p>pom新增websocket依赖：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>开启<code>@EnableWebSocket</code>,通过<code>WebSocketConfigurer</code>注入<code>WebSocketHandler</code>。这里直接继承<code>TextWebSocketHandler</code>, 注意同时定义了客户端连接路径<code>/connect</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSocket</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSocketServerConfigure</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebSocketConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyTextSocketHandler textSocketHandler;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 效果类似 <span class=\"doctag\">@ServerEndpoint</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> registry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerWebSocketHandlers</span><span class=\"params\">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        registry.addHandler(textSocketHandler, <span class=\"string\">&quot;/connect&quot;</span>)</span><br><span class=\"line\">                .setAllowedOriginPatterns(<span class=\"string\">&quot;*&quot;</span>)  <span class=\"comment\">// setAllowedOrigins已过时</span></span><br><span class=\"line\">                .withSockJS();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义WebSocketHandler  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTextSocketHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">TextWebSocketHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, WebSocketSession&gt; connectManager = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterConnectionEstablished</span><span class=\"params\">(WebSocketSession session)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;和客户端建立连接&quot;</span>);</span><br><span class=\"line\">        connectManager.put(session.getId(), session);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleTransportError</span><span class=\"params\">(WebSocketSession session, Throwable exception)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        session.close(CloseStatus.SERVER_ERROR);</span><br><span class=\"line\">        connectManager.remove(session.getId());</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;连接异常&quot;</span>, exception);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterConnectionClosed</span><span class=\"params\">(WebSocketSession session, CloseStatus status)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.afterConnectionClosed(session, status);</span><br><span class=\"line\">        connectManager.remove(session.getId());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;和客户端断开连接&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">handleTextMessage</span><span class=\"params\">(WebSocketSession session, TextMessage message)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取到客户端发送过来的消息</span></span><br><span class=\"line\">        String receiveMessage = message.getPayload();</span><br><span class=\"line\">        log.info(receiveMessage);</span><br><span class=\"line\">        <span class=\"comment\">// 发送消息给客户端</span></span><br><span class=\"line\">        session.sendMessage(<span class=\"keyword\">new</span> TextMessage(fakeAi(receiveMessage)));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">        <span class=\"comment\">// session.close(CloseStatus.NORMAL);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">fakeAi</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (input == <span class=\"keyword\">null</span> || <span class=\"string\">&quot;&quot;</span>.equals(input)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;你说啥？&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;收到消息 : &quot;</span> +input;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>注意到以上代码只有服务端响应，并返回客户端数据，没有服务端主动推送的。而服务端响应都是通过<code>WebSocketSession</code>来完成，因此，我们只要把<code>WebSocketSession</code>保存，在另一个地方就可以实现服务端push了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection&lt;WebSocketSession&gt; values = MyTextSocketHandler.connectManager.values();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (WebSocketSession session : values) &#123;</span><br><span class=\"line\">    socketHandler.handleTextMessage(session, <span class=\"keyword\">new</span> TextMessage(msg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果不想依赖Springboot，那么需要引入<code>javax.websocket</code>。可以参考<a href=\"https://www.baeldung.com/java-websockets\">A Guide to the Java API for WebSocket</a></p>\n</li>\n</ol>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>正如文章开头说的那样，web即时通讯中，commet是过时但稳定的技术；如果只考虑服务端推送，那么SSE也是可以的，基于HTTP流的它拥有着传统HTTP的优势，实现简便且能稳定处理网络异常；websocket随着日渐被广泛使用，已经被Html5说是未来的通信技术，而且已经被绝大多数的浏览器支持，比支持SSE的更多。如果你是应用于新的项目的话，那么放心地使用它吧。</p>\n<hr>\n<p>如果你想了解更多的comet技术细节，可以参阅：<br><a href=\"http://www.52im.net/thread-338-1-1.html\">http://www.52im.net/thread-338-1-1.html</a><br>然后这篇文章对Comet、SSE、websocket进行了清晰的对比和说明：<br><a href=\"https://blog.csdn.net/weixin_44739881/article/details/104072392\">https://blog.csdn.net/weixin_44739881/article/details/104072392</a>  </p>"},{"title":"程序员练级攻略","date":"2024-01-12T12:47:06.000Z","_content":"芝兰生于幽林，不以无人而不芳；君子修道立德，不为穷困而改节\n-- 致敬 陈皓\n<!--more-->  \n\n程序员练级攻略  \n[开篇词](https://time.geekbang.org/column/article/8136)  \n\n[用十年学会编程](http://norvig.com/21-days.html)  \n\n----\n\n## 最好的学习方式：实践！\n> the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors  \n\n> 最有效的学习方式需要：  \n    1. 明确的目标任务\n    2. 因人而异的难度\n    3. 丰富的信息反馈\n    4. 重复试错的机会\n\n---\n\n[程序员的谎谬之言还是至理名言？](https://coolshell.cn/articles/4235.html) | 酷 壳 - CoolShell\n\n### 你不知道你不知道的\n \n> （例如：如果你对搜索和约束传播（constraint propagation）有点了解的话，那你就可能 容易地解决数独问题，否则的话， 这的确是 非常 难的）。你无法学习一种不知道或是你不知道用在哪里的算法。你也不可能去用一个你以为不存在的技术去解决一个问题。同样，你身边也不可以一直都有一个高人随时在给你指引正确的方向。  \n广度知识只是深度知识的副产品， 记忆不深刻是因为没深入研究  \n\n### 永远做最重要的事情（你学的足够快吗？）\n\n> 我在这里想说几个我的观点：\n我特别同意作者的，如果你把一个技术搞精搞深，你的知识面自然会很广的。\n面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会。\n为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。\n不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。\n永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。\n很多东西在概念上是相通的，在哲学层次上是相通的，这是你需要去追求的学习知识的境界。\n最后echo一下作者的话——“很多时候，你缺少的不是知识而是热情”！\n\n- 《易经》有云：“取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也”\n\n---\n\n## 程序员修养\n\n- 提问的智慧（How To Ask Questions The Smart Way）\n[How To Ask Questions The Smart Way](http://www.catb.org/~esr/faqs/smart-questions.html)\n\n- 警惕X-Y问题\n[X-Y Problem](https://coolshell.cn/articles/10804.html) | 酷 壳 - CoolShell\n\n- 《代码大全》\n- 《重构：改善既有代码的设计》\n> Code Review 对我的成长非常有帮助，我认为没有 Code Review 的公司都没有必要呆（因为不做 Code Review 的公司一定是不尊重技术的）\n\n- OWASP\n美国联邦贸易委员会（FTC）强烈建议所有企业需遵循 OWASP 十大 Web 弱点防护守则。\nOWASP Top 10 项目 是程序员非常需要关注的最基本的也是最严重的安全问题，现在其已经成了一种标准\n[OWASP Top 10](https://wiki.owasp.org/images/d/dc/OWASP_Top_10_2017_%E4%B8%AD%E6%96%87%E7%89%88v1.3.pdf) - 2017\n\n- HTTP 安全\n[Hardening Your HTTP Security Headers](https://www.keycdn.com/blog/http-security-headers) - KeyCDN\n\n- 什么数据需要监控，指标\n[Monitoring 101: Collecting the Right Data](https://www.datadoghq.com/blog/monitoring-101-collecting-data/) | Datadog (datadoghq.com)\n    1. Work Metrics\n    ​![image](/images/coder/Metrics1.png)​\n    2. Resource Metrics\n    ​![image](/images/coder/Metrics2.png)​\n    3. Event Metrics\n    ​![image](/images/coder/Metrics3.png)​\n\n---\n\n## 程序员基础知识\n\n### 五种IO模型\n\n- 阻塞 I/0\n- 非阻塞I/0\n- I/O 的多路复用(select和 poll)\n- 信号驱动的 I/O (SIGIO)\n- 异步 I/O (POSIX的 aio functions)\n\n[Scalable IO in Java](https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf)\n\n\n[JVM规范说明书](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf)\nThe Java® Virtual Machine Specification (oracle.com)\n\n[解剖JVM(JVM Anatomy Quarks)](https://shipilev.net/jvm/anatomy-quarks/)\n\n\n\nJava字节码，动态修改或是动态生成Java字节码  \n[Introduction to Java Bytecode](https://dzone.com/articles/introduction-to-java-bytecode)\n\n---\n\n### 分布式架构\n\n分布式架构中的核心思想  \n[Distributed systems for fun and profit](http://book.mixu.net/distsys/single-page.html)\n\n[设计数据密集应用](http://ddia.vonng.com/#/)\n\n\n[可扩展的web架构和分布式系统](http://nettee.github.io/posts/2016/Scalable-Web-Architecture-and-Distributed-Systems/)\n\n软件即服务（SaaS）  \n[The Twelve-Factor App （简体中文） ](https://12factor.net/zh_cn/)\n\n#### 自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有 Docker 和 Kubernetes 才是未来!\n\nDocker使用  \n[Docker overview](https://docs.docker.com/get-started/overview/)\n\nDocker原理  \n[Docker基础技术：Linux Namespace](https://coolshell.cn/articles/17010.html)\n\n\n\n\n\n\n\n","source":"_posts/程序员练级攻略.md","raw":"---\ntitle: 程序员练级攻略\ntags: \ncategories: 其他\ndate: 2024-01-12 20:47:06\n---\n芝兰生于幽林，不以无人而不芳；君子修道立德，不为穷困而改节\n-- 致敬 陈皓\n<!--more-->  \n\n程序员练级攻略  \n[开篇词](https://time.geekbang.org/column/article/8136)  \n\n[用十年学会编程](http://norvig.com/21-days.html)  \n\n----\n\n## 最好的学习方式：实践！\n> the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors  \n\n> 最有效的学习方式需要：  \n    1. 明确的目标任务\n    2. 因人而异的难度\n    3. 丰富的信息反馈\n    4. 重复试错的机会\n\n---\n\n[程序员的谎谬之言还是至理名言？](https://coolshell.cn/articles/4235.html) | 酷 壳 - CoolShell\n\n### 你不知道你不知道的\n \n> （例如：如果你对搜索和约束传播（constraint propagation）有点了解的话，那你就可能 容易地解决数独问题，否则的话， 这的确是 非常 难的）。你无法学习一种不知道或是你不知道用在哪里的算法。你也不可能去用一个你以为不存在的技术去解决一个问题。同样，你身边也不可以一直都有一个高人随时在给你指引正确的方向。  \n广度知识只是深度知识的副产品， 记忆不深刻是因为没深入研究  \n\n### 永远做最重要的事情（你学的足够快吗？）\n\n> 我在这里想说几个我的观点：\n我特别同意作者的，如果你把一个技术搞精搞深，你的知识面自然会很广的。\n面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会。\n为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。\n不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。\n永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。\n很多东西在概念上是相通的，在哲学层次上是相通的，这是你需要去追求的学习知识的境界。\n最后echo一下作者的话——“很多时候，你缺少的不是知识而是热情”！\n\n- 《易经》有云：“取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也”\n\n---\n\n## 程序员修养\n\n- 提问的智慧（How To Ask Questions The Smart Way）\n[How To Ask Questions The Smart Way](http://www.catb.org/~esr/faqs/smart-questions.html)\n\n- 警惕X-Y问题\n[X-Y Problem](https://coolshell.cn/articles/10804.html) | 酷 壳 - CoolShell\n\n- 《代码大全》\n- 《重构：改善既有代码的设计》\n> Code Review 对我的成长非常有帮助，我认为没有 Code Review 的公司都没有必要呆（因为不做 Code Review 的公司一定是不尊重技术的）\n\n- OWASP\n美国联邦贸易委员会（FTC）强烈建议所有企业需遵循 OWASP 十大 Web 弱点防护守则。\nOWASP Top 10 项目 是程序员非常需要关注的最基本的也是最严重的安全问题，现在其已经成了一种标准\n[OWASP Top 10](https://wiki.owasp.org/images/d/dc/OWASP_Top_10_2017_%E4%B8%AD%E6%96%87%E7%89%88v1.3.pdf) - 2017\n\n- HTTP 安全\n[Hardening Your HTTP Security Headers](https://www.keycdn.com/blog/http-security-headers) - KeyCDN\n\n- 什么数据需要监控，指标\n[Monitoring 101: Collecting the Right Data](https://www.datadoghq.com/blog/monitoring-101-collecting-data/) | Datadog (datadoghq.com)\n    1. Work Metrics\n    ​![image](/images/coder/Metrics1.png)​\n    2. Resource Metrics\n    ​![image](/images/coder/Metrics2.png)​\n    3. Event Metrics\n    ​![image](/images/coder/Metrics3.png)​\n\n---\n\n## 程序员基础知识\n\n### 五种IO模型\n\n- 阻塞 I/0\n- 非阻塞I/0\n- I/O 的多路复用(select和 poll)\n- 信号驱动的 I/O (SIGIO)\n- 异步 I/O (POSIX的 aio functions)\n\n[Scalable IO in Java](https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf)\n\n\n[JVM规范说明书](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf)\nThe Java® Virtual Machine Specification (oracle.com)\n\n[解剖JVM(JVM Anatomy Quarks)](https://shipilev.net/jvm/anatomy-quarks/)\n\n\n\nJava字节码，动态修改或是动态生成Java字节码  \n[Introduction to Java Bytecode](https://dzone.com/articles/introduction-to-java-bytecode)\n\n---\n\n### 分布式架构\n\n分布式架构中的核心思想  \n[Distributed systems for fun and profit](http://book.mixu.net/distsys/single-page.html)\n\n[设计数据密集应用](http://ddia.vonng.com/#/)\n\n\n[可扩展的web架构和分布式系统](http://nettee.github.io/posts/2016/Scalable-Web-Architecture-and-Distributed-Systems/)\n\n软件即服务（SaaS）  \n[The Twelve-Factor App （简体中文） ](https://12factor.net/zh_cn/)\n\n#### 自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有 Docker 和 Kubernetes 才是未来!\n\nDocker使用  \n[Docker overview](https://docs.docker.com/get-started/overview/)\n\nDocker原理  \n[Docker基础技术：Linux Namespace](https://coolshell.cn/articles/17010.html)\n\n\n\n\n\n\n\n","slug":"程序员练级攻略","published":1,"updated":"2024-04-11T03:37:49.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6ozl004pqwvd4j7hg0zx","content":"<p>芝兰生于幽林，不以无人而不芳；君子修道立德，不为穷困而改节<br>– 致敬 陈皓</p>\n<span id=\"more\"></span>  \n\n<p>程序员练级攻略<br><a href=\"https://time.geekbang.org/column/article/8136\">开篇词</a>  </p>\n<p><a href=\"http://norvig.com/21-days.html\">用十年学会编程</a>  </p>\n<hr>\n<h2 id=\"最好的学习方式：实践！\"><a href=\"#最好的学习方式：实践！\" class=\"headerlink\" title=\"最好的学习方式：实践！\"></a>最好的学习方式：实践！</h2><blockquote>\n<p>the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors  </p>\n</blockquote>\n<blockquote>\n<p>最有效的学习方式需要：<br>    1. 明确的目标任务<br>    2. 因人而异的难度<br>    3. 丰富的信息反馈<br>    4. 重复试错的机会</p>\n</blockquote>\n<hr>\n<p><a href=\"https://coolshell.cn/articles/4235.html\">程序员的谎谬之言还是至理名言？</a> | 酷 壳 - CoolShell</p>\n<h3 id=\"你不知道你不知道的\"><a href=\"#你不知道你不知道的\" class=\"headerlink\" title=\"你不知道你不知道的\"></a>你不知道你不知道的</h3><blockquote>\n<p>（例如：如果你对搜索和约束传播（constraint propagation）有点了解的话，那你就可能 容易地解决数独问题，否则的话， 这的确是 非常 难的）。你无法学习一种不知道或是你不知道用在哪里的算法。你也不可能去用一个你以为不存在的技术去解决一个问题。同样，你身边也不可以一直都有一个高人随时在给你指引正确的方向。<br>广度知识只是深度知识的副产品， 记忆不深刻是因为没深入研究  </p>\n</blockquote>\n<h3 id=\"永远做最重要的事情（你学的足够快吗？）\"><a href=\"#永远做最重要的事情（你学的足够快吗？）\" class=\"headerlink\" title=\"永远做最重要的事情（你学的足够快吗？）\"></a>永远做最重要的事情（你学的足够快吗？）</h3><blockquote>\n<p>我在这里想说几个我的观点：<br>我特别同意作者的，如果你把一个技术搞精搞深，你的知识面自然会很广的。<br>面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会。<br>为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。<br>不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。<br>永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。<br>很多东西在概念上是相通的，在哲学层次上是相通的，这是你需要去追求的学习知识的境界。<br>最后echo一下作者的话——“很多时候，你缺少的不是知识而是热情”！</p>\n</blockquote>\n<ul>\n<li>《易经》有云：“取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也”</li>\n</ul>\n<hr>\n<h2 id=\"程序员修养\"><a href=\"#程序员修养\" class=\"headerlink\" title=\"程序员修养\"></a>程序员修养</h2><ul>\n<li><p>提问的智慧（How To Ask Questions The Smart Way）<br><a href=\"http://www.catb.org/~esr/faqs/smart-questions.html\">How To Ask Questions The Smart Way</a></p>\n</li>\n<li><p>警惕X-Y问题<br><a href=\"https://coolshell.cn/articles/10804.html\">X-Y Problem</a> | 酷 壳 - CoolShell</p>\n</li>\n<li><p>《代码大全》</p>\n</li>\n<li><p>《重构：改善既有代码的设计》</p>\n<blockquote>\n<p>Code Review 对我的成长非常有帮助，我认为没有 Code Review 的公司都没有必要呆（因为不做 Code Review 的公司一定是不尊重技术的）</p>\n</blockquote>\n</li>\n<li><p>OWASP<br>美国联邦贸易委员会（FTC）强烈建议所有企业需遵循 OWASP 十大 Web 弱点防护守则。<br>OWASP Top 10 项目 是程序员非常需要关注的最基本的也是最严重的安全问题，现在其已经成了一种标准<br><a href=\"https://wiki.owasp.org/images/d/dc/OWASP_Top_10_2017_%E4%B8%AD%E6%96%87%E7%89%88v1.3.pdf\">OWASP Top 10</a> - 2017</p>\n</li>\n<li><p>HTTP 安全<br><a href=\"https://www.keycdn.com/blog/http-security-headers\">Hardening Your HTTP Security Headers</a> - KeyCDN</p>\n</li>\n<li><p>什么数据需要监控，指标<br><a href=\"https://www.datadoghq.com/blog/monitoring-101-collecting-data/\">Monitoring 101: Collecting the Right Data</a> | Datadog (datadoghq.com)</p>\n<ol>\n<li>Work Metrics<br>  ​<img src=\"/images/coder/Metrics1.png\" alt=\"image\">​</li>\n<li>Resource Metrics<br>  ​<img src=\"/images/coder/Metrics2.png\" alt=\"image\">​</li>\n<li>Event Metrics<br>  ​<img src=\"/images/coder/Metrics3.png\" alt=\"image\">​</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"程序员基础知识\"><a href=\"#程序员基础知识\" class=\"headerlink\" title=\"程序员基础知识\"></a>程序员基础知识</h2><h3 id=\"五种IO模型\"><a href=\"#五种IO模型\" class=\"headerlink\" title=\"五种IO模型\"></a>五种IO模型</h3><ul>\n<li>阻塞 I&#x2F;0</li>\n<li>非阻塞I&#x2F;0</li>\n<li>I&#x2F;O 的多路复用(select和 poll)</li>\n<li>信号驱动的 I&#x2F;O (SIGIO)</li>\n<li>异步 I&#x2F;O (POSIX的 aio functions)</li>\n</ul>\n<p><a href=\"https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\">Scalable IO in Java</a></p>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf\">JVM规范说明书</a><br>The Java® Virtual Machine Specification (oracle.com)</p>\n<p><a href=\"https://shipilev.net/jvm/anatomy-quarks/\">解剖JVM(JVM Anatomy Quarks)</a></p>\n<p>Java字节码，动态修改或是动态生成Java字节码<br><a href=\"https://dzone.com/articles/introduction-to-java-bytecode\">Introduction to Java Bytecode</a></p>\n<hr>\n<h3 id=\"分布式架构\"><a href=\"#分布式架构\" class=\"headerlink\" title=\"分布式架构\"></a>分布式架构</h3><p>分布式架构中的核心思想<br><a href=\"http://book.mixu.net/distsys/single-page.html\">Distributed systems for fun and profit</a></p>\n<p><a href=\"http://ddia.vonng.com/#/\">设计数据密集应用</a></p>\n<p><a href=\"http://nettee.github.io/posts/2016/Scalable-Web-Architecture-and-Distributed-Systems/\">可扩展的web架构和分布式系统</a></p>\n<p>软件即服务（SaaS）<br><a href=\"https://12factor.net/zh_cn/\">The Twelve-Factor App （简体中文） </a></p>\n<h4 id=\"自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有-Docker-和-Kubernetes-才是未来\"><a href=\"#自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有-Docker-和-Kubernetes-才是未来\" class=\"headerlink\" title=\"自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有 Docker 和 Kubernetes 才是未来!\"></a>自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有 Docker 和 Kubernetes 才是未来!</h4><p>Docker使用<br><a href=\"https://docs.docker.com/get-started/overview/\">Docker overview</a></p>\n<p>Docker原理<br><a href=\"https://coolshell.cn/articles/17010.html\">Docker基础技术：Linux Namespace</a></p>\n","site":{"data":{}},"excerpt":"<p>芝兰生于幽林，不以无人而不芳；君子修道立德，不为穷困而改节<br>– 致敬 陈皓</p>","more":"<p>程序员练级攻略<br><a href=\"https://time.geekbang.org/column/article/8136\">开篇词</a>  </p>\n<p><a href=\"http://norvig.com/21-days.html\">用十年学会编程</a>  </p>\n<hr>\n<h2 id=\"最好的学习方式：实践！\"><a href=\"#最好的学习方式：实践！\" class=\"headerlink\" title=\"最好的学习方式：实践！\"></a>最好的学习方式：实践！</h2><blockquote>\n<p>the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors  </p>\n</blockquote>\n<blockquote>\n<p>最有效的学习方式需要：<br>    1. 明确的目标任务<br>    2. 因人而异的难度<br>    3. 丰富的信息反馈<br>    4. 重复试错的机会</p>\n</blockquote>\n<hr>\n<p><a href=\"https://coolshell.cn/articles/4235.html\">程序员的谎谬之言还是至理名言？</a> | 酷 壳 - CoolShell</p>\n<h3 id=\"你不知道你不知道的\"><a href=\"#你不知道你不知道的\" class=\"headerlink\" title=\"你不知道你不知道的\"></a>你不知道你不知道的</h3><blockquote>\n<p>（例如：如果你对搜索和约束传播（constraint propagation）有点了解的话，那你就可能 容易地解决数独问题，否则的话， 这的确是 非常 难的）。你无法学习一种不知道或是你不知道用在哪里的算法。你也不可能去用一个你以为不存在的技术去解决一个问题。同样，你身边也不可以一直都有一个高人随时在给你指引正确的方向。<br>广度知识只是深度知识的副产品， 记忆不深刻是因为没深入研究  </p>\n</blockquote>\n<h3 id=\"永远做最重要的事情（你学的足够快吗？）\"><a href=\"#永远做最重要的事情（你学的足够快吗？）\" class=\"headerlink\" title=\"永远做最重要的事情（你学的足够快吗？）\"></a>永远做最重要的事情（你学的足够快吗？）</h3><blockquote>\n<p>我在这里想说几个我的观点：<br>我特别同意作者的，如果你把一个技术搞精搞深，你的知识面自然会很广的。<br>面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会。<br>为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。<br>不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。<br>永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。<br>很多东西在概念上是相通的，在哲学层次上是相通的，这是你需要去追求的学习知识的境界。<br>最后echo一下作者的话——“很多时候，你缺少的不是知识而是热情”！</p>\n</blockquote>\n<ul>\n<li>《易经》有云：“取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也”</li>\n</ul>\n<hr>\n<h2 id=\"程序员修养\"><a href=\"#程序员修养\" class=\"headerlink\" title=\"程序员修养\"></a>程序员修养</h2><ul>\n<li><p>提问的智慧（How To Ask Questions The Smart Way）<br><a href=\"http://www.catb.org/~esr/faqs/smart-questions.html\">How To Ask Questions The Smart Way</a></p>\n</li>\n<li><p>警惕X-Y问题<br><a href=\"https://coolshell.cn/articles/10804.html\">X-Y Problem</a> | 酷 壳 - CoolShell</p>\n</li>\n<li><p>《代码大全》</p>\n</li>\n<li><p>《重构：改善既有代码的设计》</p>\n<blockquote>\n<p>Code Review 对我的成长非常有帮助，我认为没有 Code Review 的公司都没有必要呆（因为不做 Code Review 的公司一定是不尊重技术的）</p>\n</blockquote>\n</li>\n<li><p>OWASP<br>美国联邦贸易委员会（FTC）强烈建议所有企业需遵循 OWASP 十大 Web 弱点防护守则。<br>OWASP Top 10 项目 是程序员非常需要关注的最基本的也是最严重的安全问题，现在其已经成了一种标准<br><a href=\"https://wiki.owasp.org/images/d/dc/OWASP_Top_10_2017_%E4%B8%AD%E6%96%87%E7%89%88v1.3.pdf\">OWASP Top 10</a> - 2017</p>\n</li>\n<li><p>HTTP 安全<br><a href=\"https://www.keycdn.com/blog/http-security-headers\">Hardening Your HTTP Security Headers</a> - KeyCDN</p>\n</li>\n<li><p>什么数据需要监控，指标<br><a href=\"https://www.datadoghq.com/blog/monitoring-101-collecting-data/\">Monitoring 101: Collecting the Right Data</a> | Datadog (datadoghq.com)</p>\n<ol>\n<li>Work Metrics<br>  ​<img src=\"/images/coder/Metrics1.png\" alt=\"image\">​</li>\n<li>Resource Metrics<br>  ​<img src=\"/images/coder/Metrics2.png\" alt=\"image\">​</li>\n<li>Event Metrics<br>  ​<img src=\"/images/coder/Metrics3.png\" alt=\"image\">​</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"程序员基础知识\"><a href=\"#程序员基础知识\" class=\"headerlink\" title=\"程序员基础知识\"></a>程序员基础知识</h2><h3 id=\"五种IO模型\"><a href=\"#五种IO模型\" class=\"headerlink\" title=\"五种IO模型\"></a>五种IO模型</h3><ul>\n<li>阻塞 I&#x2F;0</li>\n<li>非阻塞I&#x2F;0</li>\n<li>I&#x2F;O 的多路复用(select和 poll)</li>\n<li>信号驱动的 I&#x2F;O (SIGIO)</li>\n<li>异步 I&#x2F;O (POSIX的 aio functions)</li>\n</ul>\n<p><a href=\"https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\">Scalable IO in Java</a></p>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf\">JVM规范说明书</a><br>The Java® Virtual Machine Specification (oracle.com)</p>\n<p><a href=\"https://shipilev.net/jvm/anatomy-quarks/\">解剖JVM(JVM Anatomy Quarks)</a></p>\n<p>Java字节码，动态修改或是动态生成Java字节码<br><a href=\"https://dzone.com/articles/introduction-to-java-bytecode\">Introduction to Java Bytecode</a></p>\n<hr>\n<h3 id=\"分布式架构\"><a href=\"#分布式架构\" class=\"headerlink\" title=\"分布式架构\"></a>分布式架构</h3><p>分布式架构中的核心思想<br><a href=\"http://book.mixu.net/distsys/single-page.html\">Distributed systems for fun and profit</a></p>\n<p><a href=\"http://ddia.vonng.com/#/\">设计数据密集应用</a></p>\n<p><a href=\"http://nettee.github.io/posts/2016/Scalable-Web-Architecture-and-Distributed-Systems/\">可扩展的web架构和分布式系统</a></p>\n<p>软件即服务（SaaS）<br><a href=\"https://12factor.net/zh_cn/\">The Twelve-Factor App （简体中文） </a></p>\n<h4 id=\"自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有-Docker-和-Kubernetes-才是未来\"><a href=\"#自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有-Docker-和-Kubernetes-才是未来\" class=\"headerlink\" title=\"自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有 Docker 和 Kubernetes 才是未来!\"></a>自动化部署根本不够，还需要对环境和运行时的管理和运维才够，而只有 Docker 和 Kubernetes 才是未来!</h4><p>Docker使用<br><a href=\"https://docs.docker.com/get-started/overview/\">Docker overview</a></p>\n<p>Docker原理<br><a href=\"https://coolshell.cn/articles/17010.html\">Docker基础技术：Linux Namespace</a></p>"},{"title":"跨域问题总结","date":"2023-07-17T06:30:03.000Z","_content":"跨域问题产生的根本原因是浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)。同一个`源`，即同一*协议/主机/端口*元组的资源加载不会被限制。\n<!--more-->\n根据同源定义，不同端口或不同子域名的资源加载均会被同源策略拦截。其中，子域名页面脚本中可通过设置当前域名来规避：  \n``` js\ndocument.domain = \"company.com\";\n```\n如果确实是跨源了，则需要通过*跨源资源共享*（CORS）：\n![](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/cors_principle.png)\n\n## 预检请求\n预检请求是指在发起真正数据请求前，发起一个OPTIONS请求确认是否允许跨域，以避免跨域请求对服务器的用户数据产生未预期的影响。  \n\n## 简单请求，复杂请求\n可以简单的认为，没有预检请求的称为简单请求，反之则是复杂请求。  \n\n### 简单请求跨域访问\n使用 Origin 和 Access-Control-Allow-Origin就可以。服务端响应Header：\n```\nAccess-Control-Allow-Origin: *\nOrigin: \n```\n\n### 复杂请求跨域访问\n复杂请求的问题，主要是针对预检请求的处理:  \n1. 返回204状态码\n2. 需要跨源Header : `Access-Control-Allow-Origin`\n以下是一次POST请求示例：\n![](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/preflight_correct.png)\n以上示例中，重点为预检请求的服务端响应：\n``` yml\nAccess-Control-Allow-Origin: https://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\n# 单位为秒，表示时间段内无需对同一请求再次发起预检\nAccess-Control-Max-Age: 86400\n```\n\n### 1. web新增Filter处理跨域\n\n#### springboot项目\n``` java\n\t@Bean\n\tpublic CorsFilter corsFilter() {\n\t\tfinal UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();\n\t\tfinal CorsConfiguration corsConfiguration = new CorsConfiguration();\n\t\t/* 是否允许请求带有验证信息 */\n\t\tcorsConfiguration.setAllowCredentials(true);\n\t\t/* 允许访问的客户端域名 */\n\t\tcorsConfiguration.addAllowedOrigin(\"*\");\n\t\t/* 允许服务端访问的客户端请求头 */\n\t\tcorsConfiguration.addAllowedHeader(\"*\");\n\t\t/* 允许访问的方法名,GET POST等 */\n\t\tcorsConfiguration.addAllowedMethod(\"*\");\n\t\turlBasedCorsConfigurationSource.registerCorsConfiguration(\"/**\", corsConfiguration);\n\t\treturn new CorsFilter(urlBasedCorsConfigurationSource);\n\t}\n```\n\n#### spring项目\n``` java\nCORSFilter implements Filter\n.....\n    @Override\n   public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n        String origin = request.getHeader(\"Origin\");\n        response.setHeader(\"Access-Control-Allow-Origin\", origin);\n        response.setHeader(\"Access-Control-Allow-Methods\", \"GET,OPTIONS,POST,HEAD,PUT,DELETE\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Accept,Origin,X-Requested-With,Content-Type,X-Auth-Token,content-type,Authorization\");\n        response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n\n        // 防止点击劫持, 只允许自己域名的frame嵌套\n        response.addHeader(\"x-frame-options\",\"SAMEORIGIN\");\n\n        if (request.getMethod().equalsIgnoreCase(\"OPTIONS\")) {\n            response.setStatus(HttpServletResponse.SC_NO_CONTENT);\n            return;\n        }\n\n        chain.doFilter(servletRequest, servletResponse);\n\n   }\n```\n\n### 2. nginx配置处理跨域\n``` nginx\nlocation /\n    {\n\n        add_header Access-Control-Allow-Origin *;\n        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n        add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Auth-Token,Authorization';\n        add_header Access-Control-Max-Age 86400;\n        if ($request_method = 'OPTIONS') {\n                return 204;\n            }\n    }\n```\n\n### 预检请求携带证书问题\nCORS 预检请求不能包含凭据。预检请求的响应必须指定 `Access-Control-Allow-Credentials: true `来表明可以携带凭据进行实际的请求。  \n\n### 附带身份凭证cookie的跨域请求\n1. 首先允许`Access-Control-Allow-Headers`中必须要有该header名称，特别是自定义的。\n2. 服务端的`Access-Control-Allow-Origin`不能设置为`*`,而应将其设置为特定的域。比如在Filter中：\n``` java\nString origin = request.getHeader(\"Origin\");\nresponse.setHeader(\"Access-Control-Allow-Origin\", origin);\n```\n3. 服务端`Access-Control-Allow-Headers`不能为`*`\n4. 服务端`Access-Control-Allow-Methods`不能为`*`\n\n> 参考 [MSDN CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n","source":"_posts/跨域问题总结.md","raw":"---\ntitle: 跨域问题总结\ndate: 2023-07-17 14:30:03\ntags: \n- 跨域\ncategories: troubleshooting\n---\n跨域问题产生的根本原因是浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)。同一个`源`，即同一*协议/主机/端口*元组的资源加载不会被限制。\n<!--more-->\n根据同源定义，不同端口或不同子域名的资源加载均会被同源策略拦截。其中，子域名页面脚本中可通过设置当前域名来规避：  \n``` js\ndocument.domain = \"company.com\";\n```\n如果确实是跨源了，则需要通过*跨源资源共享*（CORS）：\n![](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/cors_principle.png)\n\n## 预检请求\n预检请求是指在发起真正数据请求前，发起一个OPTIONS请求确认是否允许跨域，以避免跨域请求对服务器的用户数据产生未预期的影响。  \n\n## 简单请求，复杂请求\n可以简单的认为，没有预检请求的称为简单请求，反之则是复杂请求。  \n\n### 简单请求跨域访问\n使用 Origin 和 Access-Control-Allow-Origin就可以。服务端响应Header：\n```\nAccess-Control-Allow-Origin: *\nOrigin: \n```\n\n### 复杂请求跨域访问\n复杂请求的问题，主要是针对预检请求的处理:  \n1. 返回204状态码\n2. 需要跨源Header : `Access-Control-Allow-Origin`\n以下是一次POST请求示例：\n![](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/preflight_correct.png)\n以上示例中，重点为预检请求的服务端响应：\n``` yml\nAccess-Control-Allow-Origin: https://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\n# 单位为秒，表示时间段内无需对同一请求再次发起预检\nAccess-Control-Max-Age: 86400\n```\n\n### 1. web新增Filter处理跨域\n\n#### springboot项目\n``` java\n\t@Bean\n\tpublic CorsFilter corsFilter() {\n\t\tfinal UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();\n\t\tfinal CorsConfiguration corsConfiguration = new CorsConfiguration();\n\t\t/* 是否允许请求带有验证信息 */\n\t\tcorsConfiguration.setAllowCredentials(true);\n\t\t/* 允许访问的客户端域名 */\n\t\tcorsConfiguration.addAllowedOrigin(\"*\");\n\t\t/* 允许服务端访问的客户端请求头 */\n\t\tcorsConfiguration.addAllowedHeader(\"*\");\n\t\t/* 允许访问的方法名,GET POST等 */\n\t\tcorsConfiguration.addAllowedMethod(\"*\");\n\t\turlBasedCorsConfigurationSource.registerCorsConfiguration(\"/**\", corsConfiguration);\n\t\treturn new CorsFilter(urlBasedCorsConfigurationSource);\n\t}\n```\n\n#### spring项目\n``` java\nCORSFilter implements Filter\n.....\n    @Override\n   public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n        String origin = request.getHeader(\"Origin\");\n        response.setHeader(\"Access-Control-Allow-Origin\", origin);\n        response.setHeader(\"Access-Control-Allow-Methods\", \"GET,OPTIONS,POST,HEAD,PUT,DELETE\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Accept,Origin,X-Requested-With,Content-Type,X-Auth-Token,content-type,Authorization\");\n        response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n\n        // 防止点击劫持, 只允许自己域名的frame嵌套\n        response.addHeader(\"x-frame-options\",\"SAMEORIGIN\");\n\n        if (request.getMethod().equalsIgnoreCase(\"OPTIONS\")) {\n            response.setStatus(HttpServletResponse.SC_NO_CONTENT);\n            return;\n        }\n\n        chain.doFilter(servletRequest, servletResponse);\n\n   }\n```\n\n### 2. nginx配置处理跨域\n``` nginx\nlocation /\n    {\n\n        add_header Access-Control-Allow-Origin *;\n        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n        add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Auth-Token,Authorization';\n        add_header Access-Control-Max-Age 86400;\n        if ($request_method = 'OPTIONS') {\n                return 204;\n            }\n    }\n```\n\n### 预检请求携带证书问题\nCORS 预检请求不能包含凭据。预检请求的响应必须指定 `Access-Control-Allow-Credentials: true `来表明可以携带凭据进行实际的请求。  \n\n### 附带身份凭证cookie的跨域请求\n1. 首先允许`Access-Control-Allow-Headers`中必须要有该header名称，特别是自定义的。\n2. 服务端的`Access-Control-Allow-Origin`不能设置为`*`,而应将其设置为特定的域。比如在Filter中：\n``` java\nString origin = request.getHeader(\"Origin\");\nresponse.setHeader(\"Access-Control-Allow-Origin\", origin);\n```\n3. 服务端`Access-Control-Allow-Headers`不能为`*`\n4. 服务端`Access-Control-Allow-Methods`不能为`*`\n\n> 参考 [MSDN CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n","slug":"跨域问题总结","published":1,"updated":"2024-04-11T03:38:03.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clw5r6ozl004sqwvddfhs673c","content":"<p>跨域问题产生的根本原因是浏览器的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a>。同一个<code>源</code>，即同一<em>协议&#x2F;主机&#x2F;端口</em>元组的资源加载不会被限制。</p>\n<span id=\"more\"></span>\n<p>根据同源定义，不同端口或不同子域名的资源加载均会被同源策略拦截。其中，子域名页面脚本中可通过设置当前域名来规避：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">&quot;company.com&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>如果确实是跨源了，则需要通过<em>跨源资源共享</em>（CORS）：<br><img src=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/cors_principle.png\"></p>\n<h2 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h2><p>预检请求是指在发起真正数据请求前，发起一个OPTIONS请求确认是否允许跨域，以避免跨域请求对服务器的用户数据产生未预期的影响。  </p>\n<h2 id=\"简单请求，复杂请求\"><a href=\"#简单请求，复杂请求\" class=\"headerlink\" title=\"简单请求，复杂请求\"></a>简单请求，复杂请求</h2><p>可以简单的认为，没有预检请求的称为简单请求，反之则是复杂请求。  </p>\n<h3 id=\"简单请求跨域访问\"><a href=\"#简单请求跨域访问\" class=\"headerlink\" title=\"简单请求跨域访问\"></a>简单请求跨域访问</h3><p>使用 Origin 和 Access-Control-Allow-Origin就可以。服务端响应Header：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: *</span><br><span class=\"line\">Origin: </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复杂请求跨域访问\"><a href=\"#复杂请求跨域访问\" class=\"headerlink\" title=\"复杂请求跨域访问\"></a>复杂请求跨域访问</h3><p>复杂请求的问题，主要是针对预检请求的处理:  </p>\n<ol>\n<li>返回204状态码</li>\n<li>需要跨源Header : <code>Access-Control-Allow-Origin</code><br>以下是一次POST请求示例：<br><img src=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/preflight_correct.png\"><br>以上示例中，重点为预检请求的服务端响应：<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Access-Control-Allow-Origin:</span> <span class=\"string\">https://foo.example</span></span><br><span class=\"line\"><span class=\"attr\">Access-Control-Allow-Methods:</span> <span class=\"string\">POST,</span> <span class=\"string\">GET,</span> <span class=\"string\">OPTIONS</span></span><br><span class=\"line\"><span class=\"attr\">Access-Control-Allow-Headers:</span> <span class=\"string\">X-PINGOTHER,</span> <span class=\"string\">Content-Type</span></span><br><span class=\"line\"><span class=\"comment\"># 单位为秒，表示时间段内无需对同一请求再次发起预检</span></span><br><span class=\"line\"><span class=\"attr\">Access-Control-Max-Age:</span> <span class=\"number\">86400</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"1-web新增Filter处理跨域\"><a href=\"#1-web新增Filter处理跨域\" class=\"headerlink\" title=\"1. web新增Filter处理跨域\"></a>1. web新增Filter处理跨域</h3><h4 id=\"springboot项目\"><a href=\"#springboot项目\" class=\"headerlink\" title=\"springboot项目\"></a>springboot项目</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CorsFilter <span class=\"title\">corsFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class=\"keyword\">new</span> UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> CorsConfiguration corsConfiguration = <span class=\"keyword\">new</span> CorsConfiguration();</span><br><span class=\"line\">\t<span class=\"comment\">/* 是否允许请求带有验证信息 */</span></span><br><span class=\"line\">\tcorsConfiguration.setAllowCredentials(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* 允许访问的客户端域名 */</span></span><br><span class=\"line\">\tcorsConfiguration.addAllowedOrigin(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* 允许服务端访问的客户端请求头 */</span></span><br><span class=\"line\">\tcorsConfiguration.addAllowedHeader(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* 允许访问的方法名,GET POST等 */</span></span><br><span class=\"line\">\tcorsConfiguration.addAllowedMethod(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">\turlBasedCorsConfigurationSource.registerCorsConfiguration(<span class=\"string\">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"spring项目\"><a href=\"#spring项目\" class=\"headerlink\" title=\"spring项目\"></a>spring项目</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CORSFilter implements Filter</span><br><span class=\"line\">.....</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class=\"line\">        HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">        String origin = request.getHeader(<span class=\"string\">&quot;Origin&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Methods&quot;</span>, <span class=\"string\">&quot;GET,OPTIONS,POST,HEAD,PUT,DELETE&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Max-Age&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, <span class=\"string\">&quot;Accept,Origin,X-Requested-With,Content-Type,X-Auth-Token,content-type,Authorization&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 防止点击劫持, 只允许自己域名的frame嵌套</span></span><br><span class=\"line\">        response.addHeader(<span class=\"string\">&quot;x-frame-options&quot;</span>,<span class=\"string\">&quot;SAMEORIGIN&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.getMethod().equalsIgnoreCase(<span class=\"string\">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class=\"line\">            response.setStatus(HttpServletResponse.SC_NO_CONTENT);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        chain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-nginx配置处理跨域\"><a href=\"#2-nginx配置处理跨域\" class=\"headerlink\" title=\"2. nginx配置处理跨域\"></a>2. nginx配置处理跨域</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">location</span> /</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;</span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Auth-Token,Authorization&#x27;</span>;</span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Max-Age <span class=\"number\">86400</span>;</span><br><span class=\"line\">        <span class=\"attribute\">if</span> ($request_method = <span class=\"string\">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"attribute\">return</span> <span class=\"number\">204</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"预检请求携带证书问题\"><a href=\"#预检请求携带证书问题\" class=\"headerlink\" title=\"预检请求携带证书问题\"></a>预检请求携带证书问题</h3><p>CORS 预检请求不能包含凭据。预检请求的响应必须指定 <code>Access-Control-Allow-Credentials: true </code>来表明可以携带凭据进行实际的请求。  </p>\n<h3 id=\"附带身份凭证cookie的跨域请求\"><a href=\"#附带身份凭证cookie的跨域请求\" class=\"headerlink\" title=\"附带身份凭证cookie的跨域请求\"></a>附带身份凭证cookie的跨域请求</h3><ol>\n<li>首先允许<code>Access-Control-Allow-Headers</code>中必须要有该header名称，特别是自定义的。</li>\n<li>服务端的<code>Access-Control-Allow-Origin</code>不能设置为<code>*</code>,而应将其设置为特定的域。比如在Filter中：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String origin = request.getHeader(<span class=\"string\">&quot;Origin&quot;</span>);</span><br><span class=\"line\">response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br></pre></td></tr></table></figure></li>\n<li>服务端<code>Access-Control-Allow-Headers</code>不能为<code>*</code></li>\n<li>服务端<code>Access-Control-Allow-Methods</code>不能为<code>*</code></li>\n</ol>\n<blockquote>\n<p>参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">MSDN CORS</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>跨域问题产生的根本原因是浏览器的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a>。同一个<code>源</code>，即同一<em>协议&#x2F;主机&#x2F;端口</em>元组的资源加载不会被限制。</p>","more":"<p>根据同源定义，不同端口或不同子域名的资源加载均会被同源策略拦截。其中，子域名页面脚本中可通过设置当前域名来规避：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">&quot;company.com&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>如果确实是跨源了，则需要通过<em>跨源资源共享</em>（CORS）：<br><img src=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/cors_principle.png\"></p>\n<h2 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h2><p>预检请求是指在发起真正数据请求前，发起一个OPTIONS请求确认是否允许跨域，以避免跨域请求对服务器的用户数据产生未预期的影响。  </p>\n<h2 id=\"简单请求，复杂请求\"><a href=\"#简单请求，复杂请求\" class=\"headerlink\" title=\"简单请求，复杂请求\"></a>简单请求，复杂请求</h2><p>可以简单的认为，没有预检请求的称为简单请求，反之则是复杂请求。  </p>\n<h3 id=\"简单请求跨域访问\"><a href=\"#简单请求跨域访问\" class=\"headerlink\" title=\"简单请求跨域访问\"></a>简单请求跨域访问</h3><p>使用 Origin 和 Access-Control-Allow-Origin就可以。服务端响应Header：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: *</span><br><span class=\"line\">Origin: </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复杂请求跨域访问\"><a href=\"#复杂请求跨域访问\" class=\"headerlink\" title=\"复杂请求跨域访问\"></a>复杂请求跨域访问</h3><p>复杂请求的问题，主要是针对预检请求的处理:  </p>\n<ol>\n<li>返回204状态码</li>\n<li>需要跨源Header : <code>Access-Control-Allow-Origin</code><br>以下是一次POST请求示例：<br><img src=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/preflight_correct.png\"><br>以上示例中，重点为预检请求的服务端响应：<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Access-Control-Allow-Origin:</span> <span class=\"string\">https://foo.example</span></span><br><span class=\"line\"><span class=\"attr\">Access-Control-Allow-Methods:</span> <span class=\"string\">POST,</span> <span class=\"string\">GET,</span> <span class=\"string\">OPTIONS</span></span><br><span class=\"line\"><span class=\"attr\">Access-Control-Allow-Headers:</span> <span class=\"string\">X-PINGOTHER,</span> <span class=\"string\">Content-Type</span></span><br><span class=\"line\"><span class=\"comment\"># 单位为秒，表示时间段内无需对同一请求再次发起预检</span></span><br><span class=\"line\"><span class=\"attr\">Access-Control-Max-Age:</span> <span class=\"number\">86400</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"1-web新增Filter处理跨域\"><a href=\"#1-web新增Filter处理跨域\" class=\"headerlink\" title=\"1. web新增Filter处理跨域\"></a>1. web新增Filter处理跨域</h3><h4 id=\"springboot项目\"><a href=\"#springboot项目\" class=\"headerlink\" title=\"springboot项目\"></a>springboot项目</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CorsFilter <span class=\"title\">corsFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class=\"keyword\">new</span> UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> CorsConfiguration corsConfiguration = <span class=\"keyword\">new</span> CorsConfiguration();</span><br><span class=\"line\">\t<span class=\"comment\">/* 是否允许请求带有验证信息 */</span></span><br><span class=\"line\">\tcorsConfiguration.setAllowCredentials(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* 允许访问的客户端域名 */</span></span><br><span class=\"line\">\tcorsConfiguration.addAllowedOrigin(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* 允许服务端访问的客户端请求头 */</span></span><br><span class=\"line\">\tcorsConfiguration.addAllowedHeader(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* 允许访问的方法名,GET POST等 */</span></span><br><span class=\"line\">\tcorsConfiguration.addAllowedMethod(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">\turlBasedCorsConfigurationSource.registerCorsConfiguration(<span class=\"string\">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"spring项目\"><a href=\"#spring项目\" class=\"headerlink\" title=\"spring项目\"></a>spring项目</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CORSFilter implements Filter</span><br><span class=\"line\">.....</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class=\"line\">        HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">        String origin = request.getHeader(<span class=\"string\">&quot;Origin&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Methods&quot;</span>, <span class=\"string\">&quot;GET,OPTIONS,POST,HEAD,PUT,DELETE&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Max-Age&quot;</span>, <span class=\"string\">&quot;3600&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, <span class=\"string\">&quot;Accept,Origin,X-Requested-With,Content-Type,X-Auth-Token,content-type,Authorization&quot;</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 防止点击劫持, 只允许自己域名的frame嵌套</span></span><br><span class=\"line\">        response.addHeader(<span class=\"string\">&quot;x-frame-options&quot;</span>,<span class=\"string\">&quot;SAMEORIGIN&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.getMethod().equalsIgnoreCase(<span class=\"string\">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class=\"line\">            response.setStatus(HttpServletResponse.SC_NO_CONTENT);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        chain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-nginx配置处理跨域\"><a href=\"#2-nginx配置处理跨域\" class=\"headerlink\" title=\"2. nginx配置处理跨域\"></a>2. nginx配置处理跨域</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">location</span> /</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;</span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-Auth-Token,Authorization&#x27;</span>;</span><br><span class=\"line\">        <span class=\"attribute\">add_header</span> Access-Control-Max-Age <span class=\"number\">86400</span>;</span><br><span class=\"line\">        <span class=\"attribute\">if</span> ($request_method = <span class=\"string\">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"attribute\">return</span> <span class=\"number\">204</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"预检请求携带证书问题\"><a href=\"#预检请求携带证书问题\" class=\"headerlink\" title=\"预检请求携带证书问题\"></a>预检请求携带证书问题</h3><p>CORS 预检请求不能包含凭据。预检请求的响应必须指定 <code>Access-Control-Allow-Credentials: true </code>来表明可以携带凭据进行实际的请求。  </p>\n<h3 id=\"附带身份凭证cookie的跨域请求\"><a href=\"#附带身份凭证cookie的跨域请求\" class=\"headerlink\" title=\"附带身份凭证cookie的跨域请求\"></a>附带身份凭证cookie的跨域请求</h3><ol>\n<li>首先允许<code>Access-Control-Allow-Headers</code>中必须要有该header名称，特别是自定义的。</li>\n<li>服务端的<code>Access-Control-Allow-Origin</code>不能设置为<code>*</code>,而应将其设置为特定的域。比如在Filter中：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String origin = request.getHeader(<span class=\"string\">&quot;Origin&quot;</span>);</span><br><span class=\"line\">response.setHeader(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br></pre></td></tr></table></figure></li>\n<li>服务端<code>Access-Control-Allow-Headers</code>不能为<code>*</code></li>\n<li>服务端<code>Access-Control-Allow-Methods</code>不能为<code>*</code></li>\n</ol>\n<blockquote>\n<p>参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">MSDN CORS</a></p>\n</blockquote>"},{"title":"理解Raft简述","date":"2024-04-29T08:03:13.000Z","_content":"Raft是一种共识算法，用于解决分布式系统中的一致性问题。Raft细节虽多，但算法并不晦涩、神秘\n<!--more-->\n声明：本文参考[Raft中文翻译](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)结合自己理解完成，更深入全面的Raft，请关注[Raft官网](https://raft.github.io/)\n\n为了详细解释Raft算法，作者将问题分解成三个问题：领导人选举、日志复制和安全性及成员变更。\n\n但是，在这之前，还需要了解下Raft的背景和基础设计。\n\n‍\n\n## 一、Raft背景及基础\n\n### 1.1 复制状态机\n\n一致性算法是从复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。\n\n​![image](/images/assets/image-20240509100554-j5ulk0q.png)​\n\n复制状态机通常都是基于复制日志实现的，因此Raft算法其实保证的就是集群日志的一致性。\n\n‍\n\n### 1.2 Raft算法基础概念\n\nRaft共识算法中包含以下角色：\n\n* 领导者（Leader）：负责接收客户端的请求，并将其复制到其他节点的日志中。领导者负责发起选举、维护心跳以及处理来自其他节点的请求。\n* 跟随者（Follower）： 跟随者是Raft集群中的普通节点角色，它们只是被动地响应来自领导者的请求，并根据领导者的指示更新自己的状态。\n* 候选人（Candidate）： 当Raft集群中没有领导者时，节点会转变为候选人角色，并发起选举以尝试成为新的领导者。候选人会向其他节点发送投票请求，如果获得多数节点的投票，则成为新的领导者。\n\n角色流转示意图：\n\n![image](/images/assets/image-20240508174543-ue2vter.png)​\n\nRaft用任期(term)来表示角色变更的基本时间单位：\n\n​![image](/images/assets/image-20240514143508-npmef32.png)​\n\n时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束\n\n‍\n\n## 二、Leader选举\n\nRaft 使用一种心跳机制来触发领导人选举。  \n要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点来给自己投票。\n\n选举的结果可能有3中结果：1）自己成为Leader 2）别人成为Leader 3）选票被瓜分，选举失败\n\n## 三、日志复制\n\n### 3.1 理想的日志复制\n\n​![image](/images/assets/image-20240514145801-mfzjlbf.png)​\n\n### 3.2 会导致冲突的日志复制\n\n​![image](/images/assets/image-20240514152040-m7ea0hd.png)​\n\n领导人和跟随者日志不一致场景，丢失或者多出日志条目可能会持续多个任期。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。\n\n‍\n\n在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。\n\n要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。\n\n‍\n\n## 四、安全性\n\n通过选举和日志复制，并不能保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目。因此，需要在领导选举的时候增加一些限制来完善 Raft 算法。\n\n### 4.1 选举限制\n\n在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。\n\n### 4.2 提交之前任期内的日志条目\n\n当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号。\n\n### 4.3 安全性论证\n\n假设领导人完全性特性是不存在的，通过反推出矛盾来论证算法的安全性。\n\n‍\n\n* 一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）\n\n  |特性|解释|\n  | ------------------| --------------------------------------------------------------------------------------------------------------------------|\n  |选举安全特性|对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）|\n  |领导人只附加原则|领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）|\n  |日志匹配原则|如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节）|\n  |领导人完全特性|如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）|\n  |状态机安全特性|如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节）|\n\n‍\n\n‍\n","source":"_posts/理解Raft简述.md","raw":"---\ntitle: 理解Raft简述\ndate: 2024-04-29 16:03:13\ntags:\n- Raft\ncategories: 其他\n---\nRaft是一种共识算法，用于解决分布式系统中的一致性问题。Raft细节虽多，但算法并不晦涩、神秘\n<!--more-->\n声明：本文参考[Raft中文翻译](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)结合自己理解完成，更深入全面的Raft，请关注[Raft官网](https://raft.github.io/)\n\n为了详细解释Raft算法，作者将问题分解成三个问题：领导人选举、日志复制和安全性及成员变更。\n\n但是，在这之前，还需要了解下Raft的背景和基础设计。\n\n‍\n\n## 一、Raft背景及基础\n\n### 1.1 复制状态机\n\n一致性算法是从复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。\n\n​![image](/images/assets/image-20240509100554-j5ulk0q.png)​\n\n复制状态机通常都是基于复制日志实现的，因此Raft算法其实保证的就是集群日志的一致性。\n\n‍\n\n### 1.2 Raft算法基础概念\n\nRaft共识算法中包含以下角色：\n\n* 领导者（Leader）：负责接收客户端的请求，并将其复制到其他节点的日志中。领导者负责发起选举、维护心跳以及处理来自其他节点的请求。\n* 跟随者（Follower）： 跟随者是Raft集群中的普通节点角色，它们只是被动地响应来自领导者的请求，并根据领导者的指示更新自己的状态。\n* 候选人（Candidate）： 当Raft集群中没有领导者时，节点会转变为候选人角色，并发起选举以尝试成为新的领导者。候选人会向其他节点发送投票请求，如果获得多数节点的投票，则成为新的领导者。\n\n角色流转示意图：\n\n![image](/images/assets/image-20240508174543-ue2vter.png)​\n\nRaft用任期(term)来表示角色变更的基本时间单位：\n\n​![image](/images/assets/image-20240514143508-npmef32.png)​\n\n时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束\n\n‍\n\n## 二、Leader选举\n\nRaft 使用一种心跳机制来触发领导人选举。  \n要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点来给自己投票。\n\n选举的结果可能有3中结果：1）自己成为Leader 2）别人成为Leader 3）选票被瓜分，选举失败\n\n## 三、日志复制\n\n### 3.1 理想的日志复制\n\n​![image](/images/assets/image-20240514145801-mfzjlbf.png)​\n\n### 3.2 会导致冲突的日志复制\n\n​![image](/images/assets/image-20240514152040-m7ea0hd.png)​\n\n领导人和跟随者日志不一致场景，丢失或者多出日志条目可能会持续多个任期。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。\n\n‍\n\n在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。\n\n要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。\n\n‍\n\n## 四、安全性\n\n通过选举和日志复制，并不能保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目。因此，需要在领导选举的时候增加一些限制来完善 Raft 算法。\n\n### 4.1 选举限制\n\n在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。\n\n### 4.2 提交之前任期内的日志条目\n\n当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号。\n\n### 4.3 安全性论证\n\n假设领导人完全性特性是不存在的，通过反推出矛盾来论证算法的安全性。\n\n‍\n\n* 一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）\n\n  |特性|解释|\n  | ------------------| --------------------------------------------------------------------------------------------------------------------------|\n  |选举安全特性|对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）|\n  |领导人只附加原则|领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）|\n  |日志匹配原则|如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节）|\n  |领导人完全特性|如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）|\n  |状态机安全特性|如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节）|\n\n‍\n\n‍\n","slug":"理解Raft简述","published":1,"updated":"2024-05-14T10:07:37.291Z","_id":"clw68as2k00003gvd8yt99gry","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Raft是一种共识算法，用于解决分布式系统中的一致性问题。Raft细节虽多，但算法并不晦涩、神秘</p>\n<span id=\"more\"></span>\n<p>声明：本文参考<a href=\"https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md\">Raft中文翻译</a>结合自己理解完成，更深入全面的Raft，请关注<a href=\"https://raft.github.io/\">Raft官网</a></p>\n<p>为了详细解释Raft算法，作者将问题分解成三个问题：领导人选举、日志复制和安全性及成员变更。</p>\n<p>但是，在这之前，还需要了解下Raft的背景和基础设计。</p>\n<p>‍</p>\n<h2 id=\"一、Raft背景及基础\"><a href=\"#一、Raft背景及基础\" class=\"headerlink\" title=\"一、Raft背景及基础\"></a>一、Raft背景及基础</h2><h3 id=\"1-1-复制状态机\"><a href=\"#1-1-复制状态机\" class=\"headerlink\" title=\"1.1 复制状态机\"></a>1.1 复制状态机</h3><p>一致性算法是从复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。</p>\n<p>​<img src=\"/images/assets/image-20240509100554-j5ulk0q.png\" alt=\"image\">​</p>\n<p>复制状态机通常都是基于复制日志实现的，因此Raft算法其实保证的就是集群日志的一致性。</p>\n<p>‍</p>\n<h3 id=\"1-2-Raft算法基础概念\"><a href=\"#1-2-Raft算法基础概念\" class=\"headerlink\" title=\"1.2 Raft算法基础概念\"></a>1.2 Raft算法基础概念</h3><p>Raft共识算法中包含以下角色：</p>\n<ul>\n<li>领导者（Leader）：负责接收客户端的请求，并将其复制到其他节点的日志中。领导者负责发起选举、维护心跳以及处理来自其他节点的请求。</li>\n<li>跟随者（Follower）： 跟随者是Raft集群中的普通节点角色，它们只是被动地响应来自领导者的请求，并根据领导者的指示更新自己的状态。</li>\n<li>候选人（Candidate）： 当Raft集群中没有领导者时，节点会转变为候选人角色，并发起选举以尝试成为新的领导者。候选人会向其他节点发送投票请求，如果获得多数节点的投票，则成为新的领导者。</li>\n</ul>\n<p>角色流转示意图：</p>\n<p><img src=\"/images/assets/image-20240508174543-ue2vter.png\" alt=\"image\">​</p>\n<p>Raft用任期(term)来表示角色变更的基本时间单位：</p>\n<p>​<img src=\"/images/assets/image-20240514143508-npmef32.png\" alt=\"image\">​</p>\n<p>时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束</p>\n<p>‍</p>\n<h2 id=\"二、Leader选举\"><a href=\"#二、Leader选举\" class=\"headerlink\" title=\"二、Leader选举\"></a>二、Leader选举</h2><p>Raft 使用一种心跳机制来触发领导人选举。<br>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点来给自己投票。</p>\n<p>选举的结果可能有3中结果：1）自己成为Leader 2）别人成为Leader 3）选票被瓜分，选举失败</p>\n<h2 id=\"三、日志复制\"><a href=\"#三、日志复制\" class=\"headerlink\" title=\"三、日志复制\"></a>三、日志复制</h2><h3 id=\"3-1-理想的日志复制\"><a href=\"#3-1-理想的日志复制\" class=\"headerlink\" title=\"3.1 理想的日志复制\"></a>3.1 理想的日志复制</h3><p>​<img src=\"/images/assets/image-20240514145801-mfzjlbf.png\" alt=\"image\">​</p>\n<h3 id=\"3-2-会导致冲突的日志复制\"><a href=\"#3-2-会导致冲突的日志复制\" class=\"headerlink\" title=\"3.2 会导致冲突的日志复制\"></a>3.2 会导致冲突的日志复制</h3><p>​<img src=\"/images/assets/image-20240514152040-m7ea0hd.png\" alt=\"image\">​</p>\n<p>领导人和跟随者日志不一致场景，丢失或者多出日志条目可能会持续多个任期。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p>\n<p>‍</p>\n<p>在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。</p>\n<p>要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。</p>\n<p>‍</p>\n<h2 id=\"四、安全性\"><a href=\"#四、安全性\" class=\"headerlink\" title=\"四、安全性\"></a>四、安全性</h2><p>通过选举和日志复制，并不能保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目。因此，需要在领导选举的时候增加一些限制来完善 Raft 算法。</p>\n<h3 id=\"4-1-选举限制\"><a href=\"#4-1-选举限制\" class=\"headerlink\" title=\"4.1 选举限制\"></a>4.1 选举限制</h3><p>在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。</p>\n<h3 id=\"4-2-提交之前任期内的日志条目\"><a href=\"#4-2-提交之前任期内的日志条目\" class=\"headerlink\" title=\"4.2 提交之前任期内的日志条目\"></a>4.2 提交之前任期内的日志条目</h3><p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号。</p>\n<h3 id=\"4-3-安全性论证\"><a href=\"#4-3-安全性论证\" class=\"headerlink\" title=\"4.3 安全性论证\"></a>4.3 安全性论证</h3><p>假设领导人完全性特性是不存在的，通过反推出矛盾来论证算法的安全性。</p>\n<p>‍</p>\n<ul>\n<li><p>一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>选举安全特性</td>\n<td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）</td>\n</tr>\n<tr>\n<td>领导人只附加原则</td>\n<td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td>\n</tr>\n<tr>\n<td>日志匹配原则</td>\n<td>如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节）</td>\n</tr>\n<tr>\n<td>领导人完全特性</td>\n<td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td>\n</tr>\n<tr>\n<td>状态机安全特性</td>\n<td>如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节）</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>‍</p>\n<p>‍</p>\n","site":{"data":{}},"excerpt":"<p>Raft是一种共识算法，用于解决分布式系统中的一致性问题。Raft细节虽多，但算法并不晦涩、神秘</p>","more":"<p>声明：本文参考<a href=\"https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md\">Raft中文翻译</a>结合自己理解完成，更深入全面的Raft，请关注<a href=\"https://raft.github.io/\">Raft官网</a></p>\n<p>为了详细解释Raft算法，作者将问题分解成三个问题：领导人选举、日志复制和安全性及成员变更。</p>\n<p>但是，在这之前，还需要了解下Raft的背景和基础设计。</p>\n<p>‍</p>\n<h2 id=\"一、Raft背景及基础\"><a href=\"#一、Raft背景及基础\" class=\"headerlink\" title=\"一、Raft背景及基础\"></a>一、Raft背景及基础</h2><h3 id=\"1-1-复制状态机\"><a href=\"#1-1-复制状态机\" class=\"headerlink\" title=\"1.1 复制状态机\"></a>1.1 复制状态机</h3><p>一致性算法是从复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。</p>\n<p>​<img src=\"/images/assets/image-20240509100554-j5ulk0q.png\" alt=\"image\">​</p>\n<p>复制状态机通常都是基于复制日志实现的，因此Raft算法其实保证的就是集群日志的一致性。</p>\n<p>‍</p>\n<h3 id=\"1-2-Raft算法基础概念\"><a href=\"#1-2-Raft算法基础概念\" class=\"headerlink\" title=\"1.2 Raft算法基础概念\"></a>1.2 Raft算法基础概念</h3><p>Raft共识算法中包含以下角色：</p>\n<ul>\n<li>领导者（Leader）：负责接收客户端的请求，并将其复制到其他节点的日志中。领导者负责发起选举、维护心跳以及处理来自其他节点的请求。</li>\n<li>跟随者（Follower）： 跟随者是Raft集群中的普通节点角色，它们只是被动地响应来自领导者的请求，并根据领导者的指示更新自己的状态。</li>\n<li>候选人（Candidate）： 当Raft集群中没有领导者时，节点会转变为候选人角色，并发起选举以尝试成为新的领导者。候选人会向其他节点发送投票请求，如果获得多数节点的投票，则成为新的领导者。</li>\n</ul>\n<p>角色流转示意图：</p>\n<p><img src=\"/images/assets/image-20240508174543-ue2vter.png\" alt=\"image\">​</p>\n<p>Raft用任期(term)来表示角色变更的基本时间单位：</p>\n<p>​<img src=\"/images/assets/image-20240514143508-npmef32.png\" alt=\"image\">​</p>\n<p>时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束</p>\n<p>‍</p>\n<h2 id=\"二、Leader选举\"><a href=\"#二、Leader选举\" class=\"headerlink\" title=\"二、Leader选举\"></a>二、Leader选举</h2><p>Raft 使用一种心跳机制来触发领导人选举。<br>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点来给自己投票。</p>\n<p>选举的结果可能有3中结果：1）自己成为Leader 2）别人成为Leader 3）选票被瓜分，选举失败</p>\n<h2 id=\"三、日志复制\"><a href=\"#三、日志复制\" class=\"headerlink\" title=\"三、日志复制\"></a>三、日志复制</h2><h3 id=\"3-1-理想的日志复制\"><a href=\"#3-1-理想的日志复制\" class=\"headerlink\" title=\"3.1 理想的日志复制\"></a>3.1 理想的日志复制</h3><p>​<img src=\"/images/assets/image-20240514145801-mfzjlbf.png\" alt=\"image\">​</p>\n<h3 id=\"3-2-会导致冲突的日志复制\"><a href=\"#3-2-会导致冲突的日志复制\" class=\"headerlink\" title=\"3.2 会导致冲突的日志复制\"></a>3.2 会导致冲突的日志复制</h3><p>​<img src=\"/images/assets/image-20240514152040-m7ea0hd.png\" alt=\"image\">​</p>\n<p>领导人和跟随者日志不一致场景，丢失或者多出日志条目可能会持续多个任期。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p>\n<p>‍</p>\n<p>在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。</p>\n<p>要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。</p>\n<p>‍</p>\n<h2 id=\"四、安全性\"><a href=\"#四、安全性\" class=\"headerlink\" title=\"四、安全性\"></a>四、安全性</h2><p>通过选举和日志复制，并不能保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目。因此，需要在领导选举的时候增加一些限制来完善 Raft 算法。</p>\n<h3 id=\"4-1-选举限制\"><a href=\"#4-1-选举限制\" class=\"headerlink\" title=\"4.1 选举限制\"></a>4.1 选举限制</h3><p>在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。</p>\n<h3 id=\"4-2-提交之前任期内的日志条目\"><a href=\"#4-2-提交之前任期内的日志条目\" class=\"headerlink\" title=\"4.2 提交之前任期内的日志条目\"></a>4.2 提交之前任期内的日志条目</h3><p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号。</p>\n<h3 id=\"4-3-安全性论证\"><a href=\"#4-3-安全性论证\" class=\"headerlink\" title=\"4.3 安全性论证\"></a>4.3 安全性论证</h3><p>假设领导人完全性特性是不存在的，通过反推出矛盾来论证算法的安全性。</p>\n<p>‍</p>\n<ul>\n<li><p>一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>选举安全特性</td>\n<td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）</td>\n</tr>\n<tr>\n<td>领导人只附加原则</td>\n<td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td>\n</tr>\n<tr>\n<td>日志匹配原则</td>\n<td>如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节）</td>\n</tr>\n<tr>\n<td>领导人完全特性</td>\n<td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td>\n</tr>\n<tr>\n<td>状态机安全特性</td>\n<td>如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节）</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>‍</p>\n<p>‍</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"clw5r6oyh0001qwvdfuqcd0wr","category_id":"clw5r6oyl0004qwvd4348a0h2","_id":"clw5r6oyq000gqwvd54x5e3rv"},{"post_id":"clw5r6oyp000eqwvdg8796kmf","category_id":"clw5r6oyl0004qwvd4348a0h2","_id":"clw5r6oys000lqwvddh3vhe4s"},{"post_id":"clw5r6oyk0003qwvd0g5c2b5x","category_id":"clw5r6oyp000bqwvddzitdfy1","_id":"clw5r6oyu000pqwvdeczp18lw"},{"post_id":"clw5r6oym0007qwvd38is4nfg","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oyv000uqwvdhxty7v2b"},{"post_id":"clw5r6oyr000kqwvd17bke0pd","category_id":"clw5r6oyp000bqwvddzitdfy1","_id":"clw5r6oyw000xqwvd1rrf9ikt"},{"post_id":"clw5r6oyt000oqwvd75mt7p2v","category_id":"clw5r6oyl0004qwvd4348a0h2","_id":"clw5r6oyx0011qwvd1axm58t7"},{"post_id":"clw5r6oyo0009qwvd6ji90kws","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oyx0014qwvddx7x7a0o"},{"post_id":"clw5r6oyo000aqwvd1y9v1f0n","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oyy0017qwvd252j898h"},{"post_id":"clw5r6oyx0012qwvdc5fth7zh","category_id":"clw5r6oyp000bqwvddzitdfy1","_id":"clw5r6oyz001bqwvdedlzekrw"},{"post_id":"clw5r6oyq000fqwvd0v3eh49p","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz0001fqwvdfdg9fqvg"},{"post_id":"clw5r6oyx0015qwvd8ggbbis0","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz1001jqwvd460ef6l5"},{"post_id":"clw5r6oyy0018qwvdaly5bt4q","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz1001mqwvdhxy4ggke"},{"post_id":"clw5r6oyv000wqwvdad6ver4m","category_id":"clw5r6oyy0016qwvdbss7gig8","_id":"clw5r6oz2001qqwvd74sshq79"},{"post_id":"clw5r6oyz001aqwvdgkjh86e5","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz3001sqwvdgkfjftik"},{"post_id":"clw5r6oyz001eqwvd58z0ddan","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz3001vqwvdboxs09rm"},{"post_id":"clw5r6oyw000zqwvd1svj85cw","category_id":"clw5r6oyy0016qwvdbss7gig8","_id":"clw5r6oz4001zqwvde8tnh2hs"},{"post_id":"clw5r6oz1001lqwvd01wq6ner","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz40022qwvd78fkeiq6"},{"post_id":"clw5r6oz2001rqwvdhkyl1c9a","category_id":"clw5r6oz1001nqwvd8svuaifr","_id":"clw5r6oz50025qwvdhg6z3ezp"},{"post_id":"clw5r6oz0001iqwvdbyr64na1","category_id":"clw5r6oz1001nqwvd8svuaifr","_id":"clw5r6oz60028qwvd74h2bgqs"},{"post_id":"clw5r6oz3001tqwvd64aohyrr","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz6002bqwvdfs254ga6"},{"post_id":"clw5r6oz4001yqwvdfcm1c9d3","category_id":"clw5r6oz1001nqwvd8svuaifr","_id":"clw5r6oz7002dqwvdd0968q63"},{"post_id":"clw5r6oz2001pqwvd6k4uful5","category_id":"clw5r6oz3001uqwvdbha0gfqf","_id":"clw5r6oz8002hqwvdaf9nb76a"},{"post_id":"clw5r6oz40021qwvdgeireref","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oz8002kqwvd0toq37fg"},{"post_id":"clw5r6oz50024qwvdclpq2zbu","category_id":"clw5r6oz1001nqwvd8svuaifr","_id":"clw5r6oz9002oqwvd2cm2c55h"},{"post_id":"clw5r6oz50027qwvdfi0xbonb","category_id":"clw5r6oyy0016qwvdbss7gig8","_id":"clw5r6oz9002sqwvdelnf5he6"},{"post_id":"clw5r6oz8002jqwvdb1cta7xy","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6oza002uqwvd98pc5kpi"},{"post_id":"clw5r6oz6002aqwvdd2j08ho0","category_id":"clw5r6oz7002eqwvddeythy3f","_id":"clw5r6oza002xqwvdh5km2sg0"},{"post_id":"clw5r6oz8002mqwvde58i7bxk","category_id":"clw5r6oyy0016qwvdbss7gig8","_id":"clw5r6oza002zqwvd0dnje3a5"},{"post_id":"clw5r6oz9002rqwvdeax168jx","category_id":"clw5r6oyy0016qwvdbss7gig8","_id":"clw5r6oza0031qwvdch6p30jg"},{"post_id":"clw5r6oz6002cqwvd5w9u51dp","category_id":"clw5r6oz7002eqwvddeythy3f","_id":"clw5r6oza0033qwvdhogqgyon"},{"post_id":"clw5r6oz7002gqwvdexwef26x","category_id":"clw5r6oz7002eqwvddeythy3f","_id":"clw5r6ozb0035qwvdbg0f287n"},{"post_id":"clw5r6ozi004dqwvd85bm0isj","category_id":"clw5r6oyy0016qwvdbss7gig8","_id":"clw5r6ozj004iqwvd0ozpad6v"},{"post_id":"clw5r6ozi004eqwvdet7q60pg","category_id":"clw5r6oz3001uqwvdbha0gfqf","_id":"clw5r6ozk004kqwvd2sj50ivh"},{"post_id":"clw5r6ozj004gqwvdc6ho3sqr","category_id":"clw5r6oz7002eqwvddeythy3f","_id":"clw5r6ozk004oqwvd2rmy9nnq"},{"post_id":"clw5r6ozj004hqwvd9hned9zb","category_id":"clw5r6oyy0016qwvdbss7gig8","_id":"clw5r6ozl004qqwvdfowt2jvb"},{"post_id":"clw5r6ozk004jqwvdg0go4eed","category_id":"clw5r6oyl0004qwvd4348a0h2","_id":"clw5r6ozm004tqwvd9q408zrl"},{"post_id":"clw5r6ozk004nqwvd7p2i3n40","category_id":"clw5r6oyq000hqwvdcmkr257k","_id":"clw5r6ozm004vqwvd730m11vj"},{"post_id":"clw5r6ozl004pqwvd4j7hg0zx","category_id":"clw5r6oyl0004qwvd4348a0h2","_id":"clw5r6ozm004xqwvdhcz773jf"},{"post_id":"clw5r6ozl004sqwvddfhs673c","category_id":"clw5r6oz3001uqwvdbha0gfqf","_id":"clw5r6ozm004zqwvdaw71dz1x"},{"post_id":"clw68as2k00003gvd8yt99gry","category_id":"clw5r6oyl0004qwvd4348a0h2","_id":"clw68as3100023gvdh3gb3ng2"}],"PostTag":[{"post_id":"clw5r6oyh0001qwvdfuqcd0wr","tag_id":"clw5r6oym0005qwvdhu7ge7cc","_id":"clw5r6oyp000dqwvd6ckegw8e"},{"post_id":"clw5r6oyk0003qwvd0g5c2b5x","tag_id":"clw5r6oyp000cqwvdg8go11nl","_id":"clw5r6oyu000qqwvda5wkfb43"},{"post_id":"clw5r6oyk0003qwvd0g5c2b5x","tag_id":"clw5r6oyr000iqwvdgi9ea9c4","_id":"clw5r6oyv000sqwvdgwqxb2gm"},{"post_id":"clw5r6oym0007qwvd38is4nfg","tag_id":"clw5r6oys000nqwvdhj0wcj9z","_id":"clw5r6oyw000yqwvd4bmx9z2i"},{"post_id":"clw5r6oyo0009qwvd6ji90kws","tag_id":"clw5r6oyv000vqwvddfwtg71c","_id":"clw5r6oyz001cqwvderq00u4o"},{"post_id":"clw5r6oyo0009qwvd6ji90kws","tag_id":"clw5r6oyx0013qwvd1zgi9z37","_id":"clw5r6oz0001gqwvd80dt7lzw"},{"post_id":"clw5r6oyo000aqwvd1y9v1f0n","tag_id":"clw5r6oyz0019qwvdfaao5h5c","_id":"clw5r6oz1001kqwvdc5ry8jqk"},{"post_id":"clw5r6oyp000eqwvdg8796kmf","tag_id":"clw5r6oz0001hqwvd2oifdk2z","_id":"clw5r6oz3001xqwvdf64u7eep"},{"post_id":"clw5r6oyp000eqwvdg8796kmf","tag_id":"clw5r6oz2001oqwvd1wth3sd0","_id":"clw5r6oz40020qwvd18ak0q68"},{"post_id":"clw5r6oyq000fqwvd0v3eh49p","tag_id":"clw5r6oz3001wqwvd1cnq0cv9","_id":"clw5r6oz50026qwvdaxx1bt5c"},{"post_id":"clw5r6oyr000kqwvd17bke0pd","tag_id":"clw5r6oz50023qwvd6qjy9iz2","_id":"clw5r6oz8002iqwvd59m1dnua"},{"post_id":"clw5r6oyr000kqwvd17bke0pd","tag_id":"clw5r6oz60029qwvd2nk57n5o","_id":"clw5r6oz8002lqwvd0bn3clsf"},{"post_id":"clw5r6oyt000oqwvd75mt7p2v","tag_id":"clw5r6oz7002fqwvdf61h8f2s","_id":"clw5r6oz9002qqwvd4riogkef"},{"post_id":"clw5r6oz9002rqwvdeax168jx","tag_id":"clw5r6oz9002pqwvdcw1qbksb","_id":"clw5r6oza002wqwvd107lhz1q"},{"post_id":"clw5r6oyv000wqwvdad6ver4m","tag_id":"clw5r6oz9002pqwvdcw1qbksb","_id":"clw5r6oza002yqwvdet3rcoj8"},{"post_id":"clw5r6oyw000zqwvd1svj85cw","tag_id":"clw5r6oza002vqwvd3tjc4gx0","_id":"clw5r6oza0032qwvd203m8nyj"},{"post_id":"clw5r6oyx0012qwvdc5fth7zh","tag_id":"clw5r6oza0030qwvd5t2gb0ep","_id":"clw5r6ozb0036qwvd9d1eeotf"},{"post_id":"clw5r6oyx0015qwvd8ggbbis0","tag_id":"clw5r6ozb0034qwvdakkjcay9","_id":"clw5r6ozb0039qwvd5y4d6vws"},{"post_id":"clw5r6oyx0015qwvd8ggbbis0","tag_id":"clw5r6ozb0037qwvd5swvh5fx","_id":"clw5r6ozb003aqwvd9ny701tu"},{"post_id":"clw5r6oyy0018qwvdaly5bt4q","tag_id":"clw5r6ozb0034qwvdakkjcay9","_id":"clw5r6ozb003cqwvd59wzcamp"},{"post_id":"clw5r6oyz001aqwvdgkjh86e5","tag_id":"clw5r6ozb003bqwvddujme5is","_id":"clw5r6ozc003eqwvd12mpcl1v"},{"post_id":"clw5r6oyz001eqwvd58z0ddan","tag_id":"clw5r6ozb003bqwvddujme5is","_id":"clw5r6ozc003gqwvd27o752tt"},{"post_id":"clw5r6oz0001iqwvdbyr64na1","tag_id":"clw5r6ozc003fqwvdg36q6wqq","_id":"clw5r6ozc003iqwvda0je3m40"},{"post_id":"clw5r6oz1001lqwvd01wq6ner","tag_id":"clw5r6ozc003hqwvd6klzfh0n","_id":"clw5r6ozc003lqwvdf7jdci67"},{"post_id":"clw5r6oz1001lqwvd01wq6ner","tag_id":"clw5r6ozc003jqwvd8rzlfu3q","_id":"clw5r6ozc003mqwvdd1lr6op0"},{"post_id":"clw5r6oz2001pqwvd6k4uful5","tag_id":"clw5r6ozc003kqwvd93qre0aa","_id":"clw5r6ozd003oqwvd6qokg1t8"},{"post_id":"clw5r6oz2001rqwvdhkyl1c9a","tag_id":"clw5r6ozc003fqwvdg36q6wqq","_id":"clw5r6ozd003qqwvd0z8b17ey"},{"post_id":"clw5r6oz3001tqwvd64aohyrr","tag_id":"clw5r6ozd003pqwvd9s8e2hcj","_id":"clw5r6ozd003sqwvd2r6864m4"},{"post_id":"clw5r6oz4001yqwvdfcm1c9d3","tag_id":"clw5r6ozd003rqwvdd5ri4ng8","_id":"clw5r6ozd003uqwvde7jeg4q1"},{"post_id":"clw5r6oz40021qwvdgeireref","tag_id":"clw5r6ozd003tqwvdbyj43fjt","_id":"clw5r6ozd003wqwvd48g36b0x"},{"post_id":"clw5r6oz50024qwvdclpq2zbu","tag_id":"clw5r6ozd003vqwvd0bdm33lu","_id":"clw5r6oze003zqwvd3f278ady"},{"post_id":"clw5r6oz50024qwvdclpq2zbu","tag_id":"clw5r6ozd003xqwvd57oqcxhj","_id":"clw5r6oze0040qwvdggsz5hh6"},{"post_id":"clw5r6oz50024qwvdclpq2zbu","tag_id":"clw5r6oyr000iqwvdgi9ea9c4","_id":"clw5r6oze0042qwvdfngl3ikq"},{"post_id":"clw5r6oz50027qwvdfi0xbonb","tag_id":"clw5r6oze003yqwvd2i7v6eih","_id":"clw5r6oze0043qwvd4eat8e7p"},{"post_id":"clw5r6oz6002aqwvdd2j08ho0","tag_id":"clw5r6oze0041qwvdcoamdaef","_id":"clw5r6oze0045qwvd86276asq"},{"post_id":"clw5r6oz6002cqwvd5w9u51dp","tag_id":"clw5r6oze0041qwvdcoamdaef","_id":"clw5r6ozf0047qwvddpd6hpkj"},{"post_id":"clw5r6oz7002gqwvdexwef26x","tag_id":"clw5r6oze0041qwvdcoamdaef","_id":"clw5r6ozf0049qwvd39lk9fq1"},{"post_id":"clw5r6oz8002jqwvdb1cta7xy","tag_id":"clw5r6ozf0048qwvd52d1bl4h","_id":"clw5r6ozf004bqwvd2wv39969"},{"post_id":"clw5r6oz8002mqwvde58i7bxk","tag_id":"clw5r6oz9002pqwvdcw1qbksb","_id":"clw5r6ozf004cqwvddtvq3908"},{"post_id":"clw5r6ozi004dqwvd85bm0isj","tag_id":"clw5r6ozj004fqwvd1nlbfjay","_id":"clw5r6ozk004mqwvd3n455vc6"},{"post_id":"clw5r6ozi004eqwvdet7q60pg","tag_id":"clw5r6ozk004lqwvdd4vw4mmt","_id":"clw5r6ozm004uqwvd0dd3af94"},{"post_id":"clw5r6ozj004gqwvdc6ho3sqr","tag_id":"clw5r6ozl004rqwvd9vo17ajv","_id":"clw5r6ozm004yqwvd5hfe1epw"},{"post_id":"clw5r6ozj004hqwvd9hned9zb","tag_id":"clw5r6ozm004wqwvd9vnt3zx0","_id":"clw5r6ozm0052qwvdaa6294bt"},{"post_id":"clw5r6ozj004hqwvd9hned9zb","tag_id":"clw5r6ozm0050qwvdaum3bk9k","_id":"clw5r6ozm0053qwvd9febhveh"},{"post_id":"clw5r6ozk004jqwvdg0go4eed","tag_id":"clw5r6ozm0051qwvdf4t2gv7w","_id":"clw5r6ozn0055qwvd6orierfc"},{"post_id":"clw5r6ozk004nqwvd7p2i3n40","tag_id":"clw5r6ozm0054qwvd0e444xy2","_id":"clw5r6ozn0059qwvd7cy36fac"},{"post_id":"clw5r6ozk004nqwvd7p2i3n40","tag_id":"clw5r6ozn0056qwvd1j6r4duq","_id":"clw5r6ozn005aqwvdez6y392w"},{"post_id":"clw5r6ozk004nqwvd7p2i3n40","tag_id":"clw5r6ozn0057qwvderrmaokz","_id":"clw5r6ozn005bqwvd9j9rdfut"},{"post_id":"clw5r6ozl004sqwvddfhs673c","tag_id":"clw5r6ozn0058qwvd8p0lgac4","_id":"clw5r6ozn005cqwvdah761n99"},{"post_id":"clw68as2k00003gvd8yt99gry","tag_id":"clw68as2r00013gvddaqcfevd","_id":"clw68as3100033gvd8hpz02hr"}],"Tag":[{"name":"DDD","_id":"clw5r6oym0005qwvdhu7ge7cc"},{"name":"Flink","_id":"clw5r6oyp000cqwvdg8go11nl"},{"name":"大数据","_id":"clw5r6oyr000iqwvdgi9ea9c4"},{"name":"java","_id":"clw5r6oys000nqwvdhj0wcj9z"},{"name":"JVM","_id":"clw5r6oyv000vqwvddfwtg71c"},{"name":"垃圾回收","_id":"clw5r6oyx0013qwvd1zgi9z37"},{"name":"gradle","_id":"clw5r6oyz0019qwvdfaao5h5c"},{"name":"hexo","_id":"clw5r6oz0001hqwvd2oifdk2z"},{"name":"blog","_id":"clw5r6oz2001oqwvd1wth3sd0"},{"name":"mybatis","_id":"clw5r6oz3001wqwvd1cnq0cv9"},{"name":"OLAP","_id":"clw5r6oz50023qwvd6qjy9iz2"},{"name":"clickhouse","_id":"clw5r6oz60029qwvd2nk57n5o"},{"name":"RBAC","_id":"clw5r6oz7002fqwvdf61h8f2s"},{"name":"redis","_id":"clw5r6oz9002pqwvdcw1qbksb"},{"name":"Redis","_id":"clw5r6oza002vqwvd3tjc4gx0"},{"name":"Spark","_id":"clw5r6oza0030qwvd5t2gb0ep"},{"name":"spring cache","_id":"clw5r6ozb0034qwvdakkjcay9"},{"name":"spring增强","_id":"clw5r6ozb0037qwvd5swvh5fx"},{"name":"Spring源码","_id":"clw5r6ozb003bqwvddujme5is"},{"name":"Tidb","_id":"clw5r6ozc003fqwvdg36q6wqq"},{"name":"spring-aop","_id":"clw5r6ozc003hqwvd6klzfh0n"},{"name":"AspectJ","_id":"clw5r6ozc003jqwvd8rzlfu3q"},{"name":"arthas","_id":"clw5r6ozc003kqwvd93qre0aa"},{"name":"spring event","_id":"clw5r6ozd003pqwvd9s8e2hcj"},{"name":"dataX","_id":"clw5r6ozd003rqwvdd5ri4ng8"},{"name":"grpc","_id":"clw5r6ozd003tqwvdbyj43fjt"},{"name":"jdbc","_id":"clw5r6ozd003vqwvd0bdm33lu"},{"name":"数据库","_id":"clw5r6ozd003xqwvd57oqcxhj"},{"name":"kafka","_id":"clw5r6oze003yqwvd2i7v6eih"},{"name":"kubernetes","_id":"clw5r6oze0041qwvdcoamdaef"},{"name":"protobuf","_id":"clw5r6ozf0048qwvd52d1bl4h"},{"name":"skywalking","_id":"clw5r6ozj004fqwvd1nlbfjay"},{"name":"OOM","_id":"clw5r6ozk004lqwvdd4vw4mmt"},{"name":"k8s","_id":"clw5r6ozl004rqwvd9vo17ajv"},{"name":"限流","_id":"clw5r6ozm004wqwvd9vnt3zx0"},{"name":"sentinel","_id":"clw5r6ozm0050qwvdaum3bk9k"},{"name":"压力测试","_id":"clw5r6ozm0051qwvdf4t2gv7w"},{"name":"SSE","_id":"clw5r6ozm0054qwvd0e444xy2"},{"name":"websocket","_id":"clw5r6ozn0056qwvd1j6r4duq"},{"name":"comet","_id":"clw5r6ozn0057qwvderrmaokz"},{"name":"跨域","_id":"clw5r6ozn0058qwvd8p0lgac4"},{"name":"Raft","_id":"clw68as2r00013gvddaqcfevd"}]}}